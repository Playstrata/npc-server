
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model BankTransaction
 * 
 */
export type BankTransaction = $Result.DefaultSelection<Prisma.$BankTransactionPayload>
/**
 * Model CharacterKnowledge
 * 
 */
export type CharacterKnowledge = $Result.DefaultSelection<Prisma.$CharacterKnowledgePayload>
/**
 * Model CharacterSkill
 * 
 */
export type CharacterSkill = $Result.DefaultSelection<Prisma.$CharacterSkillPayload>
/**
 * Model DeliveryQuest
 * 
 */
export type DeliveryQuest = $Result.DefaultSelection<Prisma.$DeliveryQuestPayload>
/**
 * Model GameCharacter
 * 
 */
export type GameCharacter = $Result.DefaultSelection<Prisma.$GameCharacterPayload>
/**
 * Model JobChangeHistory
 * 
 */
export type JobChangeHistory = $Result.DefaultSelection<Prisma.$JobChangeHistoryPayload>
/**
 * Model LoanPayment
 * 
 */
export type LoanPayment = $Result.DefaultSelection<Prisma.$LoanPaymentPayload>
/**
 * Model Loan
 * 
 */
export type Loan = $Result.DefaultSelection<Prisma.$LoanPayload>
/**
 * Model LogisticsTracking
 * 
 */
export type LogisticsTracking = $Result.DefaultSelection<Prisma.$LogisticsTrackingPayload>
/**
 * Model MagicalStorage
 * 
 */
export type MagicalStorage = $Result.DefaultSelection<Prisma.$MagicalStoragePayload>
/**
 * Model NpcDeliveryRoute
 * 
 */
export type NpcDeliveryRoute = $Result.DefaultSelection<Prisma.$NpcDeliveryRoutePayload>
/**
 * Model OAuthProviders
 * 
 */
export type OAuthProviders = $Result.DefaultSelection<Prisma.$OAuthProvidersPayload>
/**
 * Model PlayerInventory
 * 
 */
export type PlayerInventory = $Result.DefaultSelection<Prisma.$PlayerInventoryPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model SkillDecayLog
 * 
 */
export type SkillDecayLog = $Result.DefaultSelection<Prisma.$SkillDecayLogPayload>
/**
 * Model SkillPracticeHistory
 * 
 */
export type SkillPracticeHistory = $Result.DefaultSelection<Prisma.$SkillPracticeHistoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserEmail
 * 
 */
export type UserEmail = $Result.DefaultSelection<Prisma.$UserEmailPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model UserPresence
 * 
 */
export type UserPresence = $Result.DefaultSelection<Prisma.$UserPresencePayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Jwks
 * 
 */
export type Jwks = $Result.DefaultSelection<Prisma.$JwksPayload>
/**
 * Model FriendRequest
 * 
 */
export type FriendRequest = $Result.DefaultSelection<Prisma.$FriendRequestPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model BlockedUser
 * 
 */
export type BlockedUser = $Result.DefaultSelection<Prisma.$BlockedUserPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model ForumTopic
 * 
 */
export type ForumTopic = $Result.DefaultSelection<Prisma.$ForumTopicPayload>
/**
 * Model ForumReply
 * 
 */
export type ForumReply = $Result.DefaultSelection<Prisma.$ForumReplyPayload>
/**
 * Model ForumTopicLike
 * 
 */
export type ForumTopicLike = $Result.DefaultSelection<Prisma.$ForumTopicLikePayload>
/**
 * Model ForumReplyLike
 * 
 */
export type ForumReplyLike = $Result.DefaultSelection<Prisma.$ForumReplyLikePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FriendRequestStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type FriendRequestStatus = (typeof FriendRequestStatus)[keyof typeof FriendRequestStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const ForumCategory: {
  GENERAL_DISCUSSION: 'GENERAL_DISCUSSION',
  GAME_GUIDES: 'GAME_GUIDES',
  BUG_REPORTS: 'BUG_REPORTS',
  FEATURE_REQUESTS: 'FEATURE_REQUESTS',
  TRADING_POST: 'TRADING_POST',
  GUILD_RECRUITMENT: 'GUILD_RECRUITMENT'
};

export type ForumCategory = (typeof ForumCategory)[keyof typeof ForumCategory]


export const TopicType: {
  DISCUSSION: 'DISCUSSION',
  QUESTION: 'QUESTION',
  GUIDE: 'GUIDE',
  ANNOUNCEMENT: 'ANNOUNCEMENT'
};

export type TopicType = (typeof TopicType)[keyof typeof TopicType]

}

export type FriendRequestStatus = $Enums.FriendRequestStatus

export const FriendRequestStatus: typeof $Enums.FriendRequestStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type ForumCategory = $Enums.ForumCategory

export const ForumCategory: typeof $Enums.ForumCategory

export type TopicType = $Enums.TopicType

export const TopicType: typeof $Enums.TopicType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs>;

  /**
   * `prisma.bankTransaction`: Exposes CRUD operations for the **BankTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankTransactions
    * const bankTransactions = await prisma.bankTransaction.findMany()
    * ```
    */
  get bankTransaction(): Prisma.BankTransactionDelegate<ExtArgs>;

  /**
   * `prisma.characterKnowledge`: Exposes CRUD operations for the **CharacterKnowledge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterKnowledges
    * const characterKnowledges = await prisma.characterKnowledge.findMany()
    * ```
    */
  get characterKnowledge(): Prisma.CharacterKnowledgeDelegate<ExtArgs>;

  /**
   * `prisma.characterSkill`: Exposes CRUD operations for the **CharacterSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterSkills
    * const characterSkills = await prisma.characterSkill.findMany()
    * ```
    */
  get characterSkill(): Prisma.CharacterSkillDelegate<ExtArgs>;

  /**
   * `prisma.deliveryQuest`: Exposes CRUD operations for the **DeliveryQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryQuests
    * const deliveryQuests = await prisma.deliveryQuest.findMany()
    * ```
    */
  get deliveryQuest(): Prisma.DeliveryQuestDelegate<ExtArgs>;

  /**
   * `prisma.gameCharacter`: Exposes CRUD operations for the **GameCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameCharacters
    * const gameCharacters = await prisma.gameCharacter.findMany()
    * ```
    */
  get gameCharacter(): Prisma.GameCharacterDelegate<ExtArgs>;

  /**
   * `prisma.jobChangeHistory`: Exposes CRUD operations for the **JobChangeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobChangeHistories
    * const jobChangeHistories = await prisma.jobChangeHistory.findMany()
    * ```
    */
  get jobChangeHistory(): Prisma.JobChangeHistoryDelegate<ExtArgs>;

  /**
   * `prisma.loanPayment`: Exposes CRUD operations for the **LoanPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanPayments
    * const loanPayments = await prisma.loanPayment.findMany()
    * ```
    */
  get loanPayment(): Prisma.LoanPaymentDelegate<ExtArgs>;

  /**
   * `prisma.loan`: Exposes CRUD operations for the **Loan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loan.findMany()
    * ```
    */
  get loan(): Prisma.LoanDelegate<ExtArgs>;

  /**
   * `prisma.logisticsTracking`: Exposes CRUD operations for the **LogisticsTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogisticsTrackings
    * const logisticsTrackings = await prisma.logisticsTracking.findMany()
    * ```
    */
  get logisticsTracking(): Prisma.LogisticsTrackingDelegate<ExtArgs>;

  /**
   * `prisma.magicalStorage`: Exposes CRUD operations for the **MagicalStorage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicalStorages
    * const magicalStorages = await prisma.magicalStorage.findMany()
    * ```
    */
  get magicalStorage(): Prisma.MagicalStorageDelegate<ExtArgs>;

  /**
   * `prisma.npcDeliveryRoute`: Exposes CRUD operations for the **NpcDeliveryRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NpcDeliveryRoutes
    * const npcDeliveryRoutes = await prisma.npcDeliveryRoute.findMany()
    * ```
    */
  get npcDeliveryRoute(): Prisma.NpcDeliveryRouteDelegate<ExtArgs>;

  /**
   * `prisma.oAuthProviders`: Exposes CRUD operations for the **OAuthProviders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthProviders
    * const oAuthProviders = await prisma.oAuthProviders.findMany()
    * ```
    */
  get oAuthProviders(): Prisma.OAuthProvidersDelegate<ExtArgs>;

  /**
   * `prisma.playerInventory`: Exposes CRUD operations for the **PlayerInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerInventories
    * const playerInventories = await prisma.playerInventory.findMany()
    * ```
    */
  get playerInventory(): Prisma.PlayerInventoryDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.skillDecayLog`: Exposes CRUD operations for the **SkillDecayLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillDecayLogs
    * const skillDecayLogs = await prisma.skillDecayLog.findMany()
    * ```
    */
  get skillDecayLog(): Prisma.SkillDecayLogDelegate<ExtArgs>;

  /**
   * `prisma.skillPracticeHistory`: Exposes CRUD operations for the **SkillPracticeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillPracticeHistories
    * const skillPracticeHistories = await prisma.skillPracticeHistory.findMany()
    * ```
    */
  get skillPracticeHistory(): Prisma.SkillPracticeHistoryDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userEmail`: Exposes CRUD operations for the **UserEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEmails
    * const userEmails = await prisma.userEmail.findMany()
    * ```
    */
  get userEmail(): Prisma.UserEmailDelegate<ExtArgs>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.userPresence`: Exposes CRUD operations for the **UserPresence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPresences
    * const userPresences = await prisma.userPresence.findMany()
    * ```
    */
  get userPresence(): Prisma.UserPresenceDelegate<ExtArgs>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs>;

  /**
   * `prisma.jwks`: Exposes CRUD operations for the **Jwks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jwks
    * const jwks = await prisma.jwks.findMany()
    * ```
    */
  get jwks(): Prisma.JwksDelegate<ExtArgs>;

  /**
   * `prisma.friendRequest`: Exposes CRUD operations for the **FriendRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendRequests
    * const friendRequests = await prisma.friendRequest.findMany()
    * ```
    */
  get friendRequest(): Prisma.FriendRequestDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs>;

  /**
   * `prisma.blockedUser`: Exposes CRUD operations for the **BlockedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedUsers
    * const blockedUsers = await prisma.blockedUser.findMany()
    * ```
    */
  get blockedUser(): Prisma.BlockedUserDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.forumTopic`: Exposes CRUD operations for the **ForumTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumTopics
    * const forumTopics = await prisma.forumTopic.findMany()
    * ```
    */
  get forumTopic(): Prisma.ForumTopicDelegate<ExtArgs>;

  /**
   * `prisma.forumReply`: Exposes CRUD operations for the **ForumReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumReplies
    * const forumReplies = await prisma.forumReply.findMany()
    * ```
    */
  get forumReply(): Prisma.ForumReplyDelegate<ExtArgs>;

  /**
   * `prisma.forumTopicLike`: Exposes CRUD operations for the **ForumTopicLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumTopicLikes
    * const forumTopicLikes = await prisma.forumTopicLike.findMany()
    * ```
    */
  get forumTopicLike(): Prisma.ForumTopicLikeDelegate<ExtArgs>;

  /**
   * `prisma.forumReplyLike`: Exposes CRUD operations for the **ForumReplyLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumReplyLikes
    * const forumReplyLikes = await prisma.forumReplyLike.findMany()
    * ```
    */
  get forumReplyLike(): Prisma.ForumReplyLikeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    BankAccount: 'BankAccount',
    BankTransaction: 'BankTransaction',
    CharacterKnowledge: 'CharacterKnowledge',
    CharacterSkill: 'CharacterSkill',
    DeliveryQuest: 'DeliveryQuest',
    GameCharacter: 'GameCharacter',
    JobChangeHistory: 'JobChangeHistory',
    LoanPayment: 'LoanPayment',
    Loan: 'Loan',
    LogisticsTracking: 'LogisticsTracking',
    MagicalStorage: 'MagicalStorage',
    NpcDeliveryRoute: 'NpcDeliveryRoute',
    OAuthProviders: 'OAuthProviders',
    PlayerInventory: 'PlayerInventory',
    Session: 'Session',
    SkillDecayLog: 'SkillDecayLog',
    SkillPracticeHistory: 'SkillPracticeHistory',
    User: 'User',
    UserEmail: 'UserEmail',
    UserProfile: 'UserProfile',
    UserSettings: 'UserSettings',
    UserPresence: 'UserPresence',
    Verification: 'Verification',
    Jwks: 'Jwks',
    FriendRequest: 'FriendRequest',
    Friendship: 'Friendship',
    BlockedUser: 'BlockedUser',
    Message: 'Message',
    Post: 'Post',
    Comment: 'Comment',
    Like: 'Like',
    ForumTopic: 'ForumTopic',
    ForumReply: 'ForumReply',
    ForumTopicLike: 'ForumTopicLike',
    ForumReplyLike: 'ForumReplyLike'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "account" | "bankAccount" | "bankTransaction" | "characterKnowledge" | "characterSkill" | "deliveryQuest" | "gameCharacter" | "jobChangeHistory" | "loanPayment" | "loan" | "logisticsTracking" | "magicalStorage" | "npcDeliveryRoute" | "oAuthProviders" | "playerInventory" | "session" | "skillDecayLog" | "skillPracticeHistory" | "user" | "userEmail" | "userProfile" | "userSettings" | "userPresence" | "verification" | "jwks" | "friendRequest" | "friendship" | "blockedUser" | "message" | "post" | "comment" | "like" | "forumTopic" | "forumReply" | "forumTopicLike" | "forumReplyLike"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      BankTransaction: {
        payload: Prisma.$BankTransactionPayload<ExtArgs>
        fields: Prisma.BankTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findFirst: {
            args: Prisma.BankTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findMany: {
            args: Prisma.BankTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          create: {
            args: Prisma.BankTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          createMany: {
            args: Prisma.BankTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          delete: {
            args: Prisma.BankTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          update: {
            args: Prisma.BankTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BankTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          aggregate: {
            args: Prisma.BankTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankTransaction>
          }
          groupBy: {
            args: Prisma.BankTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionCountAggregateOutputType> | number
          }
        }
      }
      CharacterKnowledge: {
        payload: Prisma.$CharacterKnowledgePayload<ExtArgs>
        fields: Prisma.CharacterKnowledgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterKnowledgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterKnowledgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>
          }
          findFirst: {
            args: Prisma.CharacterKnowledgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterKnowledgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>
          }
          findMany: {
            args: Prisma.CharacterKnowledgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>[]
          }
          create: {
            args: Prisma.CharacterKnowledgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>
          }
          createMany: {
            args: Prisma.CharacterKnowledgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterKnowledgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>[]
          }
          delete: {
            args: Prisma.CharacterKnowledgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>
          }
          update: {
            args: Prisma.CharacterKnowledgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>
          }
          deleteMany: {
            args: Prisma.CharacterKnowledgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterKnowledgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterKnowledgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterKnowledgePayload>
          }
          aggregate: {
            args: Prisma.CharacterKnowledgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterKnowledge>
          }
          groupBy: {
            args: Prisma.CharacterKnowledgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterKnowledgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterKnowledgeCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterKnowledgeCountAggregateOutputType> | number
          }
        }
      }
      CharacterSkill: {
        payload: Prisma.$CharacterSkillPayload<ExtArgs>
        fields: Prisma.CharacterSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findFirst: {
            args: Prisma.CharacterSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findMany: {
            args: Prisma.CharacterSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          create: {
            args: Prisma.CharacterSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          createMany: {
            args: Prisma.CharacterSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          delete: {
            args: Prisma.CharacterSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          update: {
            args: Prisma.CharacterSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          deleteMany: {
            args: Prisma.CharacterSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          aggregate: {
            args: Prisma.CharacterSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterSkill>
          }
          groupBy: {
            args: Prisma.CharacterSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterSkillCountAggregateOutputType> | number
          }
        }
      }
      DeliveryQuest: {
        payload: Prisma.$DeliveryQuestPayload<ExtArgs>
        fields: Prisma.DeliveryQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryQuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryQuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>
          }
          findFirst: {
            args: Prisma.DeliveryQuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryQuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>
          }
          findMany: {
            args: Prisma.DeliveryQuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>[]
          }
          create: {
            args: Prisma.DeliveryQuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>
          }
          createMany: {
            args: Prisma.DeliveryQuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryQuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>[]
          }
          delete: {
            args: Prisma.DeliveryQuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>
          }
          update: {
            args: Prisma.DeliveryQuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryQuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryQuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryQuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryQuestPayload>
          }
          aggregate: {
            args: Prisma.DeliveryQuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryQuest>
          }
          groupBy: {
            args: Prisma.DeliveryQuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryQuestCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryQuestCountAggregateOutputType> | number
          }
        }
      }
      GameCharacter: {
        payload: Prisma.$GameCharacterPayload<ExtArgs>
        fields: Prisma.GameCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameCharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameCharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>
          }
          findFirst: {
            args: Prisma.GameCharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameCharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>
          }
          findMany: {
            args: Prisma.GameCharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>[]
          }
          create: {
            args: Prisma.GameCharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>
          }
          createMany: {
            args: Prisma.GameCharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>[]
          }
          delete: {
            args: Prisma.GameCharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>
          }
          update: {
            args: Prisma.GameCharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>
          }
          deleteMany: {
            args: Prisma.GameCharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameCharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameCharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameCharacterPayload>
          }
          aggregate: {
            args: Prisma.GameCharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameCharacter>
          }
          groupBy: {
            args: Prisma.GameCharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCharacterCountArgs<ExtArgs>
            result: $Utils.Optional<GameCharacterCountAggregateOutputType> | number
          }
        }
      }
      JobChangeHistory: {
        payload: Prisma.$JobChangeHistoryPayload<ExtArgs>
        fields: Prisma.JobChangeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobChangeHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobChangeHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>
          }
          findFirst: {
            args: Prisma.JobChangeHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobChangeHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>
          }
          findMany: {
            args: Prisma.JobChangeHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>[]
          }
          create: {
            args: Prisma.JobChangeHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>
          }
          createMany: {
            args: Prisma.JobChangeHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobChangeHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>[]
          }
          delete: {
            args: Prisma.JobChangeHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>
          }
          update: {
            args: Prisma.JobChangeHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.JobChangeHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobChangeHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobChangeHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobChangeHistoryPayload>
          }
          aggregate: {
            args: Prisma.JobChangeHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobChangeHistory>
          }
          groupBy: {
            args: Prisma.JobChangeHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobChangeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobChangeHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<JobChangeHistoryCountAggregateOutputType> | number
          }
        }
      }
      LoanPayment: {
        payload: Prisma.$LoanPaymentPayload<ExtArgs>
        fields: Prisma.LoanPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          findFirst: {
            args: Prisma.LoanPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          findMany: {
            args: Prisma.LoanPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          create: {
            args: Prisma.LoanPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          createMany: {
            args: Prisma.LoanPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          delete: {
            args: Prisma.LoanPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          update: {
            args: Prisma.LoanPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          deleteMany: {
            args: Prisma.LoanPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoanPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          aggregate: {
            args: Prisma.LoanPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanPayment>
          }
          groupBy: {
            args: Prisma.LoanPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<LoanPaymentCountAggregateOutputType> | number
          }
        }
      }
      Loan: {
        payload: Prisma.$LoanPayload<ExtArgs>
        fields: Prisma.LoanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          findFirst: {
            args: Prisma.LoanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          findMany: {
            args: Prisma.LoanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          create: {
            args: Prisma.LoanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          createMany: {
            args: Prisma.LoanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          delete: {
            args: Prisma.LoanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          update: {
            args: Prisma.LoanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          deleteMany: {
            args: Prisma.LoanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          aggregate: {
            args: Prisma.LoanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoan>
          }
          groupBy: {
            args: Prisma.LoanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanCountArgs<ExtArgs>
            result: $Utils.Optional<LoanCountAggregateOutputType> | number
          }
        }
      }
      LogisticsTracking: {
        payload: Prisma.$LogisticsTrackingPayload<ExtArgs>
        fields: Prisma.LogisticsTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogisticsTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogisticsTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>
          }
          findFirst: {
            args: Prisma.LogisticsTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogisticsTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>
          }
          findMany: {
            args: Prisma.LogisticsTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>[]
          }
          create: {
            args: Prisma.LogisticsTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>
          }
          createMany: {
            args: Prisma.LogisticsTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogisticsTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>[]
          }
          delete: {
            args: Prisma.LogisticsTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>
          }
          update: {
            args: Prisma.LogisticsTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>
          }
          deleteMany: {
            args: Prisma.LogisticsTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogisticsTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogisticsTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogisticsTrackingPayload>
          }
          aggregate: {
            args: Prisma.LogisticsTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogisticsTracking>
          }
          groupBy: {
            args: Prisma.LogisticsTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogisticsTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogisticsTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<LogisticsTrackingCountAggregateOutputType> | number
          }
        }
      }
      MagicalStorage: {
        payload: Prisma.$MagicalStoragePayload<ExtArgs>
        fields: Prisma.MagicalStorageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicalStorageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicalStorageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>
          }
          findFirst: {
            args: Prisma.MagicalStorageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicalStorageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>
          }
          findMany: {
            args: Prisma.MagicalStorageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>[]
          }
          create: {
            args: Prisma.MagicalStorageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>
          }
          createMany: {
            args: Prisma.MagicalStorageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicalStorageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>[]
          }
          delete: {
            args: Prisma.MagicalStorageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>
          }
          update: {
            args: Prisma.MagicalStorageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>
          }
          deleteMany: {
            args: Prisma.MagicalStorageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicalStorageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MagicalStorageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicalStoragePayload>
          }
          aggregate: {
            args: Prisma.MagicalStorageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicalStorage>
          }
          groupBy: {
            args: Prisma.MagicalStorageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicalStorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicalStorageCountArgs<ExtArgs>
            result: $Utils.Optional<MagicalStorageCountAggregateOutputType> | number
          }
        }
      }
      NpcDeliveryRoute: {
        payload: Prisma.$NpcDeliveryRoutePayload<ExtArgs>
        fields: Prisma.NpcDeliveryRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NpcDeliveryRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NpcDeliveryRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>
          }
          findFirst: {
            args: Prisma.NpcDeliveryRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NpcDeliveryRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>
          }
          findMany: {
            args: Prisma.NpcDeliveryRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>[]
          }
          create: {
            args: Prisma.NpcDeliveryRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>
          }
          createMany: {
            args: Prisma.NpcDeliveryRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NpcDeliveryRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>[]
          }
          delete: {
            args: Prisma.NpcDeliveryRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>
          }
          update: {
            args: Prisma.NpcDeliveryRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>
          }
          deleteMany: {
            args: Prisma.NpcDeliveryRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NpcDeliveryRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NpcDeliveryRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NpcDeliveryRoutePayload>
          }
          aggregate: {
            args: Prisma.NpcDeliveryRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNpcDeliveryRoute>
          }
          groupBy: {
            args: Prisma.NpcDeliveryRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NpcDeliveryRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NpcDeliveryRouteCountArgs<ExtArgs>
            result: $Utils.Optional<NpcDeliveryRouteCountAggregateOutputType> | number
          }
        }
      }
      OAuthProviders: {
        payload: Prisma.$OAuthProvidersPayload<ExtArgs>
        fields: Prisma.OAuthProvidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthProvidersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthProvidersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>
          }
          findFirst: {
            args: Prisma.OAuthProvidersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthProvidersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>
          }
          findMany: {
            args: Prisma.OAuthProvidersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>[]
          }
          create: {
            args: Prisma.OAuthProvidersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>
          }
          createMany: {
            args: Prisma.OAuthProvidersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthProvidersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>[]
          }
          delete: {
            args: Prisma.OAuthProvidersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>
          }
          update: {
            args: Prisma.OAuthProvidersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>
          }
          deleteMany: {
            args: Prisma.OAuthProvidersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthProvidersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthProvidersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthProvidersPayload>
          }
          aggregate: {
            args: Prisma.OAuthProvidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthProviders>
          }
          groupBy: {
            args: Prisma.OAuthProvidersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthProvidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthProvidersCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthProvidersCountAggregateOutputType> | number
          }
        }
      }
      PlayerInventory: {
        payload: Prisma.$PlayerInventoryPayload<ExtArgs>
        fields: Prisma.PlayerInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>
          }
          findFirst: {
            args: Prisma.PlayerInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>
          }
          findMany: {
            args: Prisma.PlayerInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>[]
          }
          create: {
            args: Prisma.PlayerInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>
          }
          createMany: {
            args: Prisma.PlayerInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>[]
          }
          delete: {
            args: Prisma.PlayerInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>
          }
          update: {
            args: Prisma.PlayerInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>
          }
          deleteMany: {
            args: Prisma.PlayerInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerInventoryPayload>
          }
          aggregate: {
            args: Prisma.PlayerInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerInventory>
          }
          groupBy: {
            args: Prisma.PlayerInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerInventoryCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      SkillDecayLog: {
        payload: Prisma.$SkillDecayLogPayload<ExtArgs>
        fields: Prisma.SkillDecayLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillDecayLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillDecayLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>
          }
          findFirst: {
            args: Prisma.SkillDecayLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillDecayLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>
          }
          findMany: {
            args: Prisma.SkillDecayLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>[]
          }
          create: {
            args: Prisma.SkillDecayLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>
          }
          createMany: {
            args: Prisma.SkillDecayLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillDecayLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>[]
          }
          delete: {
            args: Prisma.SkillDecayLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>
          }
          update: {
            args: Prisma.SkillDecayLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>
          }
          deleteMany: {
            args: Prisma.SkillDecayLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillDecayLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillDecayLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillDecayLogPayload>
          }
          aggregate: {
            args: Prisma.SkillDecayLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillDecayLog>
          }
          groupBy: {
            args: Prisma.SkillDecayLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillDecayLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillDecayLogCountArgs<ExtArgs>
            result: $Utils.Optional<SkillDecayLogCountAggregateOutputType> | number
          }
        }
      }
      SkillPracticeHistory: {
        payload: Prisma.$SkillPracticeHistoryPayload<ExtArgs>
        fields: Prisma.SkillPracticeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillPracticeHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillPracticeHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>
          }
          findFirst: {
            args: Prisma.SkillPracticeHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillPracticeHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>
          }
          findMany: {
            args: Prisma.SkillPracticeHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>[]
          }
          create: {
            args: Prisma.SkillPracticeHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>
          }
          createMany: {
            args: Prisma.SkillPracticeHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillPracticeHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>[]
          }
          delete: {
            args: Prisma.SkillPracticeHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>
          }
          update: {
            args: Prisma.SkillPracticeHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SkillPracticeHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillPracticeHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillPracticeHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPracticeHistoryPayload>
          }
          aggregate: {
            args: Prisma.SkillPracticeHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillPracticeHistory>
          }
          groupBy: {
            args: Prisma.SkillPracticeHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillPracticeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillPracticeHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SkillPracticeHistoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserEmail: {
        payload: Prisma.$UserEmailPayload<ExtArgs>
        fields: Prisma.UserEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          findFirst: {
            args: Prisma.UserEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          findMany: {
            args: Prisma.UserEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>[]
          }
          create: {
            args: Prisma.UserEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          createMany: {
            args: Prisma.UserEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>[]
          }
          delete: {
            args: Prisma.UserEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          update: {
            args: Prisma.UserEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          deleteMany: {
            args: Prisma.UserEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEmailPayload>
          }
          aggregate: {
            args: Prisma.UserEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEmail>
          }
          groupBy: {
            args: Prisma.UserEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEmailCountArgs<ExtArgs>
            result: $Utils.Optional<UserEmailCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserPresence: {
        payload: Prisma.$UserPresencePayload<ExtArgs>
        fields: Prisma.UserPresenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPresenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPresenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          findFirst: {
            args: Prisma.UserPresenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPresenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          findMany: {
            args: Prisma.UserPresenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          create: {
            args: Prisma.UserPresenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          createMany: {
            args: Prisma.UserPresenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPresenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          delete: {
            args: Prisma.UserPresenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          update: {
            args: Prisma.UserPresenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          deleteMany: {
            args: Prisma.UserPresenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPresenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPresenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          aggregate: {
            args: Prisma.UserPresenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPresence>
          }
          groupBy: {
            args: Prisma.UserPresenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPresenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPresenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPresenceCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Jwks: {
        payload: Prisma.$JwksPayload<ExtArgs>
        fields: Prisma.JwksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JwksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JwksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>
          }
          findFirst: {
            args: Prisma.JwksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JwksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>
          }
          findMany: {
            args: Prisma.JwksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>[]
          }
          create: {
            args: Prisma.JwksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>
          }
          createMany: {
            args: Prisma.JwksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JwksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>[]
          }
          delete: {
            args: Prisma.JwksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>
          }
          update: {
            args: Prisma.JwksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>
          }
          deleteMany: {
            args: Prisma.JwksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JwksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JwksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwksPayload>
          }
          aggregate: {
            args: Prisma.JwksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJwks>
          }
          groupBy: {
            args: Prisma.JwksGroupByArgs<ExtArgs>
            result: $Utils.Optional<JwksGroupByOutputType>[]
          }
          count: {
            args: Prisma.JwksCountArgs<ExtArgs>
            result: $Utils.Optional<JwksCountAggregateOutputType> | number
          }
        }
      }
      FriendRequest: {
        payload: Prisma.$FriendRequestPayload<ExtArgs>
        fields: Prisma.FriendRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          findFirst: {
            args: Prisma.FriendRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          findMany: {
            args: Prisma.FriendRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>[]
          }
          create: {
            args: Prisma.FriendRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          createMany: {
            args: Prisma.FriendRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>[]
          }
          delete: {
            args: Prisma.FriendRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          update: {
            args: Prisma.FriendRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          deleteMany: {
            args: Prisma.FriendRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          aggregate: {
            args: Prisma.FriendRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendRequest>
          }
          groupBy: {
            args: Prisma.FriendRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendRequestCountArgs<ExtArgs>
            result: $Utils.Optional<FriendRequestCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      BlockedUser: {
        payload: Prisma.$BlockedUserPayload<ExtArgs>
        fields: Prisma.BlockedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findFirst: {
            args: Prisma.BlockedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findMany: {
            args: Prisma.BlockedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          create: {
            args: Prisma.BlockedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          createMany: {
            args: Prisma.BlockedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          delete: {
            args: Prisma.BlockedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          update: {
            args: Prisma.BlockedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          deleteMany: {
            args: Prisma.BlockedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          aggregate: {
            args: Prisma.BlockedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedUser>
          }
          groupBy: {
            args: Prisma.BlockedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedUserCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      ForumTopic: {
        payload: Prisma.$ForumTopicPayload<ExtArgs>
        fields: Prisma.ForumTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          findFirst: {
            args: Prisma.ForumTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          findMany: {
            args: Prisma.ForumTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          create: {
            args: Prisma.ForumTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          createMany: {
            args: Prisma.ForumTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          delete: {
            args: Prisma.ForumTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          update: {
            args: Prisma.ForumTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          deleteMany: {
            args: Prisma.ForumTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          aggregate: {
            args: Prisma.ForumTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumTopic>
          }
          groupBy: {
            args: Prisma.ForumTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumTopicCountArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicCountAggregateOutputType> | number
          }
        }
      }
      ForumReply: {
        payload: Prisma.$ForumReplyPayload<ExtArgs>
        fields: Prisma.ForumReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          findFirst: {
            args: Prisma.ForumReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          findMany: {
            args: Prisma.ForumReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>[]
          }
          create: {
            args: Prisma.ForumReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          createMany: {
            args: Prisma.ForumReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>[]
          }
          delete: {
            args: Prisma.ForumReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          update: {
            args: Prisma.ForumReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          deleteMany: {
            args: Prisma.ForumReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          aggregate: {
            args: Prisma.ForumReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumReply>
          }
          groupBy: {
            args: Prisma.ForumReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumReplyCountArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyCountAggregateOutputType> | number
          }
        }
      }
      ForumTopicLike: {
        payload: Prisma.$ForumTopicLikePayload<ExtArgs>
        fields: Prisma.ForumTopicLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumTopicLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumTopicLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>
          }
          findFirst: {
            args: Prisma.ForumTopicLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumTopicLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>
          }
          findMany: {
            args: Prisma.ForumTopicLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>[]
          }
          create: {
            args: Prisma.ForumTopicLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>
          }
          createMany: {
            args: Prisma.ForumTopicLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumTopicLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>[]
          }
          delete: {
            args: Prisma.ForumTopicLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>
          }
          update: {
            args: Prisma.ForumTopicLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>
          }
          deleteMany: {
            args: Prisma.ForumTopicLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumTopicLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumTopicLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicLikePayload>
          }
          aggregate: {
            args: Prisma.ForumTopicLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumTopicLike>
          }
          groupBy: {
            args: Prisma.ForumTopicLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumTopicLikeCountArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicLikeCountAggregateOutputType> | number
          }
        }
      }
      ForumReplyLike: {
        payload: Prisma.$ForumReplyLikePayload<ExtArgs>
        fields: Prisma.ForumReplyLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumReplyLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumReplyLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>
          }
          findFirst: {
            args: Prisma.ForumReplyLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumReplyLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>
          }
          findMany: {
            args: Prisma.ForumReplyLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>[]
          }
          create: {
            args: Prisma.ForumReplyLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>
          }
          createMany: {
            args: Prisma.ForumReplyLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumReplyLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>[]
          }
          delete: {
            args: Prisma.ForumReplyLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>
          }
          update: {
            args: Prisma.ForumReplyLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>
          }
          deleteMany: {
            args: Prisma.ForumReplyLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumReplyLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumReplyLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyLikePayload>
          }
          aggregate: {
            args: Prisma.ForumReplyLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumReplyLike>
          }
          groupBy: {
            args: Prisma.ForumReplyLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumReplyLikeCountArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyLikeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BankAccountCountOutputType
   */

  export type BankAccountCountOutputType = {
    bankTransactions: number
    loans: number
  }

  export type BankAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankTransactions?: boolean | BankAccountCountOutputTypeCountBankTransactionsArgs
    loans?: boolean | BankAccountCountOutputTypeCountLoansArgs
  }

  // Custom InputTypes
  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     */
    select?: BankAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountBankTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
  }


  /**
   * Count Type CharacterSkillCountOutputType
   */

  export type CharacterSkillCountOutputType = {
    skillPracticeHistory: number
  }

  export type CharacterSkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillPracticeHistory?: boolean | CharacterSkillCountOutputTypeCountSkillPracticeHistoryArgs
  }

  // Custom InputTypes
  /**
   * CharacterSkillCountOutputType without action
   */
  export type CharacterSkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkillCountOutputType
     */
    select?: CharacterSkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterSkillCountOutputType without action
   */
  export type CharacterSkillCountOutputTypeCountSkillPracticeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillPracticeHistoryWhereInput
  }


  /**
   * Count Type GameCharacterCountOutputType
   */

  export type GameCharacterCountOutputType = {
    characterKnowledges: number
    characterSkills: number
    jobChangeHistory: number
    magicalStorage: number
    playerInventories: number
  }

  export type GameCharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characterKnowledges?: boolean | GameCharacterCountOutputTypeCountCharacterKnowledgesArgs
    characterSkills?: boolean | GameCharacterCountOutputTypeCountCharacterSkillsArgs
    jobChangeHistory?: boolean | GameCharacterCountOutputTypeCountJobChangeHistoryArgs
    magicalStorage?: boolean | GameCharacterCountOutputTypeCountMagicalStorageArgs
    playerInventories?: boolean | GameCharacterCountOutputTypeCountPlayerInventoriesArgs
  }

  // Custom InputTypes
  /**
   * GameCharacterCountOutputType without action
   */
  export type GameCharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacterCountOutputType
     */
    select?: GameCharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCharacterCountOutputType without action
   */
  export type GameCharacterCountOutputTypeCountCharacterKnowledgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterKnowledgeWhereInput
  }

  /**
   * GameCharacterCountOutputType without action
   */
  export type GameCharacterCountOutputTypeCountCharacterSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
  }

  /**
   * GameCharacterCountOutputType without action
   */
  export type GameCharacterCountOutputTypeCountJobChangeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobChangeHistoryWhereInput
  }

  /**
   * GameCharacterCountOutputType without action
   */
  export type GameCharacterCountOutputTypeCountMagicalStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicalStorageWhereInput
  }

  /**
   * GameCharacterCountOutputType without action
   */
  export type GameCharacterCountOutputTypeCountPlayerInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerInventoryWhereInput
  }


  /**
   * Count Type LoanCountOutputType
   */

  export type LoanCountOutputType = {
    loanPayments: number
  }

  export type LoanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loanPayments?: boolean | LoanCountOutputTypeCountLoanPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanCountOutputType
     */
    select?: LoanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeCountLoanPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    account: number
    session: number
    userEmails: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | UserCountOutputTypeCountAccountArgs
    session?: boolean | UserCountOutputTypeCountSessionArgs
    userEmails?: boolean | UserCountOutputTypeCountUserEmailsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    likes: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    likes?: boolean | PostCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * Count Type ForumTopicCountOutputType
   */

  export type ForumTopicCountOutputType = {
    replies: number
    likes: number
  }

  export type ForumTopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | ForumTopicCountOutputTypeCountRepliesArgs
    likes?: boolean | ForumTopicCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicCountOutputType
     */
    select?: ForumTopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
  }

  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicLikeWhereInput
  }


  /**
   * Count Type ForumReplyCountOutputType
   */

  export type ForumReplyCountOutputType = {
    likes: number
  }

  export type ForumReplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | ForumReplyCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * ForumReplyCountOutputType without action
   */
  export type ForumReplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyCountOutputType
     */
    select?: ForumReplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumReplyCountOutputType without action
   */
  export type ForumReplyCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyLikeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    balance: number | null
    creditScore: number | null
    creditLimit: number | null
    interestRate: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    balance: number | null
    creditScore: number | null
    creditLimit: number | null
    interestRate: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    accountType: string | null
    balance: number | null
    creditScore: number | null
    creditLimit: number | null
    interestRate: number | null
    accountStatus: string | null
    openedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    accountType: string | null
    balance: number | null
    creditScore: number | null
    creditLimit: number | null
    interestRate: number | null
    accountStatus: string | null
    openedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    characterId: number
    accountType: number
    balance: number
    creditScore: number
    creditLimit: number
    interestRate: number
    accountStatus: number
    openedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    balance?: true
    creditScore?: true
    creditLimit?: true
    interestRate?: true
  }

  export type BankAccountSumAggregateInputType = {
    balance?: true
    creditScore?: true
    creditLimit?: true
    interestRate?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    characterId?: true
    accountType?: true
    balance?: true
    creditScore?: true
    creditLimit?: true
    interestRate?: true
    accountStatus?: true
    openedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    characterId?: true
    accountType?: true
    balance?: true
    creditScore?: true
    creditLimit?: true
    interestRate?: true
    accountStatus?: true
    openedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    characterId?: true
    accountType?: true
    balance?: true
    creditScore?: true
    creditLimit?: true
    interestRate?: true
    accountStatus?: true
    openedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    characterId: string
    accountType: string
    balance: number
    creditScore: number
    creditLimit: number
    interestRate: number
    accountStatus: string
    openedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    accountType?: boolean
    balance?: boolean
    creditScore?: boolean
    creditLimit?: boolean
    interestRate?: boolean
    accountStatus?: boolean
    openedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
    bankTransactions?: boolean | BankAccount$bankTransactionsArgs<ExtArgs>
    loans?: boolean | BankAccount$loansArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    accountType?: boolean
    balance?: boolean
    creditScore?: boolean
    creditLimit?: boolean
    interestRate?: boolean
    accountStatus?: boolean
    openedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    characterId?: boolean
    accountType?: boolean
    balance?: boolean
    creditScore?: boolean
    creditLimit?: boolean
    interestRate?: boolean
    accountStatus?: boolean
    openedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
    bankTransactions?: boolean | BankAccount$bankTransactionsArgs<ExtArgs>
    loans?: boolean | BankAccount$loansArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      gameCharacter: Prisma.$GameCharacterPayload<ExtArgs>
      bankTransactions: Prisma.$BankTransactionPayload<ExtArgs>[]
      loans: Prisma.$LoanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      accountType: string
      balance: number
      creditScore: number
      creditLimit: number
      interestRate: number
      accountStatus: string
      openedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameCharacter<T extends GameCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacterDefaultArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bankTransactions<T extends BankAccount$bankTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$bankTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    loans<T extends BankAccount$loansArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */ 
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly characterId: FieldRef<"BankAccount", 'String'>
    readonly accountType: FieldRef<"BankAccount", 'String'>
    readonly balance: FieldRef<"BankAccount", 'Float'>
    readonly creditScore: FieldRef<"BankAccount", 'Int'>
    readonly creditLimit: FieldRef<"BankAccount", 'Float'>
    readonly interestRate: FieldRef<"BankAccount", 'Float'>
    readonly accountStatus: FieldRef<"BankAccount", 'String'>
    readonly openedAt: FieldRef<"BankAccount", 'DateTime'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
  }

  /**
   * BankAccount.bankTransactions
   */
  export type BankAccount$bankTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankAccount.loans
   */
  export type BankAccount$loansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    where?: LoanWhereInput
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    cursor?: LoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model BankTransaction
   */

  export type AggregateBankTransaction = {
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  export type BankTransactionAvgAggregateOutputType = {
    amount: number | null
    balanceAfter: number | null
  }

  export type BankTransactionSumAggregateOutputType = {
    amount: number | null
    balanceAfter: number | null
  }

  export type BankTransactionMinAggregateOutputType = {
    id: string | null
    bankAccountId: string | null
    transactionType: string | null
    amount: number | null
    balanceAfter: number | null
    description: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankTransactionMaxAggregateOutputType = {
    id: string | null
    bankAccountId: string | null
    transactionType: string | null
    amount: number | null
    balanceAfter: number | null
    description: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankTransactionCountAggregateOutputType = {
    id: number
    bankAccountId: number
    transactionType: number
    amount: number
    balanceAfter: number
    description: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankTransactionAvgAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type BankTransactionSumAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type BankTransactionMinAggregateInputType = {
    id?: true
    bankAccountId?: true
    transactionType?: true
    amount?: true
    balanceAfter?: true
    description?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankTransactionMaxAggregateInputType = {
    id?: true
    bankAccountId?: true
    transactionType?: true
    amount?: true
    balanceAfter?: true
    description?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankTransactionCountAggregateInputType = {
    id?: true
    bankAccountId?: true
    transactionType?: true
    amount?: true
    balanceAfter?: true
    description?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransaction to aggregate.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankTransactions
    **/
    _count?: true | BankTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankTransactionMaxAggregateInputType
  }

  export type GetBankTransactionAggregateType<T extends BankTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBankTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankTransaction[P]>
      : GetScalarType<T[P], AggregateBankTransaction[P]>
  }




  export type BankTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithAggregationInput | BankTransactionOrderByWithAggregationInput[]
    by: BankTransactionScalarFieldEnum[] | BankTransactionScalarFieldEnum
    having?: BankTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankTransactionCountAggregateInputType | true
    _avg?: BankTransactionAvgAggregateInputType
    _sum?: BankTransactionSumAggregateInputType
    _min?: BankTransactionMinAggregateInputType
    _max?: BankTransactionMaxAggregateInputType
  }

  export type BankTransactionGroupByOutputType = {
    id: string
    bankAccountId: string
    transactionType: string
    amount: number
    balanceAfter: number
    description: string | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  type GetBankTransactionGroupByPayload<T extends BankTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BankTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceAfter?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceAfter?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectScalar = {
    id?: boolean
    bankAccountId?: boolean
    transactionType?: boolean
    amount?: boolean
    balanceAfter?: boolean
    description?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
  }
  export type BankTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccount?: boolean | BankAccountDefaultArgs<ExtArgs>
  }

  export type $BankTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankTransaction"
    objects: {
      bankAccount: Prisma.$BankAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankAccountId: string
      transactionType: string
      amount: number
      balanceAfter: number
      description: string | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankTransaction"]>
    composites: {}
  }

  type BankTransactionGetPayload<S extends boolean | null | undefined | BankTransactionDefaultArgs> = $Result.GetResult<Prisma.$BankTransactionPayload, S>

  type BankTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankTransactionCountAggregateInputType | true
    }

  export interface BankTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankTransaction'], meta: { name: 'BankTransaction' } }
    /**
     * Find zero or one BankTransaction that matches the filter.
     * @param {BankTransactionFindUniqueArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankTransactionFindUniqueArgs>(args: SelectSubset<T, BankTransactionFindUniqueArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BankTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankTransactionFindUniqueOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BankTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BankTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankTransactionFindFirstArgs>(args?: SelectSubset<T, BankTransactionFindFirstArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BankTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BankTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BankTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany()
     * 
     * // Get first 10 BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankTransactionFindManyArgs>(args?: SelectSubset<T, BankTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BankTransaction.
     * @param {BankTransactionCreateArgs} args - Arguments to create a BankTransaction.
     * @example
     * // Create one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.create({
     *   data: {
     *     // ... data to create a BankTransaction
     *   }
     * })
     * 
     */
    create<T extends BankTransactionCreateArgs>(args: SelectSubset<T, BankTransactionCreateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BankTransactions.
     * @param {BankTransactionCreateManyArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankTransactionCreateManyArgs>(args?: SelectSubset<T, BankTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankTransactions and returns the data saved in the database.
     * @param {BankTransactionCreateManyAndReturnArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankTransactions and only return the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BankTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BankTransaction.
     * @param {BankTransactionDeleteArgs} args - Arguments to delete one BankTransaction.
     * @example
     * // Delete one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.delete({
     *   where: {
     *     // ... filter to delete one BankTransaction
     *   }
     * })
     * 
     */
    delete<T extends BankTransactionDeleteArgs>(args: SelectSubset<T, BankTransactionDeleteArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BankTransaction.
     * @param {BankTransactionUpdateArgs} args - Arguments to update one BankTransaction.
     * @example
     * // Update one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankTransactionUpdateArgs>(args: SelectSubset<T, BankTransactionUpdateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BankTransactions.
     * @param {BankTransactionDeleteManyArgs} args - Arguments to filter BankTransactions to delete.
     * @example
     * // Delete a few BankTransactions
     * const { count } = await prisma.bankTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankTransactionDeleteManyArgs>(args?: SelectSubset<T, BankTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankTransactionUpdateManyArgs>(args: SelectSubset<T, BankTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankTransaction.
     * @param {BankTransactionUpsertArgs} args - Arguments to update or create a BankTransaction.
     * @example
     * // Update or create a BankTransaction
     * const bankTransaction = await prisma.bankTransaction.upsert({
     *   create: {
     *     // ... data to create a BankTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BankTransactionUpsertArgs>(args: SelectSubset<T, BankTransactionUpsertArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionCountArgs} args - Arguments to filter BankTransactions to count.
     * @example
     * // Count the number of BankTransactions
     * const count = await prisma.bankTransaction.count({
     *   where: {
     *     // ... the filter for the BankTransactions we want to count
     *   }
     * })
    **/
    count<T extends BankTransactionCountArgs>(
      args?: Subset<T, BankTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankTransactionAggregateArgs>(args: Subset<T, BankTransactionAggregateArgs>): Prisma.PrismaPromise<GetBankTransactionAggregateType<T>>

    /**
     * Group by BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BankTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankTransaction model
   */
  readonly fields: BankTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankAccount<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankTransaction model
   */ 
  interface BankTransactionFieldRefs {
    readonly id: FieldRef<"BankTransaction", 'String'>
    readonly bankAccountId: FieldRef<"BankTransaction", 'String'>
    readonly transactionType: FieldRef<"BankTransaction", 'String'>
    readonly amount: FieldRef<"BankTransaction", 'Float'>
    readonly balanceAfter: FieldRef<"BankTransaction", 'Float'>
    readonly description: FieldRef<"BankTransaction", 'String'>
    readonly timestamp: FieldRef<"BankTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"BankTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BankTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankTransaction findUnique
   */
  export type BankTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findUniqueOrThrow
   */
  export type BankTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findFirst
   */
  export type BankTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findFirstOrThrow
   */
  export type BankTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findMany
   */
  export type BankTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransactions to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction create
   */
  export type BankTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BankTransaction.
     */
    data: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
  }

  /**
   * BankTransaction createMany
   */
  export type BankTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankTransaction createManyAndReturn
   */
  export type BankTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankTransaction update
   */
  export type BankTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BankTransaction.
     */
    data: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
    /**
     * Choose, which BankTransaction to update.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction updateMany
   */
  export type BankTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankTransactions.
     */
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BankTransactions to update
     */
    where?: BankTransactionWhereInput
  }

  /**
   * BankTransaction upsert
   */
  export type BankTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BankTransaction to update in case it exists.
     */
    where: BankTransactionWhereUniqueInput
    /**
     * In case the BankTransaction found by the `where` argument doesn't exist, create a new BankTransaction with this data.
     */
    create: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
    /**
     * In case the BankTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
  }

  /**
   * BankTransaction delete
   */
  export type BankTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter which BankTransaction to delete.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction deleteMany
   */
  export type BankTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransactions to delete
     */
    where?: BankTransactionWhereInput
  }

  /**
   * BankTransaction without action
   */
  export type BankTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
  }


  /**
   * Model CharacterKnowledge
   */

  export type AggregateCharacterKnowledge = {
    _count: CharacterKnowledgeCountAggregateOutputType | null
    _avg: CharacterKnowledgeAvgAggregateOutputType | null
    _sum: CharacterKnowledgeSumAggregateOutputType | null
    _min: CharacterKnowledgeMinAggregateOutputType | null
    _max: CharacterKnowledgeMaxAggregateOutputType | null
  }

  export type CharacterKnowledgeAvgAggregateOutputType = {
    proficiency: number | null
  }

  export type CharacterKnowledgeSumAggregateOutputType = {
    proficiency: number | null
  }

  export type CharacterKnowledgeMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    skillType: string | null
    knowledgeType: string | null
    knowledgeName: string | null
    description: string | null
    proficiency: number | null
    learnedAt: Date | null
    teacherNpcId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterKnowledgeMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    skillType: string | null
    knowledgeType: string | null
    knowledgeName: string | null
    description: string | null
    proficiency: number | null
    learnedAt: Date | null
    teacherNpcId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterKnowledgeCountAggregateOutputType = {
    id: number
    characterId: number
    skillType: number
    knowledgeType: number
    knowledgeName: number
    description: number
    proficiency: number
    learnedAt: number
    teacherNpcId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterKnowledgeAvgAggregateInputType = {
    proficiency?: true
  }

  export type CharacterKnowledgeSumAggregateInputType = {
    proficiency?: true
  }

  export type CharacterKnowledgeMinAggregateInputType = {
    id?: true
    characterId?: true
    skillType?: true
    knowledgeType?: true
    knowledgeName?: true
    description?: true
    proficiency?: true
    learnedAt?: true
    teacherNpcId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterKnowledgeMaxAggregateInputType = {
    id?: true
    characterId?: true
    skillType?: true
    knowledgeType?: true
    knowledgeName?: true
    description?: true
    proficiency?: true
    learnedAt?: true
    teacherNpcId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterKnowledgeCountAggregateInputType = {
    id?: true
    characterId?: true
    skillType?: true
    knowledgeType?: true
    knowledgeName?: true
    description?: true
    proficiency?: true
    learnedAt?: true
    teacherNpcId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterKnowledgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterKnowledge to aggregate.
     */
    where?: CharacterKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterKnowledges to fetch.
     */
    orderBy?: CharacterKnowledgeOrderByWithRelationInput | CharacterKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterKnowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterKnowledges
    **/
    _count?: true | CharacterKnowledgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterKnowledgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterKnowledgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterKnowledgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterKnowledgeMaxAggregateInputType
  }

  export type GetCharacterKnowledgeAggregateType<T extends CharacterKnowledgeAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterKnowledge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterKnowledge[P]>
      : GetScalarType<T[P], AggregateCharacterKnowledge[P]>
  }




  export type CharacterKnowledgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterKnowledgeWhereInput
    orderBy?: CharacterKnowledgeOrderByWithAggregationInput | CharacterKnowledgeOrderByWithAggregationInput[]
    by: CharacterKnowledgeScalarFieldEnum[] | CharacterKnowledgeScalarFieldEnum
    having?: CharacterKnowledgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterKnowledgeCountAggregateInputType | true
    _avg?: CharacterKnowledgeAvgAggregateInputType
    _sum?: CharacterKnowledgeSumAggregateInputType
    _min?: CharacterKnowledgeMinAggregateInputType
    _max?: CharacterKnowledgeMaxAggregateInputType
  }

  export type CharacterKnowledgeGroupByOutputType = {
    id: string
    characterId: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description: string | null
    proficiency: number
    learnedAt: Date
    teacherNpcId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CharacterKnowledgeCountAggregateOutputType | null
    _avg: CharacterKnowledgeAvgAggregateOutputType | null
    _sum: CharacterKnowledgeSumAggregateOutputType | null
    _min: CharacterKnowledgeMinAggregateOutputType | null
    _max: CharacterKnowledgeMaxAggregateOutputType | null
  }

  type GetCharacterKnowledgeGroupByPayload<T extends CharacterKnowledgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterKnowledgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterKnowledgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterKnowledgeGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterKnowledgeGroupByOutputType[P]>
        }
      >
    >


  export type CharacterKnowledgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    skillType?: boolean
    knowledgeType?: boolean
    knowledgeName?: boolean
    description?: boolean
    proficiency?: boolean
    learnedAt?: boolean
    teacherNpcId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterKnowledge"]>

  export type CharacterKnowledgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    skillType?: boolean
    knowledgeType?: boolean
    knowledgeName?: boolean
    description?: boolean
    proficiency?: boolean
    learnedAt?: boolean
    teacherNpcId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterKnowledge"]>

  export type CharacterKnowledgeSelectScalar = {
    id?: boolean
    characterId?: boolean
    skillType?: boolean
    knowledgeType?: boolean
    knowledgeName?: boolean
    description?: boolean
    proficiency?: boolean
    learnedAt?: boolean
    teacherNpcId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterKnowledgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }
  export type CharacterKnowledgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterKnowledgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterKnowledge"
    objects: {
      gameCharacter: Prisma.$GameCharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      skillType: string
      knowledgeType: string
      knowledgeName: string
      description: string | null
      proficiency: number
      learnedAt: Date
      teacherNpcId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["characterKnowledge"]>
    composites: {}
  }

  type CharacterKnowledgeGetPayload<S extends boolean | null | undefined | CharacterKnowledgeDefaultArgs> = $Result.GetResult<Prisma.$CharacterKnowledgePayload, S>

  type CharacterKnowledgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterKnowledgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterKnowledgeCountAggregateInputType | true
    }

  export interface CharacterKnowledgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterKnowledge'], meta: { name: 'CharacterKnowledge' } }
    /**
     * Find zero or one CharacterKnowledge that matches the filter.
     * @param {CharacterKnowledgeFindUniqueArgs} args - Arguments to find a CharacterKnowledge
     * @example
     * // Get one CharacterKnowledge
     * const characterKnowledge = await prisma.characterKnowledge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterKnowledgeFindUniqueArgs>(args: SelectSubset<T, CharacterKnowledgeFindUniqueArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CharacterKnowledge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterKnowledgeFindUniqueOrThrowArgs} args - Arguments to find a CharacterKnowledge
     * @example
     * // Get one CharacterKnowledge
     * const characterKnowledge = await prisma.characterKnowledge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterKnowledgeFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterKnowledgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CharacterKnowledge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeFindFirstArgs} args - Arguments to find a CharacterKnowledge
     * @example
     * // Get one CharacterKnowledge
     * const characterKnowledge = await prisma.characterKnowledge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterKnowledgeFindFirstArgs>(args?: SelectSubset<T, CharacterKnowledgeFindFirstArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CharacterKnowledge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeFindFirstOrThrowArgs} args - Arguments to find a CharacterKnowledge
     * @example
     * // Get one CharacterKnowledge
     * const characterKnowledge = await prisma.characterKnowledge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterKnowledgeFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterKnowledgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CharacterKnowledges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterKnowledges
     * const characterKnowledges = await prisma.characterKnowledge.findMany()
     * 
     * // Get first 10 CharacterKnowledges
     * const characterKnowledges = await prisma.characterKnowledge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterKnowledgeWithIdOnly = await prisma.characterKnowledge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterKnowledgeFindManyArgs>(args?: SelectSubset<T, CharacterKnowledgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CharacterKnowledge.
     * @param {CharacterKnowledgeCreateArgs} args - Arguments to create a CharacterKnowledge.
     * @example
     * // Create one CharacterKnowledge
     * const CharacterKnowledge = await prisma.characterKnowledge.create({
     *   data: {
     *     // ... data to create a CharacterKnowledge
     *   }
     * })
     * 
     */
    create<T extends CharacterKnowledgeCreateArgs>(args: SelectSubset<T, CharacterKnowledgeCreateArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CharacterKnowledges.
     * @param {CharacterKnowledgeCreateManyArgs} args - Arguments to create many CharacterKnowledges.
     * @example
     * // Create many CharacterKnowledges
     * const characterKnowledge = await prisma.characterKnowledge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterKnowledgeCreateManyArgs>(args?: SelectSubset<T, CharacterKnowledgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterKnowledges and returns the data saved in the database.
     * @param {CharacterKnowledgeCreateManyAndReturnArgs} args - Arguments to create many CharacterKnowledges.
     * @example
     * // Create many CharacterKnowledges
     * const characterKnowledge = await prisma.characterKnowledge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterKnowledges and only return the `id`
     * const characterKnowledgeWithIdOnly = await prisma.characterKnowledge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterKnowledgeCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterKnowledgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CharacterKnowledge.
     * @param {CharacterKnowledgeDeleteArgs} args - Arguments to delete one CharacterKnowledge.
     * @example
     * // Delete one CharacterKnowledge
     * const CharacterKnowledge = await prisma.characterKnowledge.delete({
     *   where: {
     *     // ... filter to delete one CharacterKnowledge
     *   }
     * })
     * 
     */
    delete<T extends CharacterKnowledgeDeleteArgs>(args: SelectSubset<T, CharacterKnowledgeDeleteArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CharacterKnowledge.
     * @param {CharacterKnowledgeUpdateArgs} args - Arguments to update one CharacterKnowledge.
     * @example
     * // Update one CharacterKnowledge
     * const characterKnowledge = await prisma.characterKnowledge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterKnowledgeUpdateArgs>(args: SelectSubset<T, CharacterKnowledgeUpdateArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CharacterKnowledges.
     * @param {CharacterKnowledgeDeleteManyArgs} args - Arguments to filter CharacterKnowledges to delete.
     * @example
     * // Delete a few CharacterKnowledges
     * const { count } = await prisma.characterKnowledge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterKnowledgeDeleteManyArgs>(args?: SelectSubset<T, CharacterKnowledgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterKnowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterKnowledges
     * const characterKnowledge = await prisma.characterKnowledge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterKnowledgeUpdateManyArgs>(args: SelectSubset<T, CharacterKnowledgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterKnowledge.
     * @param {CharacterKnowledgeUpsertArgs} args - Arguments to update or create a CharacterKnowledge.
     * @example
     * // Update or create a CharacterKnowledge
     * const characterKnowledge = await prisma.characterKnowledge.upsert({
     *   create: {
     *     // ... data to create a CharacterKnowledge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterKnowledge we want to update
     *   }
     * })
     */
    upsert<T extends CharacterKnowledgeUpsertArgs>(args: SelectSubset<T, CharacterKnowledgeUpsertArgs<ExtArgs>>): Prisma__CharacterKnowledgeClient<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CharacterKnowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeCountArgs} args - Arguments to filter CharacterKnowledges to count.
     * @example
     * // Count the number of CharacterKnowledges
     * const count = await prisma.characterKnowledge.count({
     *   where: {
     *     // ... the filter for the CharacterKnowledges we want to count
     *   }
     * })
    **/
    count<T extends CharacterKnowledgeCountArgs>(
      args?: Subset<T, CharacterKnowledgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterKnowledgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterKnowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterKnowledgeAggregateArgs>(args: Subset<T, CharacterKnowledgeAggregateArgs>): Prisma.PrismaPromise<GetCharacterKnowledgeAggregateType<T>>

    /**
     * Group by CharacterKnowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterKnowledgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterKnowledgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterKnowledgeGroupByArgs['orderBy'] }
        : { orderBy?: CharacterKnowledgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterKnowledgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterKnowledgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterKnowledge model
   */
  readonly fields: CharacterKnowledgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterKnowledge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterKnowledgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameCharacter<T extends GameCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacterDefaultArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterKnowledge model
   */ 
  interface CharacterKnowledgeFieldRefs {
    readonly id: FieldRef<"CharacterKnowledge", 'String'>
    readonly characterId: FieldRef<"CharacterKnowledge", 'String'>
    readonly skillType: FieldRef<"CharacterKnowledge", 'String'>
    readonly knowledgeType: FieldRef<"CharacterKnowledge", 'String'>
    readonly knowledgeName: FieldRef<"CharacterKnowledge", 'String'>
    readonly description: FieldRef<"CharacterKnowledge", 'String'>
    readonly proficiency: FieldRef<"CharacterKnowledge", 'Int'>
    readonly learnedAt: FieldRef<"CharacterKnowledge", 'DateTime'>
    readonly teacherNpcId: FieldRef<"CharacterKnowledge", 'String'>
    readonly createdAt: FieldRef<"CharacterKnowledge", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterKnowledge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CharacterKnowledge findUnique
   */
  export type CharacterKnowledgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterKnowledge to fetch.
     */
    where: CharacterKnowledgeWhereUniqueInput
  }

  /**
   * CharacterKnowledge findUniqueOrThrow
   */
  export type CharacterKnowledgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterKnowledge to fetch.
     */
    where: CharacterKnowledgeWhereUniqueInput
  }

  /**
   * CharacterKnowledge findFirst
   */
  export type CharacterKnowledgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterKnowledge to fetch.
     */
    where?: CharacterKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterKnowledges to fetch.
     */
    orderBy?: CharacterKnowledgeOrderByWithRelationInput | CharacterKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterKnowledges.
     */
    cursor?: CharacterKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterKnowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterKnowledges.
     */
    distinct?: CharacterKnowledgeScalarFieldEnum | CharacterKnowledgeScalarFieldEnum[]
  }

  /**
   * CharacterKnowledge findFirstOrThrow
   */
  export type CharacterKnowledgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterKnowledge to fetch.
     */
    where?: CharacterKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterKnowledges to fetch.
     */
    orderBy?: CharacterKnowledgeOrderByWithRelationInput | CharacterKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterKnowledges.
     */
    cursor?: CharacterKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterKnowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterKnowledges.
     */
    distinct?: CharacterKnowledgeScalarFieldEnum | CharacterKnowledgeScalarFieldEnum[]
  }

  /**
   * CharacterKnowledge findMany
   */
  export type CharacterKnowledgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterKnowledges to fetch.
     */
    where?: CharacterKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterKnowledges to fetch.
     */
    orderBy?: CharacterKnowledgeOrderByWithRelationInput | CharacterKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterKnowledges.
     */
    cursor?: CharacterKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterKnowledges.
     */
    skip?: number
    distinct?: CharacterKnowledgeScalarFieldEnum | CharacterKnowledgeScalarFieldEnum[]
  }

  /**
   * CharacterKnowledge create
   */
  export type CharacterKnowledgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterKnowledge.
     */
    data: XOR<CharacterKnowledgeCreateInput, CharacterKnowledgeUncheckedCreateInput>
  }

  /**
   * CharacterKnowledge createMany
   */
  export type CharacterKnowledgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterKnowledges.
     */
    data: CharacterKnowledgeCreateManyInput | CharacterKnowledgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterKnowledge createManyAndReturn
   */
  export type CharacterKnowledgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CharacterKnowledges.
     */
    data: CharacterKnowledgeCreateManyInput | CharacterKnowledgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterKnowledge update
   */
  export type CharacterKnowledgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterKnowledge.
     */
    data: XOR<CharacterKnowledgeUpdateInput, CharacterKnowledgeUncheckedUpdateInput>
    /**
     * Choose, which CharacterKnowledge to update.
     */
    where: CharacterKnowledgeWhereUniqueInput
  }

  /**
   * CharacterKnowledge updateMany
   */
  export type CharacterKnowledgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterKnowledges.
     */
    data: XOR<CharacterKnowledgeUpdateManyMutationInput, CharacterKnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which CharacterKnowledges to update
     */
    where?: CharacterKnowledgeWhereInput
  }

  /**
   * CharacterKnowledge upsert
   */
  export type CharacterKnowledgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterKnowledge to update in case it exists.
     */
    where: CharacterKnowledgeWhereUniqueInput
    /**
     * In case the CharacterKnowledge found by the `where` argument doesn't exist, create a new CharacterKnowledge with this data.
     */
    create: XOR<CharacterKnowledgeCreateInput, CharacterKnowledgeUncheckedCreateInput>
    /**
     * In case the CharacterKnowledge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterKnowledgeUpdateInput, CharacterKnowledgeUncheckedUpdateInput>
  }

  /**
   * CharacterKnowledge delete
   */
  export type CharacterKnowledgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    /**
     * Filter which CharacterKnowledge to delete.
     */
    where: CharacterKnowledgeWhereUniqueInput
  }

  /**
   * CharacterKnowledge deleteMany
   */
  export type CharacterKnowledgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterKnowledges to delete
     */
    where?: CharacterKnowledgeWhereInput
  }

  /**
   * CharacterKnowledge without action
   */
  export type CharacterKnowledgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
  }


  /**
   * Model CharacterSkill
   */

  export type AggregateCharacterSkill = {
    _count: CharacterSkillCountAggregateOutputType | null
    _avg: CharacterSkillAvgAggregateOutputType | null
    _sum: CharacterSkillSumAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  export type CharacterSkillAvgAggregateOutputType = {
    experience: number | null
  }

  export type CharacterSkillSumAggregateOutputType = {
    experience: number | null
  }

  export type CharacterSkillMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    skillType: string | null
    experience: number | null
    level: string | null
    unlockedAt: Date | null
    lastPracticed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterSkillMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    skillType: string | null
    experience: number | null
    level: string | null
    unlockedAt: Date | null
    lastPracticed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterSkillCountAggregateOutputType = {
    id: number
    characterId: number
    skillType: number
    experience: number
    level: number
    unlockedAt: number
    lastPracticed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterSkillAvgAggregateInputType = {
    experience?: true
  }

  export type CharacterSkillSumAggregateInputType = {
    experience?: true
  }

  export type CharacterSkillMinAggregateInputType = {
    id?: true
    characterId?: true
    skillType?: true
    experience?: true
    level?: true
    unlockedAt?: true
    lastPracticed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterSkillMaxAggregateInputType = {
    id?: true
    characterId?: true
    skillType?: true
    experience?: true
    level?: true
    unlockedAt?: true
    lastPracticed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterSkillCountAggregateInputType = {
    id?: true
    characterId?: true
    skillType?: true
    experience?: true
    level?: true
    unlockedAt?: true
    lastPracticed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkill to aggregate.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterSkills
    **/
    _count?: true | CharacterSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type GetCharacterSkillAggregateType<T extends CharacterSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSkill[P]>
      : GetScalarType<T[P], AggregateCharacterSkill[P]>
  }




  export type CharacterSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithAggregationInput | CharacterSkillOrderByWithAggregationInput[]
    by: CharacterSkillScalarFieldEnum[] | CharacterSkillScalarFieldEnum
    having?: CharacterSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterSkillCountAggregateInputType | true
    _avg?: CharacterSkillAvgAggregateInputType
    _sum?: CharacterSkillSumAggregateInputType
    _min?: CharacterSkillMinAggregateInputType
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type CharacterSkillGroupByOutputType = {
    id: string
    characterId: string
    skillType: string
    experience: number
    level: string
    unlockedAt: Date
    lastPracticed: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CharacterSkillCountAggregateOutputType | null
    _avg: CharacterSkillAvgAggregateOutputType | null
    _sum: CharacterSkillSumAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  type GetCharacterSkillGroupByPayload<T extends CharacterSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    skillType?: boolean
    experience?: boolean
    level?: boolean
    unlockedAt?: boolean
    lastPracticed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
    skillPracticeHistory?: boolean | CharacterSkill$skillPracticeHistoryArgs<ExtArgs>
    _count?: boolean | CharacterSkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    skillType?: boolean
    experience?: boolean
    level?: boolean
    unlockedAt?: boolean
    lastPracticed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectScalar = {
    id?: boolean
    characterId?: boolean
    skillType?: boolean
    experience?: boolean
    level?: boolean
    unlockedAt?: boolean
    lastPracticed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
    skillPracticeHistory?: boolean | CharacterSkill$skillPracticeHistoryArgs<ExtArgs>
    _count?: boolean | CharacterSkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSkill"
    objects: {
      gameCharacter: Prisma.$GameCharacterPayload<ExtArgs>
      skillPracticeHistory: Prisma.$SkillPracticeHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      skillType: string
      experience: number
      level: string
      unlockedAt: Date
      lastPracticed: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["characterSkill"]>
    composites: {}
  }

  type CharacterSkillGetPayload<S extends boolean | null | undefined | CharacterSkillDefaultArgs> = $Result.GetResult<Prisma.$CharacterSkillPayload, S>

  type CharacterSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterSkillCountAggregateInputType | true
    }

  export interface CharacterSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSkill'], meta: { name: 'CharacterSkill' } }
    /**
     * Find zero or one CharacterSkill that matches the filter.
     * @param {CharacterSkillFindUniqueArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterSkillFindUniqueArgs>(args: SelectSubset<T, CharacterSkillFindUniqueArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CharacterSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterSkillFindUniqueOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CharacterSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterSkillFindFirstArgs>(args?: SelectSubset<T, CharacterSkillFindFirstArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CharacterSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CharacterSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany()
     * 
     * // Get first 10 CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterSkillFindManyArgs>(args?: SelectSubset<T, CharacterSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CharacterSkill.
     * @param {CharacterSkillCreateArgs} args - Arguments to create a CharacterSkill.
     * @example
     * // Create one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.create({
     *   data: {
     *     // ... data to create a CharacterSkill
     *   }
     * })
     * 
     */
    create<T extends CharacterSkillCreateArgs>(args: SelectSubset<T, CharacterSkillCreateArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CharacterSkills.
     * @param {CharacterSkillCreateManyArgs} args - Arguments to create many CharacterSkills.
     * @example
     * // Create many CharacterSkills
     * const characterSkill = await prisma.characterSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterSkillCreateManyArgs>(args?: SelectSubset<T, CharacterSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterSkills and returns the data saved in the database.
     * @param {CharacterSkillCreateManyAndReturnArgs} args - Arguments to create many CharacterSkills.
     * @example
     * // Create many CharacterSkills
     * const characterSkill = await prisma.characterSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterSkills and only return the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CharacterSkill.
     * @param {CharacterSkillDeleteArgs} args - Arguments to delete one CharacterSkill.
     * @example
     * // Delete one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.delete({
     *   where: {
     *     // ... filter to delete one CharacterSkill
     *   }
     * })
     * 
     */
    delete<T extends CharacterSkillDeleteArgs>(args: SelectSubset<T, CharacterSkillDeleteArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CharacterSkill.
     * @param {CharacterSkillUpdateArgs} args - Arguments to update one CharacterSkill.
     * @example
     * // Update one CharacterSkill
     * const characterSkill = await prisma.characterSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterSkillUpdateArgs>(args: SelectSubset<T, CharacterSkillUpdateArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CharacterSkills.
     * @param {CharacterSkillDeleteManyArgs} args - Arguments to filter CharacterSkills to delete.
     * @example
     * // Delete a few CharacterSkills
     * const { count } = await prisma.characterSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterSkillDeleteManyArgs>(args?: SelectSubset<T, CharacterSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterSkills
     * const characterSkill = await prisma.characterSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterSkillUpdateManyArgs>(args: SelectSubset<T, CharacterSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterSkill.
     * @param {CharacterSkillUpsertArgs} args - Arguments to update or create a CharacterSkill.
     * @example
     * // Update or create a CharacterSkill
     * const characterSkill = await prisma.characterSkill.upsert({
     *   create: {
     *     // ... data to create a CharacterSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSkill we want to update
     *   }
     * })
     */
    upsert<T extends CharacterSkillUpsertArgs>(args: SelectSubset<T, CharacterSkillUpsertArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillCountArgs} args - Arguments to filter CharacterSkills to count.
     * @example
     * // Count the number of CharacterSkills
     * const count = await prisma.characterSkill.count({
     *   where: {
     *     // ... the filter for the CharacterSkills we want to count
     *   }
     * })
    **/
    count<T extends CharacterSkillCountArgs>(
      args?: Subset<T, CharacterSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterSkillAggregateArgs>(args: Subset<T, CharacterSkillAggregateArgs>): Prisma.PrismaPromise<GetCharacterSkillAggregateType<T>>

    /**
     * Group by CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterSkillGroupByArgs['orderBy'] }
        : { orderBy?: CharacterSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSkill model
   */
  readonly fields: CharacterSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameCharacter<T extends GameCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacterDefaultArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skillPracticeHistory<T extends CharacterSkill$skillPracticeHistoryArgs<ExtArgs> = {}>(args?: Subset<T, CharacterSkill$skillPracticeHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterSkill model
   */ 
  interface CharacterSkillFieldRefs {
    readonly id: FieldRef<"CharacterSkill", 'String'>
    readonly characterId: FieldRef<"CharacterSkill", 'String'>
    readonly skillType: FieldRef<"CharacterSkill", 'String'>
    readonly experience: FieldRef<"CharacterSkill", 'Int'>
    readonly level: FieldRef<"CharacterSkill", 'String'>
    readonly unlockedAt: FieldRef<"CharacterSkill", 'DateTime'>
    readonly lastPracticed: FieldRef<"CharacterSkill", 'DateTime'>
    readonly createdAt: FieldRef<"CharacterSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"CharacterSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CharacterSkill findUnique
   */
  export type CharacterSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill findUniqueOrThrow
   */
  export type CharacterSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill findFirst
   */
  export type CharacterSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill findFirstOrThrow
   */
  export type CharacterSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill findMany
   */
  export type CharacterSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkills to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill create
   */
  export type CharacterSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSkill.
     */
    data: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
  }

  /**
   * CharacterSkill createMany
   */
  export type CharacterSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterSkill createManyAndReturn
   */
  export type CharacterSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterSkill update
   */
  export type CharacterSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSkill.
     */
    data: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
    /**
     * Choose, which CharacterSkill to update.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill updateMany
   */
  export type CharacterSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterSkills.
     */
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSkills to update
     */
    where?: CharacterSkillWhereInput
  }

  /**
   * CharacterSkill upsert
   */
  export type CharacterSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSkill to update in case it exists.
     */
    where: CharacterSkillWhereUniqueInput
    /**
     * In case the CharacterSkill found by the `where` argument doesn't exist, create a new CharacterSkill with this data.
     */
    create: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
    /**
     * In case the CharacterSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
  }

  /**
   * CharacterSkill delete
   */
  export type CharacterSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter which CharacterSkill to delete.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill deleteMany
   */
  export type CharacterSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkills to delete
     */
    where?: CharacterSkillWhereInput
  }

  /**
   * CharacterSkill.skillPracticeHistory
   */
  export type CharacterSkill$skillPracticeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    where?: SkillPracticeHistoryWhereInput
    orderBy?: SkillPracticeHistoryOrderByWithRelationInput | SkillPracticeHistoryOrderByWithRelationInput[]
    cursor?: SkillPracticeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillPracticeHistoryScalarFieldEnum | SkillPracticeHistoryScalarFieldEnum[]
  }

  /**
   * CharacterSkill without action
   */
  export type CharacterSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryQuest
   */

  export type AggregateDeliveryQuest = {
    _count: DeliveryQuestCountAggregateOutputType | null
    _avg: DeliveryQuestAvgAggregateOutputType | null
    _sum: DeliveryQuestSumAggregateOutputType | null
    _min: DeliveryQuestMinAggregateOutputType | null
    _max: DeliveryQuestMaxAggregateOutputType | null
  }

  export type DeliveryQuestAvgAggregateOutputType = {
    quantity: number | null
    totalWeight: number | null
    requiredCapacity: number | null
    timeLimit: number | null
    distance: number | null
    goldReward: number | null
    experienceReward: number | null
    reputationReward: number | null
  }

  export type DeliveryQuestSumAggregateOutputType = {
    quantity: number | null
    totalWeight: number | null
    requiredCapacity: number | null
    timeLimit: number | null
    distance: number | null
    goldReward: number | null
    experienceReward: number | null
    reputationReward: number | null
  }

  export type DeliveryQuestMinAggregateOutputType = {
    id: string | null
    questId: string | null
    deliveryType: string | null
    fromNpcId: string | null
    toNpcId: string | null
    fromLocation: string | null
    toLocation: string | null
    itemId: string | null
    itemQuality: string | null
    quantity: number | null
    totalWeight: number | null
    requiredCapacity: number | null
    timeLimit: number | null
    distance: number | null
    difficulty: string | null
    goldReward: number | null
    experienceReward: number | null
    reputationReward: number | null
    status: string | null
    assignedTo: string | null
    startedAt: Date | null
    completedAt: Date | null
    pickupConfirmed: boolean | null
    deliveryConfirmed: boolean | null
    currentLocation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryQuestMaxAggregateOutputType = {
    id: string | null
    questId: string | null
    deliveryType: string | null
    fromNpcId: string | null
    toNpcId: string | null
    fromLocation: string | null
    toLocation: string | null
    itemId: string | null
    itemQuality: string | null
    quantity: number | null
    totalWeight: number | null
    requiredCapacity: number | null
    timeLimit: number | null
    distance: number | null
    difficulty: string | null
    goldReward: number | null
    experienceReward: number | null
    reputationReward: number | null
    status: string | null
    assignedTo: string | null
    startedAt: Date | null
    completedAt: Date | null
    pickupConfirmed: boolean | null
    deliveryConfirmed: boolean | null
    currentLocation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryQuestCountAggregateOutputType = {
    id: number
    questId: number
    deliveryType: number
    fromNpcId: number
    toNpcId: number
    fromLocation: number
    toLocation: number
    itemId: number
    itemQuality: number
    quantity: number
    totalWeight: number
    requiredCapacity: number
    timeLimit: number
    distance: number
    difficulty: number
    goldReward: number
    experienceReward: number
    reputationReward: number
    status: number
    assignedTo: number
    startedAt: number
    completedAt: number
    pickupConfirmed: number
    deliveryConfirmed: number
    currentLocation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryQuestAvgAggregateInputType = {
    quantity?: true
    totalWeight?: true
    requiredCapacity?: true
    timeLimit?: true
    distance?: true
    goldReward?: true
    experienceReward?: true
    reputationReward?: true
  }

  export type DeliveryQuestSumAggregateInputType = {
    quantity?: true
    totalWeight?: true
    requiredCapacity?: true
    timeLimit?: true
    distance?: true
    goldReward?: true
    experienceReward?: true
    reputationReward?: true
  }

  export type DeliveryQuestMinAggregateInputType = {
    id?: true
    questId?: true
    deliveryType?: true
    fromNpcId?: true
    toNpcId?: true
    fromLocation?: true
    toLocation?: true
    itemId?: true
    itemQuality?: true
    quantity?: true
    totalWeight?: true
    requiredCapacity?: true
    timeLimit?: true
    distance?: true
    difficulty?: true
    goldReward?: true
    experienceReward?: true
    reputationReward?: true
    status?: true
    assignedTo?: true
    startedAt?: true
    completedAt?: true
    pickupConfirmed?: true
    deliveryConfirmed?: true
    currentLocation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryQuestMaxAggregateInputType = {
    id?: true
    questId?: true
    deliveryType?: true
    fromNpcId?: true
    toNpcId?: true
    fromLocation?: true
    toLocation?: true
    itemId?: true
    itemQuality?: true
    quantity?: true
    totalWeight?: true
    requiredCapacity?: true
    timeLimit?: true
    distance?: true
    difficulty?: true
    goldReward?: true
    experienceReward?: true
    reputationReward?: true
    status?: true
    assignedTo?: true
    startedAt?: true
    completedAt?: true
    pickupConfirmed?: true
    deliveryConfirmed?: true
    currentLocation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryQuestCountAggregateInputType = {
    id?: true
    questId?: true
    deliveryType?: true
    fromNpcId?: true
    toNpcId?: true
    fromLocation?: true
    toLocation?: true
    itemId?: true
    itemQuality?: true
    quantity?: true
    totalWeight?: true
    requiredCapacity?: true
    timeLimit?: true
    distance?: true
    difficulty?: true
    goldReward?: true
    experienceReward?: true
    reputationReward?: true
    status?: true
    assignedTo?: true
    startedAt?: true
    completedAt?: true
    pickupConfirmed?: true
    deliveryConfirmed?: true
    currentLocation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryQuest to aggregate.
     */
    where?: DeliveryQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuests to fetch.
     */
    orderBy?: DeliveryQuestOrderByWithRelationInput | DeliveryQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryQuests
    **/
    _count?: true | DeliveryQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryQuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryQuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryQuestMaxAggregateInputType
  }

  export type GetDeliveryQuestAggregateType<T extends DeliveryQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryQuest[P]>
      : GetScalarType<T[P], AggregateDeliveryQuest[P]>
  }




  export type DeliveryQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryQuestWhereInput
    orderBy?: DeliveryQuestOrderByWithAggregationInput | DeliveryQuestOrderByWithAggregationInput[]
    by: DeliveryQuestScalarFieldEnum[] | DeliveryQuestScalarFieldEnum
    having?: DeliveryQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryQuestCountAggregateInputType | true
    _avg?: DeliveryQuestAvgAggregateInputType
    _sum?: DeliveryQuestSumAggregateInputType
    _min?: DeliveryQuestMinAggregateInputType
    _max?: DeliveryQuestMaxAggregateInputType
  }

  export type DeliveryQuestGroupByOutputType = {
    id: string
    questId: string
    deliveryType: string
    fromNpcId: string
    toNpcId: string
    fromLocation: string
    toLocation: string
    itemId: string
    itemQuality: string
    quantity: number
    totalWeight: number
    requiredCapacity: number
    timeLimit: number | null
    distance: number
    difficulty: string
    goldReward: number
    experienceReward: number
    reputationReward: number
    status: string
    assignedTo: string | null
    startedAt: Date | null
    completedAt: Date | null
    pickupConfirmed: boolean
    deliveryConfirmed: boolean
    currentLocation: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeliveryQuestCountAggregateOutputType | null
    _avg: DeliveryQuestAvgAggregateOutputType | null
    _sum: DeliveryQuestSumAggregateOutputType | null
    _min: DeliveryQuestMinAggregateOutputType | null
    _max: DeliveryQuestMaxAggregateOutputType | null
  }

  type GetDeliveryQuestGroupByPayload<T extends DeliveryQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryQuestGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryQuestGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questId?: boolean
    deliveryType?: boolean
    fromNpcId?: boolean
    toNpcId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    itemId?: boolean
    itemQuality?: boolean
    quantity?: boolean
    totalWeight?: boolean
    requiredCapacity?: boolean
    timeLimit?: boolean
    distance?: boolean
    difficulty?: boolean
    goldReward?: boolean
    experienceReward?: boolean
    reputationReward?: boolean
    status?: boolean
    assignedTo?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pickupConfirmed?: boolean
    deliveryConfirmed?: boolean
    currentLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliveryQuest"]>

  export type DeliveryQuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questId?: boolean
    deliveryType?: boolean
    fromNpcId?: boolean
    toNpcId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    itemId?: boolean
    itemQuality?: boolean
    quantity?: boolean
    totalWeight?: boolean
    requiredCapacity?: boolean
    timeLimit?: boolean
    distance?: boolean
    difficulty?: boolean
    goldReward?: boolean
    experienceReward?: boolean
    reputationReward?: boolean
    status?: boolean
    assignedTo?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pickupConfirmed?: boolean
    deliveryConfirmed?: boolean
    currentLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deliveryQuest"]>

  export type DeliveryQuestSelectScalar = {
    id?: boolean
    questId?: boolean
    deliveryType?: boolean
    fromNpcId?: boolean
    toNpcId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    itemId?: boolean
    itemQuality?: boolean
    quantity?: boolean
    totalWeight?: boolean
    requiredCapacity?: boolean
    timeLimit?: boolean
    distance?: boolean
    difficulty?: boolean
    goldReward?: boolean
    experienceReward?: boolean
    reputationReward?: boolean
    status?: boolean
    assignedTo?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pickupConfirmed?: boolean
    deliveryConfirmed?: boolean
    currentLocation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DeliveryQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryQuest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questId: string
      deliveryType: string
      fromNpcId: string
      toNpcId: string
      fromLocation: string
      toLocation: string
      itemId: string
      itemQuality: string
      quantity: number
      totalWeight: number
      requiredCapacity: number
      timeLimit: number | null
      distance: number
      difficulty: string
      goldReward: number
      experienceReward: number
      reputationReward: number
      status: string
      assignedTo: string | null
      startedAt: Date | null
      completedAt: Date | null
      pickupConfirmed: boolean
      deliveryConfirmed: boolean
      currentLocation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliveryQuest"]>
    composites: {}
  }

  type DeliveryQuestGetPayload<S extends boolean | null | undefined | DeliveryQuestDefaultArgs> = $Result.GetResult<Prisma.$DeliveryQuestPayload, S>

  type DeliveryQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryQuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryQuestCountAggregateInputType | true
    }

  export interface DeliveryQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryQuest'], meta: { name: 'DeliveryQuest' } }
    /**
     * Find zero or one DeliveryQuest that matches the filter.
     * @param {DeliveryQuestFindUniqueArgs} args - Arguments to find a DeliveryQuest
     * @example
     * // Get one DeliveryQuest
     * const deliveryQuest = await prisma.deliveryQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryQuestFindUniqueArgs>(args: SelectSubset<T, DeliveryQuestFindUniqueArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryQuest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryQuestFindUniqueOrThrowArgs} args - Arguments to find a DeliveryQuest
     * @example
     * // Get one DeliveryQuest
     * const deliveryQuest = await prisma.deliveryQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryQuestFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryQuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestFindFirstArgs} args - Arguments to find a DeliveryQuest
     * @example
     * // Get one DeliveryQuest
     * const deliveryQuest = await prisma.deliveryQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryQuestFindFirstArgs>(args?: SelectSubset<T, DeliveryQuestFindFirstArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestFindFirstOrThrowArgs} args - Arguments to find a DeliveryQuest
     * @example
     * // Get one DeliveryQuest
     * const deliveryQuest = await prisma.deliveryQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryQuestFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryQuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryQuests
     * const deliveryQuests = await prisma.deliveryQuest.findMany()
     * 
     * // Get first 10 DeliveryQuests
     * const deliveryQuests = await prisma.deliveryQuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryQuestWithIdOnly = await prisma.deliveryQuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryQuestFindManyArgs>(args?: SelectSubset<T, DeliveryQuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryQuest.
     * @param {DeliveryQuestCreateArgs} args - Arguments to create a DeliveryQuest.
     * @example
     * // Create one DeliveryQuest
     * const DeliveryQuest = await prisma.deliveryQuest.create({
     *   data: {
     *     // ... data to create a DeliveryQuest
     *   }
     * })
     * 
     */
    create<T extends DeliveryQuestCreateArgs>(args: SelectSubset<T, DeliveryQuestCreateArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryQuests.
     * @param {DeliveryQuestCreateManyArgs} args - Arguments to create many DeliveryQuests.
     * @example
     * // Create many DeliveryQuests
     * const deliveryQuest = await prisma.deliveryQuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryQuestCreateManyArgs>(args?: SelectSubset<T, DeliveryQuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryQuests and returns the data saved in the database.
     * @param {DeliveryQuestCreateManyAndReturnArgs} args - Arguments to create many DeliveryQuests.
     * @example
     * // Create many DeliveryQuests
     * const deliveryQuest = await prisma.deliveryQuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryQuests and only return the `id`
     * const deliveryQuestWithIdOnly = await prisma.deliveryQuest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryQuestCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryQuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryQuest.
     * @param {DeliveryQuestDeleteArgs} args - Arguments to delete one DeliveryQuest.
     * @example
     * // Delete one DeliveryQuest
     * const DeliveryQuest = await prisma.deliveryQuest.delete({
     *   where: {
     *     // ... filter to delete one DeliveryQuest
     *   }
     * })
     * 
     */
    delete<T extends DeliveryQuestDeleteArgs>(args: SelectSubset<T, DeliveryQuestDeleteArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryQuest.
     * @param {DeliveryQuestUpdateArgs} args - Arguments to update one DeliveryQuest.
     * @example
     * // Update one DeliveryQuest
     * const deliveryQuest = await prisma.deliveryQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryQuestUpdateArgs>(args: SelectSubset<T, DeliveryQuestUpdateArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryQuests.
     * @param {DeliveryQuestDeleteManyArgs} args - Arguments to filter DeliveryQuests to delete.
     * @example
     * // Delete a few DeliveryQuests
     * const { count } = await prisma.deliveryQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryQuestDeleteManyArgs>(args?: SelectSubset<T, DeliveryQuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryQuests
     * const deliveryQuest = await prisma.deliveryQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryQuestUpdateManyArgs>(args: SelectSubset<T, DeliveryQuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryQuest.
     * @param {DeliveryQuestUpsertArgs} args - Arguments to update or create a DeliveryQuest.
     * @example
     * // Update or create a DeliveryQuest
     * const deliveryQuest = await prisma.deliveryQuest.upsert({
     *   create: {
     *     // ... data to create a DeliveryQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryQuest we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryQuestUpsertArgs>(args: SelectSubset<T, DeliveryQuestUpsertArgs<ExtArgs>>): Prisma__DeliveryQuestClient<$Result.GetResult<Prisma.$DeliveryQuestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestCountArgs} args - Arguments to filter DeliveryQuests to count.
     * @example
     * // Count the number of DeliveryQuests
     * const count = await prisma.deliveryQuest.count({
     *   where: {
     *     // ... the filter for the DeliveryQuests we want to count
     *   }
     * })
    **/
    count<T extends DeliveryQuestCountArgs>(
      args?: Subset<T, DeliveryQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryQuestAggregateArgs>(args: Subset<T, DeliveryQuestAggregateArgs>): Prisma.PrismaPromise<GetDeliveryQuestAggregateType<T>>

    /**
     * Group by DeliveryQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryQuestGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryQuest model
   */
  readonly fields: DeliveryQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryQuest model
   */ 
  interface DeliveryQuestFieldRefs {
    readonly id: FieldRef<"DeliveryQuest", 'String'>
    readonly questId: FieldRef<"DeliveryQuest", 'String'>
    readonly deliveryType: FieldRef<"DeliveryQuest", 'String'>
    readonly fromNpcId: FieldRef<"DeliveryQuest", 'String'>
    readonly toNpcId: FieldRef<"DeliveryQuest", 'String'>
    readonly fromLocation: FieldRef<"DeliveryQuest", 'String'>
    readonly toLocation: FieldRef<"DeliveryQuest", 'String'>
    readonly itemId: FieldRef<"DeliveryQuest", 'String'>
    readonly itemQuality: FieldRef<"DeliveryQuest", 'String'>
    readonly quantity: FieldRef<"DeliveryQuest", 'Int'>
    readonly totalWeight: FieldRef<"DeliveryQuest", 'Float'>
    readonly requiredCapacity: FieldRef<"DeliveryQuest", 'Float'>
    readonly timeLimit: FieldRef<"DeliveryQuest", 'Int'>
    readonly distance: FieldRef<"DeliveryQuest", 'Float'>
    readonly difficulty: FieldRef<"DeliveryQuest", 'String'>
    readonly goldReward: FieldRef<"DeliveryQuest", 'Int'>
    readonly experienceReward: FieldRef<"DeliveryQuest", 'Int'>
    readonly reputationReward: FieldRef<"DeliveryQuest", 'Int'>
    readonly status: FieldRef<"DeliveryQuest", 'String'>
    readonly assignedTo: FieldRef<"DeliveryQuest", 'String'>
    readonly startedAt: FieldRef<"DeliveryQuest", 'DateTime'>
    readonly completedAt: FieldRef<"DeliveryQuest", 'DateTime'>
    readonly pickupConfirmed: FieldRef<"DeliveryQuest", 'Boolean'>
    readonly deliveryConfirmed: FieldRef<"DeliveryQuest", 'Boolean'>
    readonly currentLocation: FieldRef<"DeliveryQuest", 'String'>
    readonly createdAt: FieldRef<"DeliveryQuest", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryQuest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryQuest findUnique
   */
  export type DeliveryQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryQuest to fetch.
     */
    where: DeliveryQuestWhereUniqueInput
  }

  /**
   * DeliveryQuest findUniqueOrThrow
   */
  export type DeliveryQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryQuest to fetch.
     */
    where: DeliveryQuestWhereUniqueInput
  }

  /**
   * DeliveryQuest findFirst
   */
  export type DeliveryQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryQuest to fetch.
     */
    where?: DeliveryQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuests to fetch.
     */
    orderBy?: DeliveryQuestOrderByWithRelationInput | DeliveryQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryQuests.
     */
    cursor?: DeliveryQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryQuests.
     */
    distinct?: DeliveryQuestScalarFieldEnum | DeliveryQuestScalarFieldEnum[]
  }

  /**
   * DeliveryQuest findFirstOrThrow
   */
  export type DeliveryQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryQuest to fetch.
     */
    where?: DeliveryQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuests to fetch.
     */
    orderBy?: DeliveryQuestOrderByWithRelationInput | DeliveryQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryQuests.
     */
    cursor?: DeliveryQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryQuests.
     */
    distinct?: DeliveryQuestScalarFieldEnum | DeliveryQuestScalarFieldEnum[]
  }

  /**
   * DeliveryQuest findMany
   */
  export type DeliveryQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryQuests to fetch.
     */
    where?: DeliveryQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryQuests to fetch.
     */
    orderBy?: DeliveryQuestOrderByWithRelationInput | DeliveryQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryQuests.
     */
    cursor?: DeliveryQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryQuests.
     */
    skip?: number
    distinct?: DeliveryQuestScalarFieldEnum | DeliveryQuestScalarFieldEnum[]
  }

  /**
   * DeliveryQuest create
   */
  export type DeliveryQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * The data needed to create a DeliveryQuest.
     */
    data: XOR<DeliveryQuestCreateInput, DeliveryQuestUncheckedCreateInput>
  }

  /**
   * DeliveryQuest createMany
   */
  export type DeliveryQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryQuests.
     */
    data: DeliveryQuestCreateManyInput | DeliveryQuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryQuest createManyAndReturn
   */
  export type DeliveryQuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryQuests.
     */
    data: DeliveryQuestCreateManyInput | DeliveryQuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryQuest update
   */
  export type DeliveryQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * The data needed to update a DeliveryQuest.
     */
    data: XOR<DeliveryQuestUpdateInput, DeliveryQuestUncheckedUpdateInput>
    /**
     * Choose, which DeliveryQuest to update.
     */
    where: DeliveryQuestWhereUniqueInput
  }

  /**
   * DeliveryQuest updateMany
   */
  export type DeliveryQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryQuests.
     */
    data: XOR<DeliveryQuestUpdateManyMutationInput, DeliveryQuestUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryQuests to update
     */
    where?: DeliveryQuestWhereInput
  }

  /**
   * DeliveryQuest upsert
   */
  export type DeliveryQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * The filter to search for the DeliveryQuest to update in case it exists.
     */
    where: DeliveryQuestWhereUniqueInput
    /**
     * In case the DeliveryQuest found by the `where` argument doesn't exist, create a new DeliveryQuest with this data.
     */
    create: XOR<DeliveryQuestCreateInput, DeliveryQuestUncheckedCreateInput>
    /**
     * In case the DeliveryQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryQuestUpdateInput, DeliveryQuestUncheckedUpdateInput>
  }

  /**
   * DeliveryQuest delete
   */
  export type DeliveryQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
    /**
     * Filter which DeliveryQuest to delete.
     */
    where: DeliveryQuestWhereUniqueInput
  }

  /**
   * DeliveryQuest deleteMany
   */
  export type DeliveryQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryQuests to delete
     */
    where?: DeliveryQuestWhereInput
  }

  /**
   * DeliveryQuest without action
   */
  export type DeliveryQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryQuest
     */
    select?: DeliveryQuestSelect<ExtArgs> | null
  }


  /**
   * Model GameCharacter
   */

  export type AggregateGameCharacter = {
    _count: GameCharacterCountAggregateOutputType | null
    _avg: GameCharacterAvgAggregateOutputType | null
    _sum: GameCharacterSumAggregateOutputType | null
    _min: GameCharacterMinAggregateOutputType | null
    _max: GameCharacterMaxAggregateOutputType | null
  }

  export type GameCharacterAvgAggregateOutputType = {
    level: number | null
    experience: number | null
    health: number | null
    maxHealth: number | null
    mana: number | null
    maxMana: number | null
    strength: number | null
    dexterity: number | null
    intelligence: number | null
    vitality: number | null
    luck: number | null
    availableStatPoints: number | null
    baseCarryingCapacity: number | null
    carryingCapacity: number | null
    currentVolume: number | null
    currentWeight: number | null
    goldAmount: number | null
    magicalStorageCapacity: number | null
    magicalStorageUsed: number | null
    maxStamina: number | null
    maxVolume: number | null
    movementPenalty: number | null
    positionX: number | null
    positionY: number | null
    stamina: number | null
    staminaRegenRate: number | null
    baseStamina: number | null
    luckPercentage: number | null
  }

  export type GameCharacterSumAggregateOutputType = {
    level: number | null
    experience: number | null
    health: number | null
    maxHealth: number | null
    mana: number | null
    maxMana: number | null
    strength: number | null
    dexterity: number | null
    intelligence: number | null
    vitality: number | null
    luck: number | null
    availableStatPoints: number | null
    baseCarryingCapacity: number | null
    carryingCapacity: number | null
    currentVolume: number | null
    currentWeight: number | null
    goldAmount: number | null
    magicalStorageCapacity: number | null
    magicalStorageUsed: number | null
    maxStamina: number | null
    maxVolume: number | null
    movementPenalty: number | null
    positionX: number | null
    positionY: number | null
    stamina: number | null
    staminaRegenRate: number | null
    baseStamina: number | null
    luckPercentage: number | null
  }

  export type GameCharacterMinAggregateOutputType = {
    id: string | null
    characterName: string | null
    level: number | null
    experience: number | null
    health: number | null
    maxHealth: number | null
    mana: number | null
    maxMana: number | null
    strength: number | null
    dexterity: number | null
    intelligence: number | null
    vitality: number | null
    luck: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    availableStatPoints: number | null
    baseCarryingCapacity: number | null
    carryingCapacity: number | null
    characterClass: string | null
    currentMapLocation: string | null
    currentVolume: number | null
    currentWeight: number | null
    equippedArmor: string | null
    equippedBackpack: string | null
    equippedWeapon: string | null
    goldAmount: number | null
    isResting: boolean | null
    lastSaveTimestamp: Date | null
    lastStaminaUpdate: Date | null
    magicalStorageCapacity: number | null
    magicalStorageUsed: number | null
    maxStamina: number | null
    maxVolume: number | null
    movementPenalty: number | null
    positionX: number | null
    positionY: number | null
    restStartTime: Date | null
    stamina: number | null
    staminaRegenRate: number | null
    baseStamina: number | null
    equippedGloves: string | null
    equippedPants: string | null
    equippedShield: string | null
    equippedShirt: string | null
    equippedShoes: string | null
    luckPercentage: number | null
  }

  export type GameCharacterMaxAggregateOutputType = {
    id: string | null
    characterName: string | null
    level: number | null
    experience: number | null
    health: number | null
    maxHealth: number | null
    mana: number | null
    maxMana: number | null
    strength: number | null
    dexterity: number | null
    intelligence: number | null
    vitality: number | null
    luck: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    availableStatPoints: number | null
    baseCarryingCapacity: number | null
    carryingCapacity: number | null
    characterClass: string | null
    currentMapLocation: string | null
    currentVolume: number | null
    currentWeight: number | null
    equippedArmor: string | null
    equippedBackpack: string | null
    equippedWeapon: string | null
    goldAmount: number | null
    isResting: boolean | null
    lastSaveTimestamp: Date | null
    lastStaminaUpdate: Date | null
    magicalStorageCapacity: number | null
    magicalStorageUsed: number | null
    maxStamina: number | null
    maxVolume: number | null
    movementPenalty: number | null
    positionX: number | null
    positionY: number | null
    restStartTime: Date | null
    stamina: number | null
    staminaRegenRate: number | null
    baseStamina: number | null
    equippedGloves: string | null
    equippedPants: string | null
    equippedShield: string | null
    equippedShirt: string | null
    equippedShoes: string | null
    luckPercentage: number | null
  }

  export type GameCharacterCountAggregateOutputType = {
    id: number
    characterName: number
    level: number
    experience: number
    health: number
    maxHealth: number
    mana: number
    maxMana: number
    strength: number
    dexterity: number
    intelligence: number
    vitality: number
    luck: number
    createdAt: number
    updatedAt: number
    userId: number
    availableStatPoints: number
    baseCarryingCapacity: number
    carryingCapacity: number
    characterClass: number
    currentMapLocation: number
    currentVolume: number
    currentWeight: number
    equippedArmor: number
    equippedBackpack: number
    equippedWeapon: number
    goldAmount: number
    isResting: number
    lastSaveTimestamp: number
    lastStaminaUpdate: number
    magicalStorageCapacity: number
    magicalStorageUsed: number
    maxStamina: number
    maxVolume: number
    movementPenalty: number
    positionX: number
    positionY: number
    restStartTime: number
    stamina: number
    staminaRegenRate: number
    baseStamina: number
    equippedGloves: number
    equippedPants: number
    equippedShield: number
    equippedShirt: number
    equippedShoes: number
    luckPercentage: number
    _all: number
  }


  export type GameCharacterAvgAggregateInputType = {
    level?: true
    experience?: true
    health?: true
    maxHealth?: true
    mana?: true
    maxMana?: true
    strength?: true
    dexterity?: true
    intelligence?: true
    vitality?: true
    luck?: true
    availableStatPoints?: true
    baseCarryingCapacity?: true
    carryingCapacity?: true
    currentVolume?: true
    currentWeight?: true
    goldAmount?: true
    magicalStorageCapacity?: true
    magicalStorageUsed?: true
    maxStamina?: true
    maxVolume?: true
    movementPenalty?: true
    positionX?: true
    positionY?: true
    stamina?: true
    staminaRegenRate?: true
    baseStamina?: true
    luckPercentage?: true
  }

  export type GameCharacterSumAggregateInputType = {
    level?: true
    experience?: true
    health?: true
    maxHealth?: true
    mana?: true
    maxMana?: true
    strength?: true
    dexterity?: true
    intelligence?: true
    vitality?: true
    luck?: true
    availableStatPoints?: true
    baseCarryingCapacity?: true
    carryingCapacity?: true
    currentVolume?: true
    currentWeight?: true
    goldAmount?: true
    magicalStorageCapacity?: true
    magicalStorageUsed?: true
    maxStamina?: true
    maxVolume?: true
    movementPenalty?: true
    positionX?: true
    positionY?: true
    stamina?: true
    staminaRegenRate?: true
    baseStamina?: true
    luckPercentage?: true
  }

  export type GameCharacterMinAggregateInputType = {
    id?: true
    characterName?: true
    level?: true
    experience?: true
    health?: true
    maxHealth?: true
    mana?: true
    maxMana?: true
    strength?: true
    dexterity?: true
    intelligence?: true
    vitality?: true
    luck?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    availableStatPoints?: true
    baseCarryingCapacity?: true
    carryingCapacity?: true
    characterClass?: true
    currentMapLocation?: true
    currentVolume?: true
    currentWeight?: true
    equippedArmor?: true
    equippedBackpack?: true
    equippedWeapon?: true
    goldAmount?: true
    isResting?: true
    lastSaveTimestamp?: true
    lastStaminaUpdate?: true
    magicalStorageCapacity?: true
    magicalStorageUsed?: true
    maxStamina?: true
    maxVolume?: true
    movementPenalty?: true
    positionX?: true
    positionY?: true
    restStartTime?: true
    stamina?: true
    staminaRegenRate?: true
    baseStamina?: true
    equippedGloves?: true
    equippedPants?: true
    equippedShield?: true
    equippedShirt?: true
    equippedShoes?: true
    luckPercentage?: true
  }

  export type GameCharacterMaxAggregateInputType = {
    id?: true
    characterName?: true
    level?: true
    experience?: true
    health?: true
    maxHealth?: true
    mana?: true
    maxMana?: true
    strength?: true
    dexterity?: true
    intelligence?: true
    vitality?: true
    luck?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    availableStatPoints?: true
    baseCarryingCapacity?: true
    carryingCapacity?: true
    characterClass?: true
    currentMapLocation?: true
    currentVolume?: true
    currentWeight?: true
    equippedArmor?: true
    equippedBackpack?: true
    equippedWeapon?: true
    goldAmount?: true
    isResting?: true
    lastSaveTimestamp?: true
    lastStaminaUpdate?: true
    magicalStorageCapacity?: true
    magicalStorageUsed?: true
    maxStamina?: true
    maxVolume?: true
    movementPenalty?: true
    positionX?: true
    positionY?: true
    restStartTime?: true
    stamina?: true
    staminaRegenRate?: true
    baseStamina?: true
    equippedGloves?: true
    equippedPants?: true
    equippedShield?: true
    equippedShirt?: true
    equippedShoes?: true
    luckPercentage?: true
  }

  export type GameCharacterCountAggregateInputType = {
    id?: true
    characterName?: true
    level?: true
    experience?: true
    health?: true
    maxHealth?: true
    mana?: true
    maxMana?: true
    strength?: true
    dexterity?: true
    intelligence?: true
    vitality?: true
    luck?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    availableStatPoints?: true
    baseCarryingCapacity?: true
    carryingCapacity?: true
    characterClass?: true
    currentMapLocation?: true
    currentVolume?: true
    currentWeight?: true
    equippedArmor?: true
    equippedBackpack?: true
    equippedWeapon?: true
    goldAmount?: true
    isResting?: true
    lastSaveTimestamp?: true
    lastStaminaUpdate?: true
    magicalStorageCapacity?: true
    magicalStorageUsed?: true
    maxStamina?: true
    maxVolume?: true
    movementPenalty?: true
    positionX?: true
    positionY?: true
    restStartTime?: true
    stamina?: true
    staminaRegenRate?: true
    baseStamina?: true
    equippedGloves?: true
    equippedPants?: true
    equippedShield?: true
    equippedShirt?: true
    equippedShoes?: true
    luckPercentage?: true
    _all?: true
  }

  export type GameCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCharacter to aggregate.
     */
    where?: GameCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCharacters to fetch.
     */
    orderBy?: GameCharacterOrderByWithRelationInput | GameCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameCharacters
    **/
    _count?: true | GameCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameCharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameCharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameCharacterMaxAggregateInputType
  }

  export type GetGameCharacterAggregateType<T extends GameCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateGameCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameCharacter[P]>
      : GetScalarType<T[P], AggregateGameCharacter[P]>
  }




  export type GameCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameCharacterWhereInput
    orderBy?: GameCharacterOrderByWithAggregationInput | GameCharacterOrderByWithAggregationInput[]
    by: GameCharacterScalarFieldEnum[] | GameCharacterScalarFieldEnum
    having?: GameCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCharacterCountAggregateInputType | true
    _avg?: GameCharacterAvgAggregateInputType
    _sum?: GameCharacterSumAggregateInputType
    _min?: GameCharacterMinAggregateInputType
    _max?: GameCharacterMaxAggregateInputType
  }

  export type GameCharacterGroupByOutputType = {
    id: string
    characterName: string
    level: number
    experience: number
    health: number
    maxHealth: number
    mana: number
    maxMana: number
    strength: number
    dexterity: number
    intelligence: number
    vitality: number
    luck: number
    createdAt: Date
    updatedAt: Date
    userId: string
    availableStatPoints: number
    baseCarryingCapacity: number
    carryingCapacity: number
    characterClass: string
    currentMapLocation: string
    currentVolume: number
    currentWeight: number
    equippedArmor: string | null
    equippedBackpack: string | null
    equippedWeapon: string | null
    goldAmount: number
    isResting: boolean
    lastSaveTimestamp: Date
    lastStaminaUpdate: Date
    magicalStorageCapacity: number
    magicalStorageUsed: number
    maxStamina: number
    maxVolume: number
    movementPenalty: number
    positionX: number
    positionY: number
    restStartTime: Date | null
    stamina: number
    staminaRegenRate: number
    baseStamina: number
    equippedGloves: string | null
    equippedPants: string | null
    equippedShield: string | null
    equippedShirt: string | null
    equippedShoes: string | null
    luckPercentage: number
    _count: GameCharacterCountAggregateOutputType | null
    _avg: GameCharacterAvgAggregateOutputType | null
    _sum: GameCharacterSumAggregateOutputType | null
    _min: GameCharacterMinAggregateOutputType | null
    _max: GameCharacterMaxAggregateOutputType | null
  }

  type GetGameCharacterGroupByPayload<T extends GameCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], GameCharacterGroupByOutputType[P]>
        }
      >
    >


  export type GameCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    health?: boolean
    maxHealth?: boolean
    mana?: boolean
    maxMana?: boolean
    strength?: boolean
    dexterity?: boolean
    intelligence?: boolean
    vitality?: boolean
    luck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    availableStatPoints?: boolean
    baseCarryingCapacity?: boolean
    carryingCapacity?: boolean
    characterClass?: boolean
    currentMapLocation?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    equippedArmor?: boolean
    equippedBackpack?: boolean
    equippedWeapon?: boolean
    goldAmount?: boolean
    isResting?: boolean
    lastSaveTimestamp?: boolean
    lastStaminaUpdate?: boolean
    magicalStorageCapacity?: boolean
    magicalStorageUsed?: boolean
    maxStamina?: boolean
    maxVolume?: boolean
    movementPenalty?: boolean
    positionX?: boolean
    positionY?: boolean
    restStartTime?: boolean
    stamina?: boolean
    staminaRegenRate?: boolean
    baseStamina?: boolean
    equippedGloves?: boolean
    equippedPants?: boolean
    equippedShield?: boolean
    equippedShirt?: boolean
    equippedShoes?: boolean
    luckPercentage?: boolean
    bankAccounts?: boolean | GameCharacter$bankAccountsArgs<ExtArgs>
    characterKnowledges?: boolean | GameCharacter$characterKnowledgesArgs<ExtArgs>
    characterSkills?: boolean | GameCharacter$characterSkillsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobChangeHistory?: boolean | GameCharacter$jobChangeHistoryArgs<ExtArgs>
    magicalStorage?: boolean | GameCharacter$magicalStorageArgs<ExtArgs>
    playerInventories?: boolean | GameCharacter$playerInventoriesArgs<ExtArgs>
    _count?: boolean | GameCharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCharacter"]>

  export type GameCharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    health?: boolean
    maxHealth?: boolean
    mana?: boolean
    maxMana?: boolean
    strength?: boolean
    dexterity?: boolean
    intelligence?: boolean
    vitality?: boolean
    luck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    availableStatPoints?: boolean
    baseCarryingCapacity?: boolean
    carryingCapacity?: boolean
    characterClass?: boolean
    currentMapLocation?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    equippedArmor?: boolean
    equippedBackpack?: boolean
    equippedWeapon?: boolean
    goldAmount?: boolean
    isResting?: boolean
    lastSaveTimestamp?: boolean
    lastStaminaUpdate?: boolean
    magicalStorageCapacity?: boolean
    magicalStorageUsed?: boolean
    maxStamina?: boolean
    maxVolume?: boolean
    movementPenalty?: boolean
    positionX?: boolean
    positionY?: boolean
    restStartTime?: boolean
    stamina?: boolean
    staminaRegenRate?: boolean
    baseStamina?: boolean
    equippedGloves?: boolean
    equippedPants?: boolean
    equippedShield?: boolean
    equippedShirt?: boolean
    equippedShoes?: boolean
    luckPercentage?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCharacter"]>

  export type GameCharacterSelectScalar = {
    id?: boolean
    characterName?: boolean
    level?: boolean
    experience?: boolean
    health?: boolean
    maxHealth?: boolean
    mana?: boolean
    maxMana?: boolean
    strength?: boolean
    dexterity?: boolean
    intelligence?: boolean
    vitality?: boolean
    luck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    availableStatPoints?: boolean
    baseCarryingCapacity?: boolean
    carryingCapacity?: boolean
    characterClass?: boolean
    currentMapLocation?: boolean
    currentVolume?: boolean
    currentWeight?: boolean
    equippedArmor?: boolean
    equippedBackpack?: boolean
    equippedWeapon?: boolean
    goldAmount?: boolean
    isResting?: boolean
    lastSaveTimestamp?: boolean
    lastStaminaUpdate?: boolean
    magicalStorageCapacity?: boolean
    magicalStorageUsed?: boolean
    maxStamina?: boolean
    maxVolume?: boolean
    movementPenalty?: boolean
    positionX?: boolean
    positionY?: boolean
    restStartTime?: boolean
    stamina?: boolean
    staminaRegenRate?: boolean
    baseStamina?: boolean
    equippedGloves?: boolean
    equippedPants?: boolean
    equippedShield?: boolean
    equippedShirt?: boolean
    equippedShoes?: boolean
    luckPercentage?: boolean
  }

  export type GameCharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccounts?: boolean | GameCharacter$bankAccountsArgs<ExtArgs>
    characterKnowledges?: boolean | GameCharacter$characterKnowledgesArgs<ExtArgs>
    characterSkills?: boolean | GameCharacter$characterSkillsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobChangeHistory?: boolean | GameCharacter$jobChangeHistoryArgs<ExtArgs>
    magicalStorage?: boolean | GameCharacter$magicalStorageArgs<ExtArgs>
    playerInventories?: boolean | GameCharacter$playerInventoriesArgs<ExtArgs>
    _count?: boolean | GameCharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameCharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameCharacter"
    objects: {
      bankAccounts: Prisma.$BankAccountPayload<ExtArgs> | null
      characterKnowledges: Prisma.$CharacterKnowledgePayload<ExtArgs>[]
      characterSkills: Prisma.$CharacterSkillPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      jobChangeHistory: Prisma.$JobChangeHistoryPayload<ExtArgs>[]
      magicalStorage: Prisma.$MagicalStoragePayload<ExtArgs>[]
      playerInventories: Prisma.$PlayerInventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterName: string
      level: number
      experience: number
      health: number
      maxHealth: number
      mana: number
      maxMana: number
      strength: number
      dexterity: number
      intelligence: number
      vitality: number
      luck: number
      createdAt: Date
      updatedAt: Date
      userId: string
      availableStatPoints: number
      baseCarryingCapacity: number
      carryingCapacity: number
      characterClass: string
      currentMapLocation: string
      currentVolume: number
      currentWeight: number
      equippedArmor: string | null
      equippedBackpack: string | null
      equippedWeapon: string | null
      goldAmount: number
      isResting: boolean
      lastSaveTimestamp: Date
      lastStaminaUpdate: Date
      magicalStorageCapacity: number
      magicalStorageUsed: number
      maxStamina: number
      maxVolume: number
      movementPenalty: number
      positionX: number
      positionY: number
      restStartTime: Date | null
      stamina: number
      staminaRegenRate: number
      baseStamina: number
      equippedGloves: string | null
      equippedPants: string | null
      equippedShield: string | null
      equippedShirt: string | null
      equippedShoes: string | null
      luckPercentage: number
    }, ExtArgs["result"]["gameCharacter"]>
    composites: {}
  }

  type GameCharacterGetPayload<S extends boolean | null | undefined | GameCharacterDefaultArgs> = $Result.GetResult<Prisma.$GameCharacterPayload, S>

  type GameCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameCharacterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameCharacterCountAggregateInputType | true
    }

  export interface GameCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameCharacter'], meta: { name: 'GameCharacter' } }
    /**
     * Find zero or one GameCharacter that matches the filter.
     * @param {GameCharacterFindUniqueArgs} args - Arguments to find a GameCharacter
     * @example
     * // Get one GameCharacter
     * const gameCharacter = await prisma.gameCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameCharacterFindUniqueArgs>(args: SelectSubset<T, GameCharacterFindUniqueArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameCharacter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameCharacterFindUniqueOrThrowArgs} args - Arguments to find a GameCharacter
     * @example
     * // Get one GameCharacter
     * const gameCharacter = await prisma.gameCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameCharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, GameCharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterFindFirstArgs} args - Arguments to find a GameCharacter
     * @example
     * // Get one GameCharacter
     * const gameCharacter = await prisma.gameCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameCharacterFindFirstArgs>(args?: SelectSubset<T, GameCharacterFindFirstArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterFindFirstOrThrowArgs} args - Arguments to find a GameCharacter
     * @example
     * // Get one GameCharacter
     * const gameCharacter = await prisma.gameCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameCharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, GameCharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameCharacters
     * const gameCharacters = await prisma.gameCharacter.findMany()
     * 
     * // Get first 10 GameCharacters
     * const gameCharacters = await prisma.gameCharacter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameCharacterWithIdOnly = await prisma.gameCharacter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameCharacterFindManyArgs>(args?: SelectSubset<T, GameCharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameCharacter.
     * @param {GameCharacterCreateArgs} args - Arguments to create a GameCharacter.
     * @example
     * // Create one GameCharacter
     * const GameCharacter = await prisma.gameCharacter.create({
     *   data: {
     *     // ... data to create a GameCharacter
     *   }
     * })
     * 
     */
    create<T extends GameCharacterCreateArgs>(args: SelectSubset<T, GameCharacterCreateArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameCharacters.
     * @param {GameCharacterCreateManyArgs} args - Arguments to create many GameCharacters.
     * @example
     * // Create many GameCharacters
     * const gameCharacter = await prisma.gameCharacter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCharacterCreateManyArgs>(args?: SelectSubset<T, GameCharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameCharacters and returns the data saved in the database.
     * @param {GameCharacterCreateManyAndReturnArgs} args - Arguments to create many GameCharacters.
     * @example
     * // Create many GameCharacters
     * const gameCharacter = await prisma.gameCharacter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameCharacters and only return the `id`
     * const gameCharacterWithIdOnly = await prisma.gameCharacter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameCharacter.
     * @param {GameCharacterDeleteArgs} args - Arguments to delete one GameCharacter.
     * @example
     * // Delete one GameCharacter
     * const GameCharacter = await prisma.gameCharacter.delete({
     *   where: {
     *     // ... filter to delete one GameCharacter
     *   }
     * })
     * 
     */
    delete<T extends GameCharacterDeleteArgs>(args: SelectSubset<T, GameCharacterDeleteArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameCharacter.
     * @param {GameCharacterUpdateArgs} args - Arguments to update one GameCharacter.
     * @example
     * // Update one GameCharacter
     * const gameCharacter = await prisma.gameCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameCharacterUpdateArgs>(args: SelectSubset<T, GameCharacterUpdateArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameCharacters.
     * @param {GameCharacterDeleteManyArgs} args - Arguments to filter GameCharacters to delete.
     * @example
     * // Delete a few GameCharacters
     * const { count } = await prisma.gameCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameCharacterDeleteManyArgs>(args?: SelectSubset<T, GameCharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameCharacters
     * const gameCharacter = await prisma.gameCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameCharacterUpdateManyArgs>(args: SelectSubset<T, GameCharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameCharacter.
     * @param {GameCharacterUpsertArgs} args - Arguments to update or create a GameCharacter.
     * @example
     * // Update or create a GameCharacter
     * const gameCharacter = await prisma.gameCharacter.upsert({
     *   create: {
     *     // ... data to create a GameCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameCharacter we want to update
     *   }
     * })
     */
    upsert<T extends GameCharacterUpsertArgs>(args: SelectSubset<T, GameCharacterUpsertArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterCountArgs} args - Arguments to filter GameCharacters to count.
     * @example
     * // Count the number of GameCharacters
     * const count = await prisma.gameCharacter.count({
     *   where: {
     *     // ... the filter for the GameCharacters we want to count
     *   }
     * })
    **/
    count<T extends GameCharacterCountArgs>(
      args?: Subset<T, GameCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameCharacterAggregateArgs>(args: Subset<T, GameCharacterAggregateArgs>): Prisma.PrismaPromise<GetGameCharacterAggregateType<T>>

    /**
     * Group by GameCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameCharacterGroupByArgs['orderBy'] }
        : { orderBy?: GameCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameCharacter model
   */
  readonly fields: GameCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bankAccounts<T extends GameCharacter$bankAccountsArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacter$bankAccountsArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    characterKnowledges<T extends GameCharacter$characterKnowledgesArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacter$characterKnowledgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterKnowledgePayload<ExtArgs>, T, "findMany"> | Null>
    characterSkills<T extends GameCharacter$characterSkillsArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacter$characterSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jobChangeHistory<T extends GameCharacter$jobChangeHistoryArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacter$jobChangeHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    magicalStorage<T extends GameCharacter$magicalStorageArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacter$magicalStorageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "findMany"> | Null>
    playerInventories<T extends GameCharacter$playerInventoriesArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacter$playerInventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameCharacter model
   */ 
  interface GameCharacterFieldRefs {
    readonly id: FieldRef<"GameCharacter", 'String'>
    readonly characterName: FieldRef<"GameCharacter", 'String'>
    readonly level: FieldRef<"GameCharacter", 'Int'>
    readonly experience: FieldRef<"GameCharacter", 'Int'>
    readonly health: FieldRef<"GameCharacter", 'Int'>
    readonly maxHealth: FieldRef<"GameCharacter", 'Int'>
    readonly mana: FieldRef<"GameCharacter", 'Int'>
    readonly maxMana: FieldRef<"GameCharacter", 'Int'>
    readonly strength: FieldRef<"GameCharacter", 'Int'>
    readonly dexterity: FieldRef<"GameCharacter", 'Int'>
    readonly intelligence: FieldRef<"GameCharacter", 'Int'>
    readonly vitality: FieldRef<"GameCharacter", 'Int'>
    readonly luck: FieldRef<"GameCharacter", 'Int'>
    readonly createdAt: FieldRef<"GameCharacter", 'DateTime'>
    readonly updatedAt: FieldRef<"GameCharacter", 'DateTime'>
    readonly userId: FieldRef<"GameCharacter", 'String'>
    readonly availableStatPoints: FieldRef<"GameCharacter", 'Int'>
    readonly baseCarryingCapacity: FieldRef<"GameCharacter", 'Float'>
    readonly carryingCapacity: FieldRef<"GameCharacter", 'Float'>
    readonly characterClass: FieldRef<"GameCharacter", 'String'>
    readonly currentMapLocation: FieldRef<"GameCharacter", 'String'>
    readonly currentVolume: FieldRef<"GameCharacter", 'Float'>
    readonly currentWeight: FieldRef<"GameCharacter", 'Float'>
    readonly equippedArmor: FieldRef<"GameCharacter", 'String'>
    readonly equippedBackpack: FieldRef<"GameCharacter", 'String'>
    readonly equippedWeapon: FieldRef<"GameCharacter", 'String'>
    readonly goldAmount: FieldRef<"GameCharacter", 'Int'>
    readonly isResting: FieldRef<"GameCharacter", 'Boolean'>
    readonly lastSaveTimestamp: FieldRef<"GameCharacter", 'DateTime'>
    readonly lastStaminaUpdate: FieldRef<"GameCharacter", 'DateTime'>
    readonly magicalStorageCapacity: FieldRef<"GameCharacter", 'Float'>
    readonly magicalStorageUsed: FieldRef<"GameCharacter", 'Float'>
    readonly maxStamina: FieldRef<"GameCharacter", 'Float'>
    readonly maxVolume: FieldRef<"GameCharacter", 'Float'>
    readonly movementPenalty: FieldRef<"GameCharacter", 'Float'>
    readonly positionX: FieldRef<"GameCharacter", 'Float'>
    readonly positionY: FieldRef<"GameCharacter", 'Float'>
    readonly restStartTime: FieldRef<"GameCharacter", 'DateTime'>
    readonly stamina: FieldRef<"GameCharacter", 'Float'>
    readonly staminaRegenRate: FieldRef<"GameCharacter", 'Float'>
    readonly baseStamina: FieldRef<"GameCharacter", 'Int'>
    readonly equippedGloves: FieldRef<"GameCharacter", 'String'>
    readonly equippedPants: FieldRef<"GameCharacter", 'String'>
    readonly equippedShield: FieldRef<"GameCharacter", 'String'>
    readonly equippedShirt: FieldRef<"GameCharacter", 'String'>
    readonly equippedShoes: FieldRef<"GameCharacter", 'String'>
    readonly luckPercentage: FieldRef<"GameCharacter", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * GameCharacter findUnique
   */
  export type GameCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * Filter, which GameCharacter to fetch.
     */
    where: GameCharacterWhereUniqueInput
  }

  /**
   * GameCharacter findUniqueOrThrow
   */
  export type GameCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * Filter, which GameCharacter to fetch.
     */
    where: GameCharacterWhereUniqueInput
  }

  /**
   * GameCharacter findFirst
   */
  export type GameCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * Filter, which GameCharacter to fetch.
     */
    where?: GameCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCharacters to fetch.
     */
    orderBy?: GameCharacterOrderByWithRelationInput | GameCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameCharacters.
     */
    cursor?: GameCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameCharacters.
     */
    distinct?: GameCharacterScalarFieldEnum | GameCharacterScalarFieldEnum[]
  }

  /**
   * GameCharacter findFirstOrThrow
   */
  export type GameCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * Filter, which GameCharacter to fetch.
     */
    where?: GameCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCharacters to fetch.
     */
    orderBy?: GameCharacterOrderByWithRelationInput | GameCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameCharacters.
     */
    cursor?: GameCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameCharacters.
     */
    distinct?: GameCharacterScalarFieldEnum | GameCharacterScalarFieldEnum[]
  }

  /**
   * GameCharacter findMany
   */
  export type GameCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * Filter, which GameCharacters to fetch.
     */
    where?: GameCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameCharacters to fetch.
     */
    orderBy?: GameCharacterOrderByWithRelationInput | GameCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameCharacters.
     */
    cursor?: GameCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameCharacters.
     */
    skip?: number
    distinct?: GameCharacterScalarFieldEnum | GameCharacterScalarFieldEnum[]
  }

  /**
   * GameCharacter create
   */
  export type GameCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a GameCharacter.
     */
    data: XOR<GameCharacterCreateInput, GameCharacterUncheckedCreateInput>
  }

  /**
   * GameCharacter createMany
   */
  export type GameCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameCharacters.
     */
    data: GameCharacterCreateManyInput | GameCharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameCharacter createManyAndReturn
   */
  export type GameCharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameCharacters.
     */
    data: GameCharacterCreateManyInput | GameCharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameCharacter update
   */
  export type GameCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a GameCharacter.
     */
    data: XOR<GameCharacterUpdateInput, GameCharacterUncheckedUpdateInput>
    /**
     * Choose, which GameCharacter to update.
     */
    where: GameCharacterWhereUniqueInput
  }

  /**
   * GameCharacter updateMany
   */
  export type GameCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameCharacters.
     */
    data: XOR<GameCharacterUpdateManyMutationInput, GameCharacterUncheckedUpdateManyInput>
    /**
     * Filter which GameCharacters to update
     */
    where?: GameCharacterWhereInput
  }

  /**
   * GameCharacter upsert
   */
  export type GameCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the GameCharacter to update in case it exists.
     */
    where: GameCharacterWhereUniqueInput
    /**
     * In case the GameCharacter found by the `where` argument doesn't exist, create a new GameCharacter with this data.
     */
    create: XOR<GameCharacterCreateInput, GameCharacterUncheckedCreateInput>
    /**
     * In case the GameCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameCharacterUpdateInput, GameCharacterUncheckedUpdateInput>
  }

  /**
   * GameCharacter delete
   */
  export type GameCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    /**
     * Filter which GameCharacter to delete.
     */
    where: GameCharacterWhereUniqueInput
  }

  /**
   * GameCharacter deleteMany
   */
  export type GameCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCharacters to delete
     */
    where?: GameCharacterWhereInput
  }

  /**
   * GameCharacter.bankAccounts
   */
  export type GameCharacter$bankAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
  }

  /**
   * GameCharacter.characterKnowledges
   */
  export type GameCharacter$characterKnowledgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterKnowledge
     */
    select?: CharacterKnowledgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterKnowledgeInclude<ExtArgs> | null
    where?: CharacterKnowledgeWhereInput
    orderBy?: CharacterKnowledgeOrderByWithRelationInput | CharacterKnowledgeOrderByWithRelationInput[]
    cursor?: CharacterKnowledgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterKnowledgeScalarFieldEnum | CharacterKnowledgeScalarFieldEnum[]
  }

  /**
   * GameCharacter.characterSkills
   */
  export type GameCharacter$characterSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    cursor?: CharacterSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * GameCharacter.jobChangeHistory
   */
  export type GameCharacter$jobChangeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    where?: JobChangeHistoryWhereInput
    orderBy?: JobChangeHistoryOrderByWithRelationInput | JobChangeHistoryOrderByWithRelationInput[]
    cursor?: JobChangeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobChangeHistoryScalarFieldEnum | JobChangeHistoryScalarFieldEnum[]
  }

  /**
   * GameCharacter.magicalStorage
   */
  export type GameCharacter$magicalStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    where?: MagicalStorageWhereInput
    orderBy?: MagicalStorageOrderByWithRelationInput | MagicalStorageOrderByWithRelationInput[]
    cursor?: MagicalStorageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicalStorageScalarFieldEnum | MagicalStorageScalarFieldEnum[]
  }

  /**
   * GameCharacter.playerInventories
   */
  export type GameCharacter$playerInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    where?: PlayerInventoryWhereInput
    orderBy?: PlayerInventoryOrderByWithRelationInput | PlayerInventoryOrderByWithRelationInput[]
    cursor?: PlayerInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerInventoryScalarFieldEnum | PlayerInventoryScalarFieldEnum[]
  }

  /**
   * GameCharacter without action
   */
  export type GameCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
  }


  /**
   * Model JobChangeHistory
   */

  export type AggregateJobChangeHistory = {
    _count: JobChangeHistoryCountAggregateOutputType | null
    _avg: JobChangeHistoryAvgAggregateOutputType | null
    _sum: JobChangeHistorySumAggregateOutputType | null
    _min: JobChangeHistoryMinAggregateOutputType | null
    _max: JobChangeHistoryMaxAggregateOutputType | null
  }

  export type JobChangeHistoryAvgAggregateOutputType = {
    costPaid: number | null
    levelAtChange: number | null
  }

  export type JobChangeHistorySumAggregateOutputType = {
    costPaid: number | null
    levelAtChange: number | null
  }

  export type JobChangeHistoryMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    fromClass: string | null
    toClass: string | null
    changedAt: Date | null
    npcTrainerId: string | null
    costPaid: number | null
    levelAtChange: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobChangeHistoryMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    fromClass: string | null
    toClass: string | null
    changedAt: Date | null
    npcTrainerId: string | null
    costPaid: number | null
    levelAtChange: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobChangeHistoryCountAggregateOutputType = {
    id: number
    characterId: number
    fromClass: number
    toClass: number
    changedAt: number
    npcTrainerId: number
    costPaid: number
    levelAtChange: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobChangeHistoryAvgAggregateInputType = {
    costPaid?: true
    levelAtChange?: true
  }

  export type JobChangeHistorySumAggregateInputType = {
    costPaid?: true
    levelAtChange?: true
  }

  export type JobChangeHistoryMinAggregateInputType = {
    id?: true
    characterId?: true
    fromClass?: true
    toClass?: true
    changedAt?: true
    npcTrainerId?: true
    costPaid?: true
    levelAtChange?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobChangeHistoryMaxAggregateInputType = {
    id?: true
    characterId?: true
    fromClass?: true
    toClass?: true
    changedAt?: true
    npcTrainerId?: true
    costPaid?: true
    levelAtChange?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobChangeHistoryCountAggregateInputType = {
    id?: true
    characterId?: true
    fromClass?: true
    toClass?: true
    changedAt?: true
    npcTrainerId?: true
    costPaid?: true
    levelAtChange?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobChangeHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobChangeHistory to aggregate.
     */
    where?: JobChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobChangeHistories to fetch.
     */
    orderBy?: JobChangeHistoryOrderByWithRelationInput | JobChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobChangeHistories
    **/
    _count?: true | JobChangeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobChangeHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobChangeHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobChangeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobChangeHistoryMaxAggregateInputType
  }

  export type GetJobChangeHistoryAggregateType<T extends JobChangeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateJobChangeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobChangeHistory[P]>
      : GetScalarType<T[P], AggregateJobChangeHistory[P]>
  }




  export type JobChangeHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobChangeHistoryWhereInput
    orderBy?: JobChangeHistoryOrderByWithAggregationInput | JobChangeHistoryOrderByWithAggregationInput[]
    by: JobChangeHistoryScalarFieldEnum[] | JobChangeHistoryScalarFieldEnum
    having?: JobChangeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobChangeHistoryCountAggregateInputType | true
    _avg?: JobChangeHistoryAvgAggregateInputType
    _sum?: JobChangeHistorySumAggregateInputType
    _min?: JobChangeHistoryMinAggregateInputType
    _max?: JobChangeHistoryMaxAggregateInputType
  }

  export type JobChangeHistoryGroupByOutputType = {
    id: string
    characterId: string
    fromClass: string
    toClass: string
    changedAt: Date
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: JobChangeHistoryCountAggregateOutputType | null
    _avg: JobChangeHistoryAvgAggregateOutputType | null
    _sum: JobChangeHistorySumAggregateOutputType | null
    _min: JobChangeHistoryMinAggregateOutputType | null
    _max: JobChangeHistoryMaxAggregateOutputType | null
  }

  type GetJobChangeHistoryGroupByPayload<T extends JobChangeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobChangeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobChangeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobChangeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], JobChangeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type JobChangeHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    fromClass?: boolean
    toClass?: boolean
    changedAt?: boolean
    npcTrainerId?: boolean
    costPaid?: boolean
    levelAtChange?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobChangeHistory"]>

  export type JobChangeHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    fromClass?: boolean
    toClass?: boolean
    changedAt?: boolean
    npcTrainerId?: boolean
    costPaid?: boolean
    levelAtChange?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobChangeHistory"]>

  export type JobChangeHistorySelectScalar = {
    id?: boolean
    characterId?: boolean
    fromClass?: boolean
    toClass?: boolean
    changedAt?: boolean
    npcTrainerId?: boolean
    costPaid?: boolean
    levelAtChange?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobChangeHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }
  export type JobChangeHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }

  export type $JobChangeHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobChangeHistory"
    objects: {
      gameCharacters: Prisma.$GameCharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      fromClass: string
      toClass: string
      changedAt: Date
      npcTrainerId: string
      costPaid: number
      levelAtChange: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobChangeHistory"]>
    composites: {}
  }

  type JobChangeHistoryGetPayload<S extends boolean | null | undefined | JobChangeHistoryDefaultArgs> = $Result.GetResult<Prisma.$JobChangeHistoryPayload, S>

  type JobChangeHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobChangeHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobChangeHistoryCountAggregateInputType | true
    }

  export interface JobChangeHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobChangeHistory'], meta: { name: 'JobChangeHistory' } }
    /**
     * Find zero or one JobChangeHistory that matches the filter.
     * @param {JobChangeHistoryFindUniqueArgs} args - Arguments to find a JobChangeHistory
     * @example
     * // Get one JobChangeHistory
     * const jobChangeHistory = await prisma.jobChangeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobChangeHistoryFindUniqueArgs>(args: SelectSubset<T, JobChangeHistoryFindUniqueArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobChangeHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobChangeHistoryFindUniqueOrThrowArgs} args - Arguments to find a JobChangeHistory
     * @example
     * // Get one JobChangeHistory
     * const jobChangeHistory = await prisma.jobChangeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobChangeHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, JobChangeHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobChangeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryFindFirstArgs} args - Arguments to find a JobChangeHistory
     * @example
     * // Get one JobChangeHistory
     * const jobChangeHistory = await prisma.jobChangeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobChangeHistoryFindFirstArgs>(args?: SelectSubset<T, JobChangeHistoryFindFirstArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobChangeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryFindFirstOrThrowArgs} args - Arguments to find a JobChangeHistory
     * @example
     * // Get one JobChangeHistory
     * const jobChangeHistory = await prisma.jobChangeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobChangeHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, JobChangeHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobChangeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobChangeHistories
     * const jobChangeHistories = await prisma.jobChangeHistory.findMany()
     * 
     * // Get first 10 JobChangeHistories
     * const jobChangeHistories = await prisma.jobChangeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobChangeHistoryWithIdOnly = await prisma.jobChangeHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobChangeHistoryFindManyArgs>(args?: SelectSubset<T, JobChangeHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobChangeHistory.
     * @param {JobChangeHistoryCreateArgs} args - Arguments to create a JobChangeHistory.
     * @example
     * // Create one JobChangeHistory
     * const JobChangeHistory = await prisma.jobChangeHistory.create({
     *   data: {
     *     // ... data to create a JobChangeHistory
     *   }
     * })
     * 
     */
    create<T extends JobChangeHistoryCreateArgs>(args: SelectSubset<T, JobChangeHistoryCreateArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobChangeHistories.
     * @param {JobChangeHistoryCreateManyArgs} args - Arguments to create many JobChangeHistories.
     * @example
     * // Create many JobChangeHistories
     * const jobChangeHistory = await prisma.jobChangeHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobChangeHistoryCreateManyArgs>(args?: SelectSubset<T, JobChangeHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobChangeHistories and returns the data saved in the database.
     * @param {JobChangeHistoryCreateManyAndReturnArgs} args - Arguments to create many JobChangeHistories.
     * @example
     * // Create many JobChangeHistories
     * const jobChangeHistory = await prisma.jobChangeHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobChangeHistories and only return the `id`
     * const jobChangeHistoryWithIdOnly = await prisma.jobChangeHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobChangeHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, JobChangeHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JobChangeHistory.
     * @param {JobChangeHistoryDeleteArgs} args - Arguments to delete one JobChangeHistory.
     * @example
     * // Delete one JobChangeHistory
     * const JobChangeHistory = await prisma.jobChangeHistory.delete({
     *   where: {
     *     // ... filter to delete one JobChangeHistory
     *   }
     * })
     * 
     */
    delete<T extends JobChangeHistoryDeleteArgs>(args: SelectSubset<T, JobChangeHistoryDeleteArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobChangeHistory.
     * @param {JobChangeHistoryUpdateArgs} args - Arguments to update one JobChangeHistory.
     * @example
     * // Update one JobChangeHistory
     * const jobChangeHistory = await prisma.jobChangeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobChangeHistoryUpdateArgs>(args: SelectSubset<T, JobChangeHistoryUpdateArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobChangeHistories.
     * @param {JobChangeHistoryDeleteManyArgs} args - Arguments to filter JobChangeHistories to delete.
     * @example
     * // Delete a few JobChangeHistories
     * const { count } = await prisma.jobChangeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobChangeHistoryDeleteManyArgs>(args?: SelectSubset<T, JobChangeHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobChangeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobChangeHistories
     * const jobChangeHistory = await prisma.jobChangeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobChangeHistoryUpdateManyArgs>(args: SelectSubset<T, JobChangeHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobChangeHistory.
     * @param {JobChangeHistoryUpsertArgs} args - Arguments to update or create a JobChangeHistory.
     * @example
     * // Update or create a JobChangeHistory
     * const jobChangeHistory = await prisma.jobChangeHistory.upsert({
     *   create: {
     *     // ... data to create a JobChangeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobChangeHistory we want to update
     *   }
     * })
     */
    upsert<T extends JobChangeHistoryUpsertArgs>(args: SelectSubset<T, JobChangeHistoryUpsertArgs<ExtArgs>>): Prisma__JobChangeHistoryClient<$Result.GetResult<Prisma.$JobChangeHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobChangeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryCountArgs} args - Arguments to filter JobChangeHistories to count.
     * @example
     * // Count the number of JobChangeHistories
     * const count = await prisma.jobChangeHistory.count({
     *   where: {
     *     // ... the filter for the JobChangeHistories we want to count
     *   }
     * })
    **/
    count<T extends JobChangeHistoryCountArgs>(
      args?: Subset<T, JobChangeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobChangeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobChangeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobChangeHistoryAggregateArgs>(args: Subset<T, JobChangeHistoryAggregateArgs>): Prisma.PrismaPromise<GetJobChangeHistoryAggregateType<T>>

    /**
     * Group by JobChangeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobChangeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobChangeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobChangeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: JobChangeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobChangeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobChangeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobChangeHistory model
   */
  readonly fields: JobChangeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobChangeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobChangeHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameCharacters<T extends GameCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacterDefaultArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobChangeHistory model
   */ 
  interface JobChangeHistoryFieldRefs {
    readonly id: FieldRef<"JobChangeHistory", 'String'>
    readonly characterId: FieldRef<"JobChangeHistory", 'String'>
    readonly fromClass: FieldRef<"JobChangeHistory", 'String'>
    readonly toClass: FieldRef<"JobChangeHistory", 'String'>
    readonly changedAt: FieldRef<"JobChangeHistory", 'DateTime'>
    readonly npcTrainerId: FieldRef<"JobChangeHistory", 'String'>
    readonly costPaid: FieldRef<"JobChangeHistory", 'Int'>
    readonly levelAtChange: FieldRef<"JobChangeHistory", 'Int'>
    readonly notes: FieldRef<"JobChangeHistory", 'String'>
    readonly createdAt: FieldRef<"JobChangeHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"JobChangeHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobChangeHistory findUnique
   */
  export type JobChangeHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobChangeHistory to fetch.
     */
    where: JobChangeHistoryWhereUniqueInput
  }

  /**
   * JobChangeHistory findUniqueOrThrow
   */
  export type JobChangeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobChangeHistory to fetch.
     */
    where: JobChangeHistoryWhereUniqueInput
  }

  /**
   * JobChangeHistory findFirst
   */
  export type JobChangeHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobChangeHistory to fetch.
     */
    where?: JobChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobChangeHistories to fetch.
     */
    orderBy?: JobChangeHistoryOrderByWithRelationInput | JobChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobChangeHistories.
     */
    cursor?: JobChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobChangeHistories.
     */
    distinct?: JobChangeHistoryScalarFieldEnum | JobChangeHistoryScalarFieldEnum[]
  }

  /**
   * JobChangeHistory findFirstOrThrow
   */
  export type JobChangeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobChangeHistory to fetch.
     */
    where?: JobChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobChangeHistories to fetch.
     */
    orderBy?: JobChangeHistoryOrderByWithRelationInput | JobChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobChangeHistories.
     */
    cursor?: JobChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobChangeHistories.
     */
    distinct?: JobChangeHistoryScalarFieldEnum | JobChangeHistoryScalarFieldEnum[]
  }

  /**
   * JobChangeHistory findMany
   */
  export type JobChangeHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which JobChangeHistories to fetch.
     */
    where?: JobChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobChangeHistories to fetch.
     */
    orderBy?: JobChangeHistoryOrderByWithRelationInput | JobChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobChangeHistories.
     */
    cursor?: JobChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobChangeHistories.
     */
    skip?: number
    distinct?: JobChangeHistoryScalarFieldEnum | JobChangeHistoryScalarFieldEnum[]
  }

  /**
   * JobChangeHistory create
   */
  export type JobChangeHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a JobChangeHistory.
     */
    data: XOR<JobChangeHistoryCreateInput, JobChangeHistoryUncheckedCreateInput>
  }

  /**
   * JobChangeHistory createMany
   */
  export type JobChangeHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobChangeHistories.
     */
    data: JobChangeHistoryCreateManyInput | JobChangeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobChangeHistory createManyAndReturn
   */
  export type JobChangeHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JobChangeHistories.
     */
    data: JobChangeHistoryCreateManyInput | JobChangeHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobChangeHistory update
   */
  export type JobChangeHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a JobChangeHistory.
     */
    data: XOR<JobChangeHistoryUpdateInput, JobChangeHistoryUncheckedUpdateInput>
    /**
     * Choose, which JobChangeHistory to update.
     */
    where: JobChangeHistoryWhereUniqueInput
  }

  /**
   * JobChangeHistory updateMany
   */
  export type JobChangeHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobChangeHistories.
     */
    data: XOR<JobChangeHistoryUpdateManyMutationInput, JobChangeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which JobChangeHistories to update
     */
    where?: JobChangeHistoryWhereInput
  }

  /**
   * JobChangeHistory upsert
   */
  export type JobChangeHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the JobChangeHistory to update in case it exists.
     */
    where: JobChangeHistoryWhereUniqueInput
    /**
     * In case the JobChangeHistory found by the `where` argument doesn't exist, create a new JobChangeHistory with this data.
     */
    create: XOR<JobChangeHistoryCreateInput, JobChangeHistoryUncheckedCreateInput>
    /**
     * In case the JobChangeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobChangeHistoryUpdateInput, JobChangeHistoryUncheckedUpdateInput>
  }

  /**
   * JobChangeHistory delete
   */
  export type JobChangeHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter which JobChangeHistory to delete.
     */
    where: JobChangeHistoryWhereUniqueInput
  }

  /**
   * JobChangeHistory deleteMany
   */
  export type JobChangeHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobChangeHistories to delete
     */
    where?: JobChangeHistoryWhereInput
  }

  /**
   * JobChangeHistory without action
   */
  export type JobChangeHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobChangeHistory
     */
    select?: JobChangeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobChangeHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LoanPayment
   */

  export type AggregateLoanPayment = {
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  export type LoanPaymentAvgAggregateOutputType = {
    amount: number | null
    principalPaid: number | null
    interestPaid: number | null
  }

  export type LoanPaymentSumAggregateOutputType = {
    amount: number | null
    principalPaid: number | null
    interestPaid: number | null
  }

  export type LoanPaymentMinAggregateOutputType = {
    id: string | null
    loanId: string | null
    amount: number | null
    paymentDate: Date | null
    principalPaid: number | null
    interestPaid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanPaymentMaxAggregateOutputType = {
    id: string | null
    loanId: string | null
    amount: number | null
    paymentDate: Date | null
    principalPaid: number | null
    interestPaid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanPaymentCountAggregateOutputType = {
    id: number
    loanId: number
    amount: number
    paymentDate: number
    principalPaid: number
    interestPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanPaymentAvgAggregateInputType = {
    amount?: true
    principalPaid?: true
    interestPaid?: true
  }

  export type LoanPaymentSumAggregateInputType = {
    amount?: true
    principalPaid?: true
    interestPaid?: true
  }

  export type LoanPaymentMinAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    paymentDate?: true
    principalPaid?: true
    interestPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanPaymentMaxAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    paymentDate?: true
    principalPaid?: true
    interestPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanPaymentCountAggregateInputType = {
    id?: true
    loanId?: true
    amount?: true
    paymentDate?: true
    principalPaid?: true
    interestPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanPayment to aggregate.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanPayments
    **/
    _count?: true | LoanPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type GetLoanPaymentAggregateType<T extends LoanPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanPayment[P]>
      : GetScalarType<T[P], AggregateLoanPayment[P]>
  }




  export type LoanPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithAggregationInput | LoanPaymentOrderByWithAggregationInput[]
    by: LoanPaymentScalarFieldEnum[] | LoanPaymentScalarFieldEnum
    having?: LoanPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanPaymentCountAggregateInputType | true
    _avg?: LoanPaymentAvgAggregateInputType
    _sum?: LoanPaymentSumAggregateInputType
    _min?: LoanPaymentMinAggregateInputType
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type LoanPaymentGroupByOutputType = {
    id: string
    loanId: string
    amount: number
    paymentDate: Date
    principalPaid: number
    interestPaid: number
    createdAt: Date
    updatedAt: Date
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  type GetLoanPaymentGroupByPayload<T extends LoanPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
        }
      >
    >


  export type LoanPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentDate?: boolean
    principalPaid?: boolean
    interestPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loans?: boolean | LoanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentDate?: boolean
    principalPaid?: boolean
    interestPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loans?: boolean | LoanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectScalar = {
    id?: boolean
    loanId?: boolean
    amount?: boolean
    paymentDate?: boolean
    principalPaid?: boolean
    interestPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loans?: boolean | LoanDefaultArgs<ExtArgs>
  }
  export type LoanPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loans?: boolean | LoanDefaultArgs<ExtArgs>
  }

  export type $LoanPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanPayment"
    objects: {
      loans: Prisma.$LoanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loanId: string
      amount: number
      paymentDate: Date
      principalPaid: number
      interestPaid: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loanPayment"]>
    composites: {}
  }

  type LoanPaymentGetPayload<S extends boolean | null | undefined | LoanPaymentDefaultArgs> = $Result.GetResult<Prisma.$LoanPaymentPayload, S>

  type LoanPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoanPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoanPaymentCountAggregateInputType | true
    }

  export interface LoanPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanPayment'], meta: { name: 'LoanPayment' } }
    /**
     * Find zero or one LoanPayment that matches the filter.
     * @param {LoanPaymentFindUniqueArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanPaymentFindUniqueArgs>(args: SelectSubset<T, LoanPaymentFindUniqueArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoanPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoanPaymentFindUniqueOrThrowArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoanPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanPaymentFindFirstArgs>(args?: SelectSubset<T, LoanPaymentFindFirstArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoanPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstOrThrowArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoanPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany()
     * 
     * // Get first 10 LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanPaymentFindManyArgs>(args?: SelectSubset<T, LoanPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoanPayment.
     * @param {LoanPaymentCreateArgs} args - Arguments to create a LoanPayment.
     * @example
     * // Create one LoanPayment
     * const LoanPayment = await prisma.loanPayment.create({
     *   data: {
     *     // ... data to create a LoanPayment
     *   }
     * })
     * 
     */
    create<T extends LoanPaymentCreateArgs>(args: SelectSubset<T, LoanPaymentCreateArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoanPayments.
     * @param {LoanPaymentCreateManyArgs} args - Arguments to create many LoanPayments.
     * @example
     * // Create many LoanPayments
     * const loanPayment = await prisma.loanPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanPaymentCreateManyArgs>(args?: SelectSubset<T, LoanPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanPayments and returns the data saved in the database.
     * @param {LoanPaymentCreateManyAndReturnArgs} args - Arguments to create many LoanPayments.
     * @example
     * // Create many LoanPayments
     * const loanPayment = await prisma.loanPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanPayments and only return the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoanPayment.
     * @param {LoanPaymentDeleteArgs} args - Arguments to delete one LoanPayment.
     * @example
     * // Delete one LoanPayment
     * const LoanPayment = await prisma.loanPayment.delete({
     *   where: {
     *     // ... filter to delete one LoanPayment
     *   }
     * })
     * 
     */
    delete<T extends LoanPaymentDeleteArgs>(args: SelectSubset<T, LoanPaymentDeleteArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoanPayment.
     * @param {LoanPaymentUpdateArgs} args - Arguments to update one LoanPayment.
     * @example
     * // Update one LoanPayment
     * const loanPayment = await prisma.loanPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanPaymentUpdateArgs>(args: SelectSubset<T, LoanPaymentUpdateArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoanPayments.
     * @param {LoanPaymentDeleteManyArgs} args - Arguments to filter LoanPayments to delete.
     * @example
     * // Delete a few LoanPayments
     * const { count } = await prisma.loanPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanPaymentDeleteManyArgs>(args?: SelectSubset<T, LoanPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanPayments
     * const loanPayment = await prisma.loanPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanPaymentUpdateManyArgs>(args: SelectSubset<T, LoanPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoanPayment.
     * @param {LoanPaymentUpsertArgs} args - Arguments to update or create a LoanPayment.
     * @example
     * // Update or create a LoanPayment
     * const loanPayment = await prisma.loanPayment.upsert({
     *   create: {
     *     // ... data to create a LoanPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanPayment we want to update
     *   }
     * })
     */
    upsert<T extends LoanPaymentUpsertArgs>(args: SelectSubset<T, LoanPaymentUpsertArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentCountArgs} args - Arguments to filter LoanPayments to count.
     * @example
     * // Count the number of LoanPayments
     * const count = await prisma.loanPayment.count({
     *   where: {
     *     // ... the filter for the LoanPayments we want to count
     *   }
     * })
    **/
    count<T extends LoanPaymentCountArgs>(
      args?: Subset<T, LoanPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanPaymentAggregateArgs>(args: Subset<T, LoanPaymentAggregateArgs>): Prisma.PrismaPromise<GetLoanPaymentAggregateType<T>>

    /**
     * Group by LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanPaymentGroupByArgs['orderBy'] }
        : { orderBy?: LoanPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanPayment model
   */
  readonly fields: LoanPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loans<T extends LoanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanDefaultArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanPayment model
   */ 
  interface LoanPaymentFieldRefs {
    readonly id: FieldRef<"LoanPayment", 'String'>
    readonly loanId: FieldRef<"LoanPayment", 'String'>
    readonly amount: FieldRef<"LoanPayment", 'Float'>
    readonly paymentDate: FieldRef<"LoanPayment", 'DateTime'>
    readonly principalPaid: FieldRef<"LoanPayment", 'Float'>
    readonly interestPaid: FieldRef<"LoanPayment", 'Float'>
    readonly createdAt: FieldRef<"LoanPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"LoanPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanPayment findUnique
   */
  export type LoanPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment findUniqueOrThrow
   */
  export type LoanPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment findFirst
   */
  export type LoanPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     */
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment findFirstOrThrow
   */
  export type LoanPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     */
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment findMany
   */
  export type LoanPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayments to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment create
   */
  export type LoanPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanPayment.
     */
    data: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
  }

  /**
   * LoanPayment createMany
   */
  export type LoanPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanPayments.
     */
    data: LoanPaymentCreateManyInput | LoanPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanPayment createManyAndReturn
   */
  export type LoanPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoanPayments.
     */
    data: LoanPaymentCreateManyInput | LoanPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanPayment update
   */
  export type LoanPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanPayment.
     */
    data: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
    /**
     * Choose, which LoanPayment to update.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment updateMany
   */
  export type LoanPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanPayments.
     */
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyInput>
    /**
     * Filter which LoanPayments to update
     */
    where?: LoanPaymentWhereInput
  }

  /**
   * LoanPayment upsert
   */
  export type LoanPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanPayment to update in case it exists.
     */
    where: LoanPaymentWhereUniqueInput
    /**
     * In case the LoanPayment found by the `where` argument doesn't exist, create a new LoanPayment with this data.
     */
    create: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
    /**
     * In case the LoanPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
  }

  /**
   * LoanPayment delete
   */
  export type LoanPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter which LoanPayment to delete.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment deleteMany
   */
  export type LoanPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanPayments to delete
     */
    where?: LoanPaymentWhereInput
  }

  /**
   * LoanPayment without action
   */
  export type LoanPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Loan
   */

  export type AggregateLoan = {
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  export type LoanAvgAggregateOutputType = {
    principalAmount: number | null
    interestRate: number | null
    termMonths: number | null
    monthlyPayment: number | null
    remainingBalance: number | null
  }

  export type LoanSumAggregateOutputType = {
    principalAmount: number | null
    interestRate: number | null
    termMonths: number | null
    monthlyPayment: number | null
    remainingBalance: number | null
  }

  export type LoanMinAggregateOutputType = {
    id: string | null
    bankAccountId: string | null
    principalAmount: number | null
    interestRate: number | null
    termMonths: number | null
    monthlyPayment: number | null
    remainingBalance: number | null
    status: string | null
    loanPurpose: string | null
    nextPaymentDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanMaxAggregateOutputType = {
    id: string | null
    bankAccountId: string | null
    principalAmount: number | null
    interestRate: number | null
    termMonths: number | null
    monthlyPayment: number | null
    remainingBalance: number | null
    status: string | null
    loanPurpose: string | null
    nextPaymentDue: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanCountAggregateOutputType = {
    id: number
    bankAccountId: number
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status: number
    loanPurpose: number
    nextPaymentDue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanAvgAggregateInputType = {
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    remainingBalance?: true
  }

  export type LoanSumAggregateInputType = {
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    remainingBalance?: true
  }

  export type LoanMinAggregateInputType = {
    id?: true
    bankAccountId?: true
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    remainingBalance?: true
    status?: true
    loanPurpose?: true
    nextPaymentDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanMaxAggregateInputType = {
    id?: true
    bankAccountId?: true
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    remainingBalance?: true
    status?: true
    loanPurpose?: true
    nextPaymentDue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanCountAggregateInputType = {
    id?: true
    bankAccountId?: true
    principalAmount?: true
    interestRate?: true
    termMonths?: true
    monthlyPayment?: true
    remainingBalance?: true
    status?: true
    loanPurpose?: true
    nextPaymentDue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loan to aggregate.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loans
    **/
    _count?: true | LoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanMaxAggregateInputType
  }

  export type GetLoanAggregateType<T extends LoanAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan[P]>
      : GetScalarType<T[P], AggregateLoan[P]>
  }




  export type LoanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
    orderBy?: LoanOrderByWithAggregationInput | LoanOrderByWithAggregationInput[]
    by: LoanScalarFieldEnum[] | LoanScalarFieldEnum
    having?: LoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanCountAggregateInputType | true
    _avg?: LoanAvgAggregateInputType
    _sum?: LoanSumAggregateInputType
    _min?: LoanMinAggregateInputType
    _max?: LoanMaxAggregateInputType
  }

  export type LoanGroupByOutputType = {
    id: string
    bankAccountId: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status: string
    loanPurpose: string
    nextPaymentDue: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  type GetLoanGroupByPayload<T extends LoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanGroupByOutputType[P]>
            : GetScalarType<T[P], LoanGroupByOutputType[P]>
        }
      >
    >


  export type LoanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    principalAmount?: boolean
    interestRate?: boolean
    termMonths?: boolean
    monthlyPayment?: boolean
    remainingBalance?: boolean
    status?: boolean
    loanPurpose?: boolean
    nextPaymentDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loanPayments?: boolean | Loan$loanPaymentsArgs<ExtArgs>
    bankAccounts?: boolean | BankAccountDefaultArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankAccountId?: boolean
    principalAmount?: boolean
    interestRate?: boolean
    termMonths?: boolean
    monthlyPayment?: boolean
    remainingBalance?: boolean
    status?: boolean
    loanPurpose?: boolean
    nextPaymentDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bankAccounts?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectScalar = {
    id?: boolean
    bankAccountId?: boolean
    principalAmount?: boolean
    interestRate?: boolean
    termMonths?: boolean
    monthlyPayment?: boolean
    remainingBalance?: boolean
    status?: boolean
    loanPurpose?: boolean
    nextPaymentDue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loanPayments?: boolean | Loan$loanPaymentsArgs<ExtArgs>
    bankAccounts?: boolean | BankAccountDefaultArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bankAccounts?: boolean | BankAccountDefaultArgs<ExtArgs>
  }

  export type $LoanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loan"
    objects: {
      loanPayments: Prisma.$LoanPaymentPayload<ExtArgs>[]
      bankAccounts: Prisma.$BankAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankAccountId: string
      principalAmount: number
      interestRate: number
      termMonths: number
      monthlyPayment: number
      remainingBalance: number
      status: string
      loanPurpose: string
      nextPaymentDue: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loan"]>
    composites: {}
  }

  type LoanGetPayload<S extends boolean | null | undefined | LoanDefaultArgs> = $Result.GetResult<Prisma.$LoanPayload, S>

  type LoanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoanCountAggregateInputType | true
    }

  export interface LoanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loan'], meta: { name: 'Loan' } }
    /**
     * Find zero or one Loan that matches the filter.
     * @param {LoanFindUniqueArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanFindUniqueArgs>(args: SelectSubset<T, LoanFindUniqueArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Loan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoanFindUniqueOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Loan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanFindFirstArgs>(args?: SelectSubset<T, LoanFindFirstArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Loan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loan.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanWithIdOnly = await prisma.loan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanFindManyArgs>(args?: SelectSubset<T, LoanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Loan.
     * @param {LoanCreateArgs} args - Arguments to create a Loan.
     * @example
     * // Create one Loan
     * const Loan = await prisma.loan.create({
     *   data: {
     *     // ... data to create a Loan
     *   }
     * })
     * 
     */
    create<T extends LoanCreateArgs>(args: SelectSubset<T, LoanCreateArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Loans.
     * @param {LoanCreateManyArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loan = await prisma.loan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanCreateManyArgs>(args?: SelectSubset<T, LoanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loans and returns the data saved in the database.
     * @param {LoanCreateManyAndReturnArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loan = await prisma.loan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loans and only return the `id`
     * const loanWithIdOnly = await prisma.loan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Loan.
     * @param {LoanDeleteArgs} args - Arguments to delete one Loan.
     * @example
     * // Delete one Loan
     * const Loan = await prisma.loan.delete({
     *   where: {
     *     // ... filter to delete one Loan
     *   }
     * })
     * 
     */
    delete<T extends LoanDeleteArgs>(args: SelectSubset<T, LoanDeleteArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Loan.
     * @param {LoanUpdateArgs} args - Arguments to update one Loan.
     * @example
     * // Update one Loan
     * const loan = await prisma.loan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanUpdateArgs>(args: SelectSubset<T, LoanUpdateArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Loans.
     * @param {LoanDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanDeleteManyArgs>(args?: SelectSubset<T, LoanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loan = await prisma.loan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanUpdateManyArgs>(args: SelectSubset<T, LoanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loan.
     * @param {LoanUpsertArgs} args - Arguments to update or create a Loan.
     * @example
     * // Update or create a Loan
     * const loan = await prisma.loan.upsert({
     *   create: {
     *     // ... data to create a Loan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan we want to update
     *   }
     * })
     */
    upsert<T extends LoanUpsertArgs>(args: SelectSubset<T, LoanUpsertArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loan.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends LoanCountArgs>(
      args?: Subset<T, LoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanAggregateArgs>(args: Subset<T, LoanAggregateArgs>): Prisma.PrismaPromise<GetLoanAggregateType<T>>

    /**
     * Group by Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanGroupByArgs['orderBy'] }
        : { orderBy?: LoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loan model
   */
  readonly fields: LoanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loanPayments<T extends Loan$loanPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Loan$loanPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    bankAccounts<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loan model
   */ 
  interface LoanFieldRefs {
    readonly id: FieldRef<"Loan", 'String'>
    readonly bankAccountId: FieldRef<"Loan", 'String'>
    readonly principalAmount: FieldRef<"Loan", 'Float'>
    readonly interestRate: FieldRef<"Loan", 'Float'>
    readonly termMonths: FieldRef<"Loan", 'Int'>
    readonly monthlyPayment: FieldRef<"Loan", 'Float'>
    readonly remainingBalance: FieldRef<"Loan", 'Float'>
    readonly status: FieldRef<"Loan", 'String'>
    readonly loanPurpose: FieldRef<"Loan", 'String'>
    readonly nextPaymentDue: FieldRef<"Loan", 'DateTime'>
    readonly createdAt: FieldRef<"Loan", 'DateTime'>
    readonly updatedAt: FieldRef<"Loan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Loan findUnique
   */
  export type LoanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findUniqueOrThrow
   */
  export type LoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findFirst
   */
  export type LoanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan findFirstOrThrow
   */
  export type LoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan findMany
   */
  export type LoanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan create
   */
  export type LoanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to create a Loan.
     */
    data: XOR<LoanCreateInput, LoanUncheckedCreateInput>
  }

  /**
   * Loan createMany
   */
  export type LoanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loans.
     */
    data: LoanCreateManyInput | LoanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loan createManyAndReturn
   */
  export type LoanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Loans.
     */
    data: LoanCreateManyInput | LoanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loan update
   */
  export type LoanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to update a Loan.
     */
    data: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
    /**
     * Choose, which Loan to update.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan updateMany
   */
  export type LoanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loans.
     */
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoanWhereInput
  }

  /**
   * Loan upsert
   */
  export type LoanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The filter to search for the Loan to update in case it exists.
     */
    where: LoanWhereUniqueInput
    /**
     * In case the Loan found by the `where` argument doesn't exist, create a new Loan with this data.
     */
    create: XOR<LoanCreateInput, LoanUncheckedCreateInput>
    /**
     * In case the Loan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
  }

  /**
   * Loan delete
   */
  export type LoanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter which Loan to delete.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan deleteMany
   */
  export type LoanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loans to delete
     */
    where?: LoanWhereInput
  }

  /**
   * Loan.loanPayments
   */
  export type Loan$loanPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    cursor?: LoanPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * Loan without action
   */
  export type LoanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
  }


  /**
   * Model LogisticsTracking
   */

  export type AggregateLogisticsTracking = {
    _count: LogisticsTrackingCountAggregateOutputType | null
    _avg: LogisticsTrackingAvgAggregateOutputType | null
    _sum: LogisticsTrackingSumAggregateOutputType | null
    _min: LogisticsTrackingMinAggregateOutputType | null
    _max: LogisticsTrackingMaxAggregateOutputType | null
  }

  export type LogisticsTrackingAvgAggregateOutputType = {
    quantity: number | null
    weight: number | null
  }

  export type LogisticsTrackingSumAggregateOutputType = {
    quantity: number | null
    weight: number | null
  }

  export type LogisticsTrackingMinAggregateOutputType = {
    id: string | null
    trackingNumber: string | null
    deliveryQuestId: string | null
    routeId: string | null
    itemId: string | null
    quantity: number | null
    weight: number | null
    status: string | null
    currentLocation: string | null
    scheduledPickup: Date | null
    actualPickup: Date | null
    scheduledDelivery: Date | null
    actualDelivery: Date | null
    handlerType: string | null
    handlerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogisticsTrackingMaxAggregateOutputType = {
    id: string | null
    trackingNumber: string | null
    deliveryQuestId: string | null
    routeId: string | null
    itemId: string | null
    quantity: number | null
    weight: number | null
    status: string | null
    currentLocation: string | null
    scheduledPickup: Date | null
    actualPickup: Date | null
    scheduledDelivery: Date | null
    actualDelivery: Date | null
    handlerType: string | null
    handlerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogisticsTrackingCountAggregateOutputType = {
    id: number
    trackingNumber: number
    deliveryQuestId: number
    routeId: number
    itemId: number
    quantity: number
    weight: number
    status: number
    currentLocation: number
    scheduledPickup: number
    actualPickup: number
    scheduledDelivery: number
    actualDelivery: number
    handlerType: number
    handlerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LogisticsTrackingAvgAggregateInputType = {
    quantity?: true
    weight?: true
  }

  export type LogisticsTrackingSumAggregateInputType = {
    quantity?: true
    weight?: true
  }

  export type LogisticsTrackingMinAggregateInputType = {
    id?: true
    trackingNumber?: true
    deliveryQuestId?: true
    routeId?: true
    itemId?: true
    quantity?: true
    weight?: true
    status?: true
    currentLocation?: true
    scheduledPickup?: true
    actualPickup?: true
    scheduledDelivery?: true
    actualDelivery?: true
    handlerType?: true
    handlerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogisticsTrackingMaxAggregateInputType = {
    id?: true
    trackingNumber?: true
    deliveryQuestId?: true
    routeId?: true
    itemId?: true
    quantity?: true
    weight?: true
    status?: true
    currentLocation?: true
    scheduledPickup?: true
    actualPickup?: true
    scheduledDelivery?: true
    actualDelivery?: true
    handlerType?: true
    handlerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogisticsTrackingCountAggregateInputType = {
    id?: true
    trackingNumber?: true
    deliveryQuestId?: true
    routeId?: true
    itemId?: true
    quantity?: true
    weight?: true
    status?: true
    currentLocation?: true
    scheduledPickup?: true
    actualPickup?: true
    scheduledDelivery?: true
    actualDelivery?: true
    handlerType?: true
    handlerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LogisticsTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogisticsTracking to aggregate.
     */
    where?: LogisticsTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogisticsTrackings to fetch.
     */
    orderBy?: LogisticsTrackingOrderByWithRelationInput | LogisticsTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogisticsTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogisticsTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogisticsTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogisticsTrackings
    **/
    _count?: true | LogisticsTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogisticsTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogisticsTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogisticsTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogisticsTrackingMaxAggregateInputType
  }

  export type GetLogisticsTrackingAggregateType<T extends LogisticsTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateLogisticsTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogisticsTracking[P]>
      : GetScalarType<T[P], AggregateLogisticsTracking[P]>
  }




  export type LogisticsTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogisticsTrackingWhereInput
    orderBy?: LogisticsTrackingOrderByWithAggregationInput | LogisticsTrackingOrderByWithAggregationInput[]
    by: LogisticsTrackingScalarFieldEnum[] | LogisticsTrackingScalarFieldEnum
    having?: LogisticsTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogisticsTrackingCountAggregateInputType | true
    _avg?: LogisticsTrackingAvgAggregateInputType
    _sum?: LogisticsTrackingSumAggregateInputType
    _min?: LogisticsTrackingMinAggregateInputType
    _max?: LogisticsTrackingMaxAggregateInputType
  }

  export type LogisticsTrackingGroupByOutputType = {
    id: string
    trackingNumber: string
    deliveryQuestId: string | null
    routeId: string | null
    itemId: string
    quantity: number
    weight: number
    status: string
    currentLocation: string
    scheduledPickup: Date
    actualPickup: Date | null
    scheduledDelivery: Date
    actualDelivery: Date | null
    handlerType: string
    handlerId: string
    createdAt: Date
    updatedAt: Date
    _count: LogisticsTrackingCountAggregateOutputType | null
    _avg: LogisticsTrackingAvgAggregateOutputType | null
    _sum: LogisticsTrackingSumAggregateOutputType | null
    _min: LogisticsTrackingMinAggregateOutputType | null
    _max: LogisticsTrackingMaxAggregateOutputType | null
  }

  type GetLogisticsTrackingGroupByPayload<T extends LogisticsTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogisticsTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogisticsTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogisticsTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], LogisticsTrackingGroupByOutputType[P]>
        }
      >
    >


  export type LogisticsTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    deliveryQuestId?: boolean
    routeId?: boolean
    itemId?: boolean
    quantity?: boolean
    weight?: boolean
    status?: boolean
    currentLocation?: boolean
    scheduledPickup?: boolean
    actualPickup?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    handlerType?: boolean
    handlerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logisticsTracking"]>

  export type LogisticsTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingNumber?: boolean
    deliveryQuestId?: boolean
    routeId?: boolean
    itemId?: boolean
    quantity?: boolean
    weight?: boolean
    status?: boolean
    currentLocation?: boolean
    scheduledPickup?: boolean
    actualPickup?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    handlerType?: boolean
    handlerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["logisticsTracking"]>

  export type LogisticsTrackingSelectScalar = {
    id?: boolean
    trackingNumber?: boolean
    deliveryQuestId?: boolean
    routeId?: boolean
    itemId?: boolean
    quantity?: boolean
    weight?: boolean
    status?: boolean
    currentLocation?: boolean
    scheduledPickup?: boolean
    actualPickup?: boolean
    scheduledDelivery?: boolean
    actualDelivery?: boolean
    handlerType?: boolean
    handlerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $LogisticsTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogisticsTracking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trackingNumber: string
      deliveryQuestId: string | null
      routeId: string | null
      itemId: string
      quantity: number
      weight: number
      status: string
      currentLocation: string
      scheduledPickup: Date
      actualPickup: Date | null
      scheduledDelivery: Date
      actualDelivery: Date | null
      handlerType: string
      handlerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["logisticsTracking"]>
    composites: {}
  }

  type LogisticsTrackingGetPayload<S extends boolean | null | undefined | LogisticsTrackingDefaultArgs> = $Result.GetResult<Prisma.$LogisticsTrackingPayload, S>

  type LogisticsTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogisticsTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogisticsTrackingCountAggregateInputType | true
    }

  export interface LogisticsTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogisticsTracking'], meta: { name: 'LogisticsTracking' } }
    /**
     * Find zero or one LogisticsTracking that matches the filter.
     * @param {LogisticsTrackingFindUniqueArgs} args - Arguments to find a LogisticsTracking
     * @example
     * // Get one LogisticsTracking
     * const logisticsTracking = await prisma.logisticsTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogisticsTrackingFindUniqueArgs>(args: SelectSubset<T, LogisticsTrackingFindUniqueArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogisticsTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogisticsTrackingFindUniqueOrThrowArgs} args - Arguments to find a LogisticsTracking
     * @example
     * // Get one LogisticsTracking
     * const logisticsTracking = await prisma.logisticsTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogisticsTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, LogisticsTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogisticsTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingFindFirstArgs} args - Arguments to find a LogisticsTracking
     * @example
     * // Get one LogisticsTracking
     * const logisticsTracking = await prisma.logisticsTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogisticsTrackingFindFirstArgs>(args?: SelectSubset<T, LogisticsTrackingFindFirstArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogisticsTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingFindFirstOrThrowArgs} args - Arguments to find a LogisticsTracking
     * @example
     * // Get one LogisticsTracking
     * const logisticsTracking = await prisma.logisticsTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogisticsTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, LogisticsTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogisticsTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogisticsTrackings
     * const logisticsTrackings = await prisma.logisticsTracking.findMany()
     * 
     * // Get first 10 LogisticsTrackings
     * const logisticsTrackings = await prisma.logisticsTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logisticsTrackingWithIdOnly = await prisma.logisticsTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogisticsTrackingFindManyArgs>(args?: SelectSubset<T, LogisticsTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogisticsTracking.
     * @param {LogisticsTrackingCreateArgs} args - Arguments to create a LogisticsTracking.
     * @example
     * // Create one LogisticsTracking
     * const LogisticsTracking = await prisma.logisticsTracking.create({
     *   data: {
     *     // ... data to create a LogisticsTracking
     *   }
     * })
     * 
     */
    create<T extends LogisticsTrackingCreateArgs>(args: SelectSubset<T, LogisticsTrackingCreateArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogisticsTrackings.
     * @param {LogisticsTrackingCreateManyArgs} args - Arguments to create many LogisticsTrackings.
     * @example
     * // Create many LogisticsTrackings
     * const logisticsTracking = await prisma.logisticsTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogisticsTrackingCreateManyArgs>(args?: SelectSubset<T, LogisticsTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogisticsTrackings and returns the data saved in the database.
     * @param {LogisticsTrackingCreateManyAndReturnArgs} args - Arguments to create many LogisticsTrackings.
     * @example
     * // Create many LogisticsTrackings
     * const logisticsTracking = await prisma.logisticsTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogisticsTrackings and only return the `id`
     * const logisticsTrackingWithIdOnly = await prisma.logisticsTracking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogisticsTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, LogisticsTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogisticsTracking.
     * @param {LogisticsTrackingDeleteArgs} args - Arguments to delete one LogisticsTracking.
     * @example
     * // Delete one LogisticsTracking
     * const LogisticsTracking = await prisma.logisticsTracking.delete({
     *   where: {
     *     // ... filter to delete one LogisticsTracking
     *   }
     * })
     * 
     */
    delete<T extends LogisticsTrackingDeleteArgs>(args: SelectSubset<T, LogisticsTrackingDeleteArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogisticsTracking.
     * @param {LogisticsTrackingUpdateArgs} args - Arguments to update one LogisticsTracking.
     * @example
     * // Update one LogisticsTracking
     * const logisticsTracking = await prisma.logisticsTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogisticsTrackingUpdateArgs>(args: SelectSubset<T, LogisticsTrackingUpdateArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogisticsTrackings.
     * @param {LogisticsTrackingDeleteManyArgs} args - Arguments to filter LogisticsTrackings to delete.
     * @example
     * // Delete a few LogisticsTrackings
     * const { count } = await prisma.logisticsTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogisticsTrackingDeleteManyArgs>(args?: SelectSubset<T, LogisticsTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogisticsTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogisticsTrackings
     * const logisticsTracking = await prisma.logisticsTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogisticsTrackingUpdateManyArgs>(args: SelectSubset<T, LogisticsTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogisticsTracking.
     * @param {LogisticsTrackingUpsertArgs} args - Arguments to update or create a LogisticsTracking.
     * @example
     * // Update or create a LogisticsTracking
     * const logisticsTracking = await prisma.logisticsTracking.upsert({
     *   create: {
     *     // ... data to create a LogisticsTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogisticsTracking we want to update
     *   }
     * })
     */
    upsert<T extends LogisticsTrackingUpsertArgs>(args: SelectSubset<T, LogisticsTrackingUpsertArgs<ExtArgs>>): Prisma__LogisticsTrackingClient<$Result.GetResult<Prisma.$LogisticsTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogisticsTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingCountArgs} args - Arguments to filter LogisticsTrackings to count.
     * @example
     * // Count the number of LogisticsTrackings
     * const count = await prisma.logisticsTracking.count({
     *   where: {
     *     // ... the filter for the LogisticsTrackings we want to count
     *   }
     * })
    **/
    count<T extends LogisticsTrackingCountArgs>(
      args?: Subset<T, LogisticsTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogisticsTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogisticsTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogisticsTrackingAggregateArgs>(args: Subset<T, LogisticsTrackingAggregateArgs>): Prisma.PrismaPromise<GetLogisticsTrackingAggregateType<T>>

    /**
     * Group by LogisticsTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticsTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogisticsTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogisticsTrackingGroupByArgs['orderBy'] }
        : { orderBy?: LogisticsTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogisticsTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogisticsTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogisticsTracking model
   */
  readonly fields: LogisticsTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogisticsTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogisticsTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogisticsTracking model
   */ 
  interface LogisticsTrackingFieldRefs {
    readonly id: FieldRef<"LogisticsTracking", 'String'>
    readonly trackingNumber: FieldRef<"LogisticsTracking", 'String'>
    readonly deliveryQuestId: FieldRef<"LogisticsTracking", 'String'>
    readonly routeId: FieldRef<"LogisticsTracking", 'String'>
    readonly itemId: FieldRef<"LogisticsTracking", 'String'>
    readonly quantity: FieldRef<"LogisticsTracking", 'Int'>
    readonly weight: FieldRef<"LogisticsTracking", 'Float'>
    readonly status: FieldRef<"LogisticsTracking", 'String'>
    readonly currentLocation: FieldRef<"LogisticsTracking", 'String'>
    readonly scheduledPickup: FieldRef<"LogisticsTracking", 'DateTime'>
    readonly actualPickup: FieldRef<"LogisticsTracking", 'DateTime'>
    readonly scheduledDelivery: FieldRef<"LogisticsTracking", 'DateTime'>
    readonly actualDelivery: FieldRef<"LogisticsTracking", 'DateTime'>
    readonly handlerType: FieldRef<"LogisticsTracking", 'String'>
    readonly handlerId: FieldRef<"LogisticsTracking", 'String'>
    readonly createdAt: FieldRef<"LogisticsTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"LogisticsTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogisticsTracking findUnique
   */
  export type LogisticsTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * Filter, which LogisticsTracking to fetch.
     */
    where: LogisticsTrackingWhereUniqueInput
  }

  /**
   * LogisticsTracking findUniqueOrThrow
   */
  export type LogisticsTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * Filter, which LogisticsTracking to fetch.
     */
    where: LogisticsTrackingWhereUniqueInput
  }

  /**
   * LogisticsTracking findFirst
   */
  export type LogisticsTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * Filter, which LogisticsTracking to fetch.
     */
    where?: LogisticsTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogisticsTrackings to fetch.
     */
    orderBy?: LogisticsTrackingOrderByWithRelationInput | LogisticsTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogisticsTrackings.
     */
    cursor?: LogisticsTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogisticsTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogisticsTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogisticsTrackings.
     */
    distinct?: LogisticsTrackingScalarFieldEnum | LogisticsTrackingScalarFieldEnum[]
  }

  /**
   * LogisticsTracking findFirstOrThrow
   */
  export type LogisticsTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * Filter, which LogisticsTracking to fetch.
     */
    where?: LogisticsTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogisticsTrackings to fetch.
     */
    orderBy?: LogisticsTrackingOrderByWithRelationInput | LogisticsTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogisticsTrackings.
     */
    cursor?: LogisticsTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogisticsTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogisticsTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogisticsTrackings.
     */
    distinct?: LogisticsTrackingScalarFieldEnum | LogisticsTrackingScalarFieldEnum[]
  }

  /**
   * LogisticsTracking findMany
   */
  export type LogisticsTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * Filter, which LogisticsTrackings to fetch.
     */
    where?: LogisticsTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogisticsTrackings to fetch.
     */
    orderBy?: LogisticsTrackingOrderByWithRelationInput | LogisticsTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogisticsTrackings.
     */
    cursor?: LogisticsTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogisticsTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogisticsTrackings.
     */
    skip?: number
    distinct?: LogisticsTrackingScalarFieldEnum | LogisticsTrackingScalarFieldEnum[]
  }

  /**
   * LogisticsTracking create
   */
  export type LogisticsTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * The data needed to create a LogisticsTracking.
     */
    data: XOR<LogisticsTrackingCreateInput, LogisticsTrackingUncheckedCreateInput>
  }

  /**
   * LogisticsTracking createMany
   */
  export type LogisticsTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogisticsTrackings.
     */
    data: LogisticsTrackingCreateManyInput | LogisticsTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogisticsTracking createManyAndReturn
   */
  export type LogisticsTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogisticsTrackings.
     */
    data: LogisticsTrackingCreateManyInput | LogisticsTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogisticsTracking update
   */
  export type LogisticsTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * The data needed to update a LogisticsTracking.
     */
    data: XOR<LogisticsTrackingUpdateInput, LogisticsTrackingUncheckedUpdateInput>
    /**
     * Choose, which LogisticsTracking to update.
     */
    where: LogisticsTrackingWhereUniqueInput
  }

  /**
   * LogisticsTracking updateMany
   */
  export type LogisticsTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogisticsTrackings.
     */
    data: XOR<LogisticsTrackingUpdateManyMutationInput, LogisticsTrackingUncheckedUpdateManyInput>
    /**
     * Filter which LogisticsTrackings to update
     */
    where?: LogisticsTrackingWhereInput
  }

  /**
   * LogisticsTracking upsert
   */
  export type LogisticsTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * The filter to search for the LogisticsTracking to update in case it exists.
     */
    where: LogisticsTrackingWhereUniqueInput
    /**
     * In case the LogisticsTracking found by the `where` argument doesn't exist, create a new LogisticsTracking with this data.
     */
    create: XOR<LogisticsTrackingCreateInput, LogisticsTrackingUncheckedCreateInput>
    /**
     * In case the LogisticsTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogisticsTrackingUpdateInput, LogisticsTrackingUncheckedUpdateInput>
  }

  /**
   * LogisticsTracking delete
   */
  export type LogisticsTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
    /**
     * Filter which LogisticsTracking to delete.
     */
    where: LogisticsTrackingWhereUniqueInput
  }

  /**
   * LogisticsTracking deleteMany
   */
  export type LogisticsTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogisticsTrackings to delete
     */
    where?: LogisticsTrackingWhereInput
  }

  /**
   * LogisticsTracking without action
   */
  export type LogisticsTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticsTracking
     */
    select?: LogisticsTrackingSelect<ExtArgs> | null
  }


  /**
   * Model MagicalStorage
   */

  export type AggregateMagicalStorage = {
    _count: MagicalStorageCountAggregateOutputType | null
    _avg: MagicalStorageAvgAggregateOutputType | null
    _sum: MagicalStorageSumAggregateOutputType | null
    _min: MagicalStorageMinAggregateOutputType | null
    _max: MagicalStorageMaxAggregateOutputType | null
  }

  export type MagicalStorageAvgAggregateOutputType = {
    quantity: number | null
    manaUsed: number | null
  }

  export type MagicalStorageSumAggregateOutputType = {
    quantity: number | null
    manaUsed: number | null
  }

  export type MagicalStorageMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    itemId: string | null
    quantity: number | null
    quality: string | null
    manaUsed: number | null
    storedAt: Date | null
    lastAccessedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MagicalStorageMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    itemId: string | null
    quantity: number | null
    quality: string | null
    manaUsed: number | null
    storedAt: Date | null
    lastAccessedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MagicalStorageCountAggregateOutputType = {
    id: number
    characterId: number
    itemId: number
    quantity: number
    quality: number
    manaUsed: number
    storedAt: number
    lastAccessedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MagicalStorageAvgAggregateInputType = {
    quantity?: true
    manaUsed?: true
  }

  export type MagicalStorageSumAggregateInputType = {
    quantity?: true
    manaUsed?: true
  }

  export type MagicalStorageMinAggregateInputType = {
    id?: true
    characterId?: true
    itemId?: true
    quantity?: true
    quality?: true
    manaUsed?: true
    storedAt?: true
    lastAccessedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MagicalStorageMaxAggregateInputType = {
    id?: true
    characterId?: true
    itemId?: true
    quantity?: true
    quality?: true
    manaUsed?: true
    storedAt?: true
    lastAccessedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MagicalStorageCountAggregateInputType = {
    id?: true
    characterId?: true
    itemId?: true
    quantity?: true
    quality?: true
    manaUsed?: true
    storedAt?: true
    lastAccessedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MagicalStorageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicalStorage to aggregate.
     */
    where?: MagicalStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicalStorages to fetch.
     */
    orderBy?: MagicalStorageOrderByWithRelationInput | MagicalStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicalStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicalStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicalStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicalStorages
    **/
    _count?: true | MagicalStorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagicalStorageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagicalStorageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicalStorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicalStorageMaxAggregateInputType
  }

  export type GetMagicalStorageAggregateType<T extends MagicalStorageAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicalStorage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicalStorage[P]>
      : GetScalarType<T[P], AggregateMagicalStorage[P]>
  }




  export type MagicalStorageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicalStorageWhereInput
    orderBy?: MagicalStorageOrderByWithAggregationInput | MagicalStorageOrderByWithAggregationInput[]
    by: MagicalStorageScalarFieldEnum[] | MagicalStorageScalarFieldEnum
    having?: MagicalStorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicalStorageCountAggregateInputType | true
    _avg?: MagicalStorageAvgAggregateInputType
    _sum?: MagicalStorageSumAggregateInputType
    _min?: MagicalStorageMinAggregateInputType
    _max?: MagicalStorageMaxAggregateInputType
  }

  export type MagicalStorageGroupByOutputType = {
    id: string
    characterId: string
    itemId: string
    quantity: number
    quality: string
    manaUsed: number
    storedAt: Date
    lastAccessedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MagicalStorageCountAggregateOutputType | null
    _avg: MagicalStorageAvgAggregateOutputType | null
    _sum: MagicalStorageSumAggregateOutputType | null
    _min: MagicalStorageMinAggregateOutputType | null
    _max: MagicalStorageMaxAggregateOutputType | null
  }

  type GetMagicalStorageGroupByPayload<T extends MagicalStorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicalStorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicalStorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicalStorageGroupByOutputType[P]>
            : GetScalarType<T[P], MagicalStorageGroupByOutputType[P]>
        }
      >
    >


  export type MagicalStorageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    itemId?: boolean
    quantity?: boolean
    quality?: boolean
    manaUsed?: boolean
    storedAt?: boolean
    lastAccessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicalStorage"]>

  export type MagicalStorageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    itemId?: boolean
    quantity?: boolean
    quality?: boolean
    manaUsed?: boolean
    storedAt?: boolean
    lastAccessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicalStorage"]>

  export type MagicalStorageSelectScalar = {
    id?: boolean
    characterId?: boolean
    itemId?: boolean
    quantity?: boolean
    quality?: boolean
    manaUsed?: boolean
    storedAt?: boolean
    lastAccessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MagicalStorageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }
  export type MagicalStorageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gameCharacter?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }

  export type $MagicalStoragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicalStorage"
    objects: {
      gameCharacter: Prisma.$GameCharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      itemId: string
      quantity: number
      quality: string
      manaUsed: number
      storedAt: Date
      lastAccessedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["magicalStorage"]>
    composites: {}
  }

  type MagicalStorageGetPayload<S extends boolean | null | undefined | MagicalStorageDefaultArgs> = $Result.GetResult<Prisma.$MagicalStoragePayload, S>

  type MagicalStorageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MagicalStorageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MagicalStorageCountAggregateInputType | true
    }

  export interface MagicalStorageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicalStorage'], meta: { name: 'MagicalStorage' } }
    /**
     * Find zero or one MagicalStorage that matches the filter.
     * @param {MagicalStorageFindUniqueArgs} args - Arguments to find a MagicalStorage
     * @example
     * // Get one MagicalStorage
     * const magicalStorage = await prisma.magicalStorage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicalStorageFindUniqueArgs>(args: SelectSubset<T, MagicalStorageFindUniqueArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MagicalStorage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MagicalStorageFindUniqueOrThrowArgs} args - Arguments to find a MagicalStorage
     * @example
     * // Get one MagicalStorage
     * const magicalStorage = await prisma.magicalStorage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicalStorageFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicalStorageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MagicalStorage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageFindFirstArgs} args - Arguments to find a MagicalStorage
     * @example
     * // Get one MagicalStorage
     * const magicalStorage = await prisma.magicalStorage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicalStorageFindFirstArgs>(args?: SelectSubset<T, MagicalStorageFindFirstArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MagicalStorage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageFindFirstOrThrowArgs} args - Arguments to find a MagicalStorage
     * @example
     * // Get one MagicalStorage
     * const magicalStorage = await prisma.magicalStorage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicalStorageFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicalStorageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MagicalStorages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicalStorages
     * const magicalStorages = await prisma.magicalStorage.findMany()
     * 
     * // Get first 10 MagicalStorages
     * const magicalStorages = await prisma.magicalStorage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magicalStorageWithIdOnly = await prisma.magicalStorage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagicalStorageFindManyArgs>(args?: SelectSubset<T, MagicalStorageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MagicalStorage.
     * @param {MagicalStorageCreateArgs} args - Arguments to create a MagicalStorage.
     * @example
     * // Create one MagicalStorage
     * const MagicalStorage = await prisma.magicalStorage.create({
     *   data: {
     *     // ... data to create a MagicalStorage
     *   }
     * })
     * 
     */
    create<T extends MagicalStorageCreateArgs>(args: SelectSubset<T, MagicalStorageCreateArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MagicalStorages.
     * @param {MagicalStorageCreateManyArgs} args - Arguments to create many MagicalStorages.
     * @example
     * // Create many MagicalStorages
     * const magicalStorage = await prisma.magicalStorage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicalStorageCreateManyArgs>(args?: SelectSubset<T, MagicalStorageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicalStorages and returns the data saved in the database.
     * @param {MagicalStorageCreateManyAndReturnArgs} args - Arguments to create many MagicalStorages.
     * @example
     * // Create many MagicalStorages
     * const magicalStorage = await prisma.magicalStorage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicalStorages and only return the `id`
     * const magicalStorageWithIdOnly = await prisma.magicalStorage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicalStorageCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicalStorageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MagicalStorage.
     * @param {MagicalStorageDeleteArgs} args - Arguments to delete one MagicalStorage.
     * @example
     * // Delete one MagicalStorage
     * const MagicalStorage = await prisma.magicalStorage.delete({
     *   where: {
     *     // ... filter to delete one MagicalStorage
     *   }
     * })
     * 
     */
    delete<T extends MagicalStorageDeleteArgs>(args: SelectSubset<T, MagicalStorageDeleteArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MagicalStorage.
     * @param {MagicalStorageUpdateArgs} args - Arguments to update one MagicalStorage.
     * @example
     * // Update one MagicalStorage
     * const magicalStorage = await prisma.magicalStorage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicalStorageUpdateArgs>(args: SelectSubset<T, MagicalStorageUpdateArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MagicalStorages.
     * @param {MagicalStorageDeleteManyArgs} args - Arguments to filter MagicalStorages to delete.
     * @example
     * // Delete a few MagicalStorages
     * const { count } = await prisma.magicalStorage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicalStorageDeleteManyArgs>(args?: SelectSubset<T, MagicalStorageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicalStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicalStorages
     * const magicalStorage = await prisma.magicalStorage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicalStorageUpdateManyArgs>(args: SelectSubset<T, MagicalStorageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MagicalStorage.
     * @param {MagicalStorageUpsertArgs} args - Arguments to update or create a MagicalStorage.
     * @example
     * // Update or create a MagicalStorage
     * const magicalStorage = await prisma.magicalStorage.upsert({
     *   create: {
     *     // ... data to create a MagicalStorage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicalStorage we want to update
     *   }
     * })
     */
    upsert<T extends MagicalStorageUpsertArgs>(args: SelectSubset<T, MagicalStorageUpsertArgs<ExtArgs>>): Prisma__MagicalStorageClient<$Result.GetResult<Prisma.$MagicalStoragePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MagicalStorages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageCountArgs} args - Arguments to filter MagicalStorages to count.
     * @example
     * // Count the number of MagicalStorages
     * const count = await prisma.magicalStorage.count({
     *   where: {
     *     // ... the filter for the MagicalStorages we want to count
     *   }
     * })
    **/
    count<T extends MagicalStorageCountArgs>(
      args?: Subset<T, MagicalStorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicalStorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicalStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicalStorageAggregateArgs>(args: Subset<T, MagicalStorageAggregateArgs>): Prisma.PrismaPromise<GetMagicalStorageAggregateType<T>>

    /**
     * Group by MagicalStorage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicalStorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicalStorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicalStorageGroupByArgs['orderBy'] }
        : { orderBy?: MagicalStorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicalStorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicalStorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicalStorage model
   */
  readonly fields: MagicalStorageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicalStorage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicalStorageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gameCharacter<T extends GameCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacterDefaultArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicalStorage model
   */ 
  interface MagicalStorageFieldRefs {
    readonly id: FieldRef<"MagicalStorage", 'String'>
    readonly characterId: FieldRef<"MagicalStorage", 'String'>
    readonly itemId: FieldRef<"MagicalStorage", 'String'>
    readonly quantity: FieldRef<"MagicalStorage", 'Int'>
    readonly quality: FieldRef<"MagicalStorage", 'String'>
    readonly manaUsed: FieldRef<"MagicalStorage", 'Float'>
    readonly storedAt: FieldRef<"MagicalStorage", 'DateTime'>
    readonly lastAccessedAt: FieldRef<"MagicalStorage", 'DateTime'>
    readonly createdAt: FieldRef<"MagicalStorage", 'DateTime'>
    readonly updatedAt: FieldRef<"MagicalStorage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MagicalStorage findUnique
   */
  export type MagicalStorageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * Filter, which MagicalStorage to fetch.
     */
    where: MagicalStorageWhereUniqueInput
  }

  /**
   * MagicalStorage findUniqueOrThrow
   */
  export type MagicalStorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * Filter, which MagicalStorage to fetch.
     */
    where: MagicalStorageWhereUniqueInput
  }

  /**
   * MagicalStorage findFirst
   */
  export type MagicalStorageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * Filter, which MagicalStorage to fetch.
     */
    where?: MagicalStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicalStorages to fetch.
     */
    orderBy?: MagicalStorageOrderByWithRelationInput | MagicalStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicalStorages.
     */
    cursor?: MagicalStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicalStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicalStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicalStorages.
     */
    distinct?: MagicalStorageScalarFieldEnum | MagicalStorageScalarFieldEnum[]
  }

  /**
   * MagicalStorage findFirstOrThrow
   */
  export type MagicalStorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * Filter, which MagicalStorage to fetch.
     */
    where?: MagicalStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicalStorages to fetch.
     */
    orderBy?: MagicalStorageOrderByWithRelationInput | MagicalStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicalStorages.
     */
    cursor?: MagicalStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicalStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicalStorages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicalStorages.
     */
    distinct?: MagicalStorageScalarFieldEnum | MagicalStorageScalarFieldEnum[]
  }

  /**
   * MagicalStorage findMany
   */
  export type MagicalStorageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * Filter, which MagicalStorages to fetch.
     */
    where?: MagicalStorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicalStorages to fetch.
     */
    orderBy?: MagicalStorageOrderByWithRelationInput | MagicalStorageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicalStorages.
     */
    cursor?: MagicalStorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicalStorages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicalStorages.
     */
    skip?: number
    distinct?: MagicalStorageScalarFieldEnum | MagicalStorageScalarFieldEnum[]
  }

  /**
   * MagicalStorage create
   */
  export type MagicalStorageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicalStorage.
     */
    data: XOR<MagicalStorageCreateInput, MagicalStorageUncheckedCreateInput>
  }

  /**
   * MagicalStorage createMany
   */
  export type MagicalStorageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicalStorages.
     */
    data: MagicalStorageCreateManyInput | MagicalStorageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicalStorage createManyAndReturn
   */
  export type MagicalStorageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MagicalStorages.
     */
    data: MagicalStorageCreateManyInput | MagicalStorageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicalStorage update
   */
  export type MagicalStorageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicalStorage.
     */
    data: XOR<MagicalStorageUpdateInput, MagicalStorageUncheckedUpdateInput>
    /**
     * Choose, which MagicalStorage to update.
     */
    where: MagicalStorageWhereUniqueInput
  }

  /**
   * MagicalStorage updateMany
   */
  export type MagicalStorageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicalStorages.
     */
    data: XOR<MagicalStorageUpdateManyMutationInput, MagicalStorageUncheckedUpdateManyInput>
    /**
     * Filter which MagicalStorages to update
     */
    where?: MagicalStorageWhereInput
  }

  /**
   * MagicalStorage upsert
   */
  export type MagicalStorageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicalStorage to update in case it exists.
     */
    where: MagicalStorageWhereUniqueInput
    /**
     * In case the MagicalStorage found by the `where` argument doesn't exist, create a new MagicalStorage with this data.
     */
    create: XOR<MagicalStorageCreateInput, MagicalStorageUncheckedCreateInput>
    /**
     * In case the MagicalStorage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicalStorageUpdateInput, MagicalStorageUncheckedUpdateInput>
  }

  /**
   * MagicalStorage delete
   */
  export type MagicalStorageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
    /**
     * Filter which MagicalStorage to delete.
     */
    where: MagicalStorageWhereUniqueInput
  }

  /**
   * MagicalStorage deleteMany
   */
  export type MagicalStorageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicalStorages to delete
     */
    where?: MagicalStorageWhereInput
  }

  /**
   * MagicalStorage without action
   */
  export type MagicalStorageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicalStorage
     */
    select?: MagicalStorageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicalStorageInclude<ExtArgs> | null
  }


  /**
   * Model NpcDeliveryRoute
   */

  export type AggregateNpcDeliveryRoute = {
    _count: NpcDeliveryRouteCountAggregateOutputType | null
    _avg: NpcDeliveryRouteAvgAggregateOutputType | null
    _sum: NpcDeliveryRouteSumAggregateOutputType | null
    _min: NpcDeliveryRouteMinAggregateOutputType | null
    _max: NpcDeliveryRouteMaxAggregateOutputType | null
  }

  export type NpcDeliveryRouteAvgAggregateOutputType = {
    totalDistance: number | null
    estimatedTime: number | null
    priority: number | null
  }

  export type NpcDeliveryRouteSumAggregateOutputType = {
    totalDistance: number | null
    estimatedTime: number | null
    priority: number | null
  }

  export type NpcDeliveryRouteMinAggregateOutputType = {
    id: string | null
    deliveryNpcId: string | null
    routeName: string | null
    startLocation: string | null
    endLocation: string | null
    waypoints: string | null
    totalDistance: number | null
    estimatedTime: number | null
    isActive: boolean | null
    priority: number | null
    frequency: string | null
    lastRun: Date | null
    nextScheduledRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NpcDeliveryRouteMaxAggregateOutputType = {
    id: string | null
    deliveryNpcId: string | null
    routeName: string | null
    startLocation: string | null
    endLocation: string | null
    waypoints: string | null
    totalDistance: number | null
    estimatedTime: number | null
    isActive: boolean | null
    priority: number | null
    frequency: string | null
    lastRun: Date | null
    nextScheduledRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NpcDeliveryRouteCountAggregateOutputType = {
    id: number
    deliveryNpcId: number
    routeName: number
    startLocation: number
    endLocation: number
    waypoints: number
    totalDistance: number
    estimatedTime: number
    isActive: number
    priority: number
    frequency: number
    lastRun: number
    nextScheduledRun: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NpcDeliveryRouteAvgAggregateInputType = {
    totalDistance?: true
    estimatedTime?: true
    priority?: true
  }

  export type NpcDeliveryRouteSumAggregateInputType = {
    totalDistance?: true
    estimatedTime?: true
    priority?: true
  }

  export type NpcDeliveryRouteMinAggregateInputType = {
    id?: true
    deliveryNpcId?: true
    routeName?: true
    startLocation?: true
    endLocation?: true
    waypoints?: true
    totalDistance?: true
    estimatedTime?: true
    isActive?: true
    priority?: true
    frequency?: true
    lastRun?: true
    nextScheduledRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NpcDeliveryRouteMaxAggregateInputType = {
    id?: true
    deliveryNpcId?: true
    routeName?: true
    startLocation?: true
    endLocation?: true
    waypoints?: true
    totalDistance?: true
    estimatedTime?: true
    isActive?: true
    priority?: true
    frequency?: true
    lastRun?: true
    nextScheduledRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NpcDeliveryRouteCountAggregateInputType = {
    id?: true
    deliveryNpcId?: true
    routeName?: true
    startLocation?: true
    endLocation?: true
    waypoints?: true
    totalDistance?: true
    estimatedTime?: true
    isActive?: true
    priority?: true
    frequency?: true
    lastRun?: true
    nextScheduledRun?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NpcDeliveryRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NpcDeliveryRoute to aggregate.
     */
    where?: NpcDeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NpcDeliveryRoutes to fetch.
     */
    orderBy?: NpcDeliveryRouteOrderByWithRelationInput | NpcDeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NpcDeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NpcDeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NpcDeliveryRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NpcDeliveryRoutes
    **/
    _count?: true | NpcDeliveryRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NpcDeliveryRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NpcDeliveryRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NpcDeliveryRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NpcDeliveryRouteMaxAggregateInputType
  }

  export type GetNpcDeliveryRouteAggregateType<T extends NpcDeliveryRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateNpcDeliveryRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNpcDeliveryRoute[P]>
      : GetScalarType<T[P], AggregateNpcDeliveryRoute[P]>
  }




  export type NpcDeliveryRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NpcDeliveryRouteWhereInput
    orderBy?: NpcDeliveryRouteOrderByWithAggregationInput | NpcDeliveryRouteOrderByWithAggregationInput[]
    by: NpcDeliveryRouteScalarFieldEnum[] | NpcDeliveryRouteScalarFieldEnum
    having?: NpcDeliveryRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NpcDeliveryRouteCountAggregateInputType | true
    _avg?: NpcDeliveryRouteAvgAggregateInputType
    _sum?: NpcDeliveryRouteSumAggregateInputType
    _min?: NpcDeliveryRouteMinAggregateInputType
    _max?: NpcDeliveryRouteMaxAggregateInputType
  }

  export type NpcDeliveryRouteGroupByOutputType = {
    id: string
    deliveryNpcId: string
    routeName: string
    startLocation: string
    endLocation: string
    waypoints: string
    totalDistance: number
    estimatedTime: number
    isActive: boolean
    priority: number
    frequency: string
    lastRun: Date | null
    nextScheduledRun: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NpcDeliveryRouteCountAggregateOutputType | null
    _avg: NpcDeliveryRouteAvgAggregateOutputType | null
    _sum: NpcDeliveryRouteSumAggregateOutputType | null
    _min: NpcDeliveryRouteMinAggregateOutputType | null
    _max: NpcDeliveryRouteMaxAggregateOutputType | null
  }

  type GetNpcDeliveryRouteGroupByPayload<T extends NpcDeliveryRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NpcDeliveryRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NpcDeliveryRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NpcDeliveryRouteGroupByOutputType[P]>
            : GetScalarType<T[P], NpcDeliveryRouteGroupByOutputType[P]>
        }
      >
    >


  export type NpcDeliveryRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryNpcId?: boolean
    routeName?: boolean
    startLocation?: boolean
    endLocation?: boolean
    waypoints?: boolean
    totalDistance?: boolean
    estimatedTime?: boolean
    isActive?: boolean
    priority?: boolean
    frequency?: boolean
    lastRun?: boolean
    nextScheduledRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["npcDeliveryRoute"]>

  export type NpcDeliveryRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryNpcId?: boolean
    routeName?: boolean
    startLocation?: boolean
    endLocation?: boolean
    waypoints?: boolean
    totalDistance?: boolean
    estimatedTime?: boolean
    isActive?: boolean
    priority?: boolean
    frequency?: boolean
    lastRun?: boolean
    nextScheduledRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["npcDeliveryRoute"]>

  export type NpcDeliveryRouteSelectScalar = {
    id?: boolean
    deliveryNpcId?: boolean
    routeName?: boolean
    startLocation?: boolean
    endLocation?: boolean
    waypoints?: boolean
    totalDistance?: boolean
    estimatedTime?: boolean
    isActive?: boolean
    priority?: boolean
    frequency?: boolean
    lastRun?: boolean
    nextScheduledRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $NpcDeliveryRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NpcDeliveryRoute"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deliveryNpcId: string
      routeName: string
      startLocation: string
      endLocation: string
      waypoints: string
      totalDistance: number
      estimatedTime: number
      isActive: boolean
      priority: number
      frequency: string
      lastRun: Date | null
      nextScheduledRun: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["npcDeliveryRoute"]>
    composites: {}
  }

  type NpcDeliveryRouteGetPayload<S extends boolean | null | undefined | NpcDeliveryRouteDefaultArgs> = $Result.GetResult<Prisma.$NpcDeliveryRoutePayload, S>

  type NpcDeliveryRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NpcDeliveryRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NpcDeliveryRouteCountAggregateInputType | true
    }

  export interface NpcDeliveryRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NpcDeliveryRoute'], meta: { name: 'NpcDeliveryRoute' } }
    /**
     * Find zero or one NpcDeliveryRoute that matches the filter.
     * @param {NpcDeliveryRouteFindUniqueArgs} args - Arguments to find a NpcDeliveryRoute
     * @example
     * // Get one NpcDeliveryRoute
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NpcDeliveryRouteFindUniqueArgs>(args: SelectSubset<T, NpcDeliveryRouteFindUniqueArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NpcDeliveryRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NpcDeliveryRouteFindUniqueOrThrowArgs} args - Arguments to find a NpcDeliveryRoute
     * @example
     * // Get one NpcDeliveryRoute
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NpcDeliveryRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, NpcDeliveryRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NpcDeliveryRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteFindFirstArgs} args - Arguments to find a NpcDeliveryRoute
     * @example
     * // Get one NpcDeliveryRoute
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NpcDeliveryRouteFindFirstArgs>(args?: SelectSubset<T, NpcDeliveryRouteFindFirstArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NpcDeliveryRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteFindFirstOrThrowArgs} args - Arguments to find a NpcDeliveryRoute
     * @example
     * // Get one NpcDeliveryRoute
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NpcDeliveryRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, NpcDeliveryRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NpcDeliveryRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NpcDeliveryRoutes
     * const npcDeliveryRoutes = await prisma.npcDeliveryRoute.findMany()
     * 
     * // Get first 10 NpcDeliveryRoutes
     * const npcDeliveryRoutes = await prisma.npcDeliveryRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const npcDeliveryRouteWithIdOnly = await prisma.npcDeliveryRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NpcDeliveryRouteFindManyArgs>(args?: SelectSubset<T, NpcDeliveryRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NpcDeliveryRoute.
     * @param {NpcDeliveryRouteCreateArgs} args - Arguments to create a NpcDeliveryRoute.
     * @example
     * // Create one NpcDeliveryRoute
     * const NpcDeliveryRoute = await prisma.npcDeliveryRoute.create({
     *   data: {
     *     // ... data to create a NpcDeliveryRoute
     *   }
     * })
     * 
     */
    create<T extends NpcDeliveryRouteCreateArgs>(args: SelectSubset<T, NpcDeliveryRouteCreateArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NpcDeliveryRoutes.
     * @param {NpcDeliveryRouteCreateManyArgs} args - Arguments to create many NpcDeliveryRoutes.
     * @example
     * // Create many NpcDeliveryRoutes
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NpcDeliveryRouteCreateManyArgs>(args?: SelectSubset<T, NpcDeliveryRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NpcDeliveryRoutes and returns the data saved in the database.
     * @param {NpcDeliveryRouteCreateManyAndReturnArgs} args - Arguments to create many NpcDeliveryRoutes.
     * @example
     * // Create many NpcDeliveryRoutes
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NpcDeliveryRoutes and only return the `id`
     * const npcDeliveryRouteWithIdOnly = await prisma.npcDeliveryRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NpcDeliveryRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, NpcDeliveryRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NpcDeliveryRoute.
     * @param {NpcDeliveryRouteDeleteArgs} args - Arguments to delete one NpcDeliveryRoute.
     * @example
     * // Delete one NpcDeliveryRoute
     * const NpcDeliveryRoute = await prisma.npcDeliveryRoute.delete({
     *   where: {
     *     // ... filter to delete one NpcDeliveryRoute
     *   }
     * })
     * 
     */
    delete<T extends NpcDeliveryRouteDeleteArgs>(args: SelectSubset<T, NpcDeliveryRouteDeleteArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NpcDeliveryRoute.
     * @param {NpcDeliveryRouteUpdateArgs} args - Arguments to update one NpcDeliveryRoute.
     * @example
     * // Update one NpcDeliveryRoute
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NpcDeliveryRouteUpdateArgs>(args: SelectSubset<T, NpcDeliveryRouteUpdateArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NpcDeliveryRoutes.
     * @param {NpcDeliveryRouteDeleteManyArgs} args - Arguments to filter NpcDeliveryRoutes to delete.
     * @example
     * // Delete a few NpcDeliveryRoutes
     * const { count } = await prisma.npcDeliveryRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NpcDeliveryRouteDeleteManyArgs>(args?: SelectSubset<T, NpcDeliveryRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NpcDeliveryRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NpcDeliveryRoutes
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NpcDeliveryRouteUpdateManyArgs>(args: SelectSubset<T, NpcDeliveryRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NpcDeliveryRoute.
     * @param {NpcDeliveryRouteUpsertArgs} args - Arguments to update or create a NpcDeliveryRoute.
     * @example
     * // Update or create a NpcDeliveryRoute
     * const npcDeliveryRoute = await prisma.npcDeliveryRoute.upsert({
     *   create: {
     *     // ... data to create a NpcDeliveryRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NpcDeliveryRoute we want to update
     *   }
     * })
     */
    upsert<T extends NpcDeliveryRouteUpsertArgs>(args: SelectSubset<T, NpcDeliveryRouteUpsertArgs<ExtArgs>>): Prisma__NpcDeliveryRouteClient<$Result.GetResult<Prisma.$NpcDeliveryRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NpcDeliveryRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteCountArgs} args - Arguments to filter NpcDeliveryRoutes to count.
     * @example
     * // Count the number of NpcDeliveryRoutes
     * const count = await prisma.npcDeliveryRoute.count({
     *   where: {
     *     // ... the filter for the NpcDeliveryRoutes we want to count
     *   }
     * })
    **/
    count<T extends NpcDeliveryRouteCountArgs>(
      args?: Subset<T, NpcDeliveryRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NpcDeliveryRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NpcDeliveryRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NpcDeliveryRouteAggregateArgs>(args: Subset<T, NpcDeliveryRouteAggregateArgs>): Prisma.PrismaPromise<GetNpcDeliveryRouteAggregateType<T>>

    /**
     * Group by NpcDeliveryRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NpcDeliveryRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NpcDeliveryRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NpcDeliveryRouteGroupByArgs['orderBy'] }
        : { orderBy?: NpcDeliveryRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NpcDeliveryRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNpcDeliveryRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NpcDeliveryRoute model
   */
  readonly fields: NpcDeliveryRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NpcDeliveryRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NpcDeliveryRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NpcDeliveryRoute model
   */ 
  interface NpcDeliveryRouteFieldRefs {
    readonly id: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly deliveryNpcId: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly routeName: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly startLocation: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly endLocation: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly waypoints: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly totalDistance: FieldRef<"NpcDeliveryRoute", 'Float'>
    readonly estimatedTime: FieldRef<"NpcDeliveryRoute", 'Int'>
    readonly isActive: FieldRef<"NpcDeliveryRoute", 'Boolean'>
    readonly priority: FieldRef<"NpcDeliveryRoute", 'Int'>
    readonly frequency: FieldRef<"NpcDeliveryRoute", 'String'>
    readonly lastRun: FieldRef<"NpcDeliveryRoute", 'DateTime'>
    readonly nextScheduledRun: FieldRef<"NpcDeliveryRoute", 'DateTime'>
    readonly createdAt: FieldRef<"NpcDeliveryRoute", 'DateTime'>
    readonly updatedAt: FieldRef<"NpcDeliveryRoute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NpcDeliveryRoute findUnique
   */
  export type NpcDeliveryRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * Filter, which NpcDeliveryRoute to fetch.
     */
    where: NpcDeliveryRouteWhereUniqueInput
  }

  /**
   * NpcDeliveryRoute findUniqueOrThrow
   */
  export type NpcDeliveryRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * Filter, which NpcDeliveryRoute to fetch.
     */
    where: NpcDeliveryRouteWhereUniqueInput
  }

  /**
   * NpcDeliveryRoute findFirst
   */
  export type NpcDeliveryRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * Filter, which NpcDeliveryRoute to fetch.
     */
    where?: NpcDeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NpcDeliveryRoutes to fetch.
     */
    orderBy?: NpcDeliveryRouteOrderByWithRelationInput | NpcDeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NpcDeliveryRoutes.
     */
    cursor?: NpcDeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NpcDeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NpcDeliveryRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NpcDeliveryRoutes.
     */
    distinct?: NpcDeliveryRouteScalarFieldEnum | NpcDeliveryRouteScalarFieldEnum[]
  }

  /**
   * NpcDeliveryRoute findFirstOrThrow
   */
  export type NpcDeliveryRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * Filter, which NpcDeliveryRoute to fetch.
     */
    where?: NpcDeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NpcDeliveryRoutes to fetch.
     */
    orderBy?: NpcDeliveryRouteOrderByWithRelationInput | NpcDeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NpcDeliveryRoutes.
     */
    cursor?: NpcDeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NpcDeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NpcDeliveryRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NpcDeliveryRoutes.
     */
    distinct?: NpcDeliveryRouteScalarFieldEnum | NpcDeliveryRouteScalarFieldEnum[]
  }

  /**
   * NpcDeliveryRoute findMany
   */
  export type NpcDeliveryRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * Filter, which NpcDeliveryRoutes to fetch.
     */
    where?: NpcDeliveryRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NpcDeliveryRoutes to fetch.
     */
    orderBy?: NpcDeliveryRouteOrderByWithRelationInput | NpcDeliveryRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NpcDeliveryRoutes.
     */
    cursor?: NpcDeliveryRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NpcDeliveryRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NpcDeliveryRoutes.
     */
    skip?: number
    distinct?: NpcDeliveryRouteScalarFieldEnum | NpcDeliveryRouteScalarFieldEnum[]
  }

  /**
   * NpcDeliveryRoute create
   */
  export type NpcDeliveryRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * The data needed to create a NpcDeliveryRoute.
     */
    data: XOR<NpcDeliveryRouteCreateInput, NpcDeliveryRouteUncheckedCreateInput>
  }

  /**
   * NpcDeliveryRoute createMany
   */
  export type NpcDeliveryRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NpcDeliveryRoutes.
     */
    data: NpcDeliveryRouteCreateManyInput | NpcDeliveryRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NpcDeliveryRoute createManyAndReturn
   */
  export type NpcDeliveryRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NpcDeliveryRoutes.
     */
    data: NpcDeliveryRouteCreateManyInput | NpcDeliveryRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NpcDeliveryRoute update
   */
  export type NpcDeliveryRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * The data needed to update a NpcDeliveryRoute.
     */
    data: XOR<NpcDeliveryRouteUpdateInput, NpcDeliveryRouteUncheckedUpdateInput>
    /**
     * Choose, which NpcDeliveryRoute to update.
     */
    where: NpcDeliveryRouteWhereUniqueInput
  }

  /**
   * NpcDeliveryRoute updateMany
   */
  export type NpcDeliveryRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NpcDeliveryRoutes.
     */
    data: XOR<NpcDeliveryRouteUpdateManyMutationInput, NpcDeliveryRouteUncheckedUpdateManyInput>
    /**
     * Filter which NpcDeliveryRoutes to update
     */
    where?: NpcDeliveryRouteWhereInput
  }

  /**
   * NpcDeliveryRoute upsert
   */
  export type NpcDeliveryRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * The filter to search for the NpcDeliveryRoute to update in case it exists.
     */
    where: NpcDeliveryRouteWhereUniqueInput
    /**
     * In case the NpcDeliveryRoute found by the `where` argument doesn't exist, create a new NpcDeliveryRoute with this data.
     */
    create: XOR<NpcDeliveryRouteCreateInput, NpcDeliveryRouteUncheckedCreateInput>
    /**
     * In case the NpcDeliveryRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NpcDeliveryRouteUpdateInput, NpcDeliveryRouteUncheckedUpdateInput>
  }

  /**
   * NpcDeliveryRoute delete
   */
  export type NpcDeliveryRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
    /**
     * Filter which NpcDeliveryRoute to delete.
     */
    where: NpcDeliveryRouteWhereUniqueInput
  }

  /**
   * NpcDeliveryRoute deleteMany
   */
  export type NpcDeliveryRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NpcDeliveryRoutes to delete
     */
    where?: NpcDeliveryRouteWhereInput
  }

  /**
   * NpcDeliveryRoute without action
   */
  export type NpcDeliveryRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NpcDeliveryRoute
     */
    select?: NpcDeliveryRouteSelect<ExtArgs> | null
  }


  /**
   * Model OAuthProviders
   */

  export type AggregateOAuthProviders = {
    _count: OAuthProvidersCountAggregateOutputType | null
    _avg: OAuthProvidersAvgAggregateOutputType | null
    _sum: OAuthProvidersSumAggregateOutputType | null
    _min: OAuthProvidersMinAggregateOutputType | null
    _max: OAuthProvidersMaxAggregateOutputType | null
  }

  export type OAuthProvidersAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type OAuthProvidersSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type OAuthProvidersMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    description: string | null
    iconName: string | null
    enabled: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthProvidersMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    description: string | null
    iconName: string | null
    enabled: boolean | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthProvidersCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    description: number
    iconName: number
    enabled: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OAuthProvidersAvgAggregateInputType = {
    displayOrder?: true
  }

  export type OAuthProvidersSumAggregateInputType = {
    displayOrder?: true
  }

  export type OAuthProvidersMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    iconName?: true
    enabled?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthProvidersMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    iconName?: true
    enabled?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthProvidersCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    iconName?: true
    enabled?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OAuthProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthProviders to aggregate.
     */
    where?: OAuthProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthProviders to fetch.
     */
    orderBy?: OAuthProvidersOrderByWithRelationInput | OAuthProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthProviders
    **/
    _count?: true | OAuthProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OAuthProvidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OAuthProvidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthProvidersMaxAggregateInputType
  }

  export type GetOAuthProvidersAggregateType<T extends OAuthProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthProviders[P]>
      : GetScalarType<T[P], AggregateOAuthProviders[P]>
  }




  export type OAuthProvidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthProvidersWhereInput
    orderBy?: OAuthProvidersOrderByWithAggregationInput | OAuthProvidersOrderByWithAggregationInput[]
    by: OAuthProvidersScalarFieldEnum[] | OAuthProvidersScalarFieldEnum
    having?: OAuthProvidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthProvidersCountAggregateInputType | true
    _avg?: OAuthProvidersAvgAggregateInputType
    _sum?: OAuthProvidersSumAggregateInputType
    _min?: OAuthProvidersMinAggregateInputType
    _max?: OAuthProvidersMaxAggregateInputType
  }

  export type OAuthProvidersGroupByOutputType = {
    id: string
    providerId: string
    name: string
    description: string
    iconName: string
    enabled: boolean
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: OAuthProvidersCountAggregateOutputType | null
    _avg: OAuthProvidersAvgAggregateOutputType | null
    _sum: OAuthProvidersSumAggregateOutputType | null
    _min: OAuthProvidersMinAggregateOutputType | null
    _max: OAuthProvidersMaxAggregateOutputType | null
  }

  type GetOAuthProvidersGroupByPayload<T extends OAuthProvidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthProvidersGroupByOutputType[P]>
        }
      >
    >


  export type OAuthProvidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    enabled?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["oAuthProviders"]>

  export type OAuthProvidersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    enabled?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["oAuthProviders"]>

  export type OAuthProvidersSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    enabled?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $OAuthProvidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthProviders"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      name: string
      description: string
      iconName: string
      enabled: boolean
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oAuthProviders"]>
    composites: {}
  }

  type OAuthProvidersGetPayload<S extends boolean | null | undefined | OAuthProvidersDefaultArgs> = $Result.GetResult<Prisma.$OAuthProvidersPayload, S>

  type OAuthProvidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthProvidersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthProvidersCountAggregateInputType | true
    }

  export interface OAuthProvidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthProviders'], meta: { name: 'OAuthProviders' } }
    /**
     * Find zero or one OAuthProviders that matches the filter.
     * @param {OAuthProvidersFindUniqueArgs} args - Arguments to find a OAuthProviders
     * @example
     * // Get one OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthProvidersFindUniqueArgs>(args: SelectSubset<T, OAuthProvidersFindUniqueArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthProviders that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthProvidersFindUniqueOrThrowArgs} args - Arguments to find a OAuthProviders
     * @example
     * // Get one OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthProvidersFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthProvidersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersFindFirstArgs} args - Arguments to find a OAuthProviders
     * @example
     * // Get one OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthProvidersFindFirstArgs>(args?: SelectSubset<T, OAuthProvidersFindFirstArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthProviders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersFindFirstOrThrowArgs} args - Arguments to find a OAuthProviders
     * @example
     * // Get one OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthProvidersFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthProvidersFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.findMany()
     * 
     * // Get first 10 OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthProvidersWithIdOnly = await prisma.oAuthProviders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthProvidersFindManyArgs>(args?: SelectSubset<T, OAuthProvidersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthProviders.
     * @param {OAuthProvidersCreateArgs} args - Arguments to create a OAuthProviders.
     * @example
     * // Create one OAuthProviders
     * const OAuthProviders = await prisma.oAuthProviders.create({
     *   data: {
     *     // ... data to create a OAuthProviders
     *   }
     * })
     * 
     */
    create<T extends OAuthProvidersCreateArgs>(args: SelectSubset<T, OAuthProvidersCreateArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthProviders.
     * @param {OAuthProvidersCreateManyArgs} args - Arguments to create many OAuthProviders.
     * @example
     * // Create many OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthProvidersCreateManyArgs>(args?: SelectSubset<T, OAuthProvidersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthProviders and returns the data saved in the database.
     * @param {OAuthProvidersCreateManyAndReturnArgs} args - Arguments to create many OAuthProviders.
     * @example
     * // Create many OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthProviders and only return the `id`
     * const oAuthProvidersWithIdOnly = await prisma.oAuthProviders.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthProvidersCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthProvidersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OAuthProviders.
     * @param {OAuthProvidersDeleteArgs} args - Arguments to delete one OAuthProviders.
     * @example
     * // Delete one OAuthProviders
     * const OAuthProviders = await prisma.oAuthProviders.delete({
     *   where: {
     *     // ... filter to delete one OAuthProviders
     *   }
     * })
     * 
     */
    delete<T extends OAuthProvidersDeleteArgs>(args: SelectSubset<T, OAuthProvidersDeleteArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthProviders.
     * @param {OAuthProvidersUpdateArgs} args - Arguments to update one OAuthProviders.
     * @example
     * // Update one OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthProvidersUpdateArgs>(args: SelectSubset<T, OAuthProvidersUpdateArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthProviders.
     * @param {OAuthProvidersDeleteManyArgs} args - Arguments to filter OAuthProviders to delete.
     * @example
     * // Delete a few OAuthProviders
     * const { count } = await prisma.oAuthProviders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthProvidersDeleteManyArgs>(args?: SelectSubset<T, OAuthProvidersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthProvidersUpdateManyArgs>(args: SelectSubset<T, OAuthProvidersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthProviders.
     * @param {OAuthProvidersUpsertArgs} args - Arguments to update or create a OAuthProviders.
     * @example
     * // Update or create a OAuthProviders
     * const oAuthProviders = await prisma.oAuthProviders.upsert({
     *   create: {
     *     // ... data to create a OAuthProviders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthProviders we want to update
     *   }
     * })
     */
    upsert<T extends OAuthProvidersUpsertArgs>(args: SelectSubset<T, OAuthProvidersUpsertArgs<ExtArgs>>): Prisma__OAuthProvidersClient<$Result.GetResult<Prisma.$OAuthProvidersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersCountArgs} args - Arguments to filter OAuthProviders to count.
     * @example
     * // Count the number of OAuthProviders
     * const count = await prisma.oAuthProviders.count({
     *   where: {
     *     // ... the filter for the OAuthProviders we want to count
     *   }
     * })
    **/
    count<T extends OAuthProvidersCountArgs>(
      args?: Subset<T, OAuthProvidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthProvidersAggregateArgs>(args: Subset<T, OAuthProvidersAggregateArgs>): Prisma.PrismaPromise<GetOAuthProvidersAggregateType<T>>

    /**
     * Group by OAuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthProvidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthProvidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthProvidersGroupByArgs['orderBy'] }
        : { orderBy?: OAuthProvidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthProvidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthProviders model
   */
  readonly fields: OAuthProvidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthProviders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthProvidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthProviders model
   */ 
  interface OAuthProvidersFieldRefs {
    readonly id: FieldRef<"OAuthProviders", 'String'>
    readonly providerId: FieldRef<"OAuthProviders", 'String'>
    readonly name: FieldRef<"OAuthProviders", 'String'>
    readonly description: FieldRef<"OAuthProviders", 'String'>
    readonly iconName: FieldRef<"OAuthProviders", 'String'>
    readonly enabled: FieldRef<"OAuthProviders", 'Boolean'>
    readonly displayOrder: FieldRef<"OAuthProviders", 'Int'>
    readonly createdAt: FieldRef<"OAuthProviders", 'DateTime'>
    readonly updatedAt: FieldRef<"OAuthProviders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthProviders findUnique
   */
  export type OAuthProvidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * Filter, which OAuthProviders to fetch.
     */
    where: OAuthProvidersWhereUniqueInput
  }

  /**
   * OAuthProviders findUniqueOrThrow
   */
  export type OAuthProvidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * Filter, which OAuthProviders to fetch.
     */
    where: OAuthProvidersWhereUniqueInput
  }

  /**
   * OAuthProviders findFirst
   */
  export type OAuthProvidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * Filter, which OAuthProviders to fetch.
     */
    where?: OAuthProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthProviders to fetch.
     */
    orderBy?: OAuthProvidersOrderByWithRelationInput | OAuthProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthProviders.
     */
    cursor?: OAuthProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthProviders.
     */
    distinct?: OAuthProvidersScalarFieldEnum | OAuthProvidersScalarFieldEnum[]
  }

  /**
   * OAuthProviders findFirstOrThrow
   */
  export type OAuthProvidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * Filter, which OAuthProviders to fetch.
     */
    where?: OAuthProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthProviders to fetch.
     */
    orderBy?: OAuthProvidersOrderByWithRelationInput | OAuthProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthProviders.
     */
    cursor?: OAuthProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthProviders.
     */
    distinct?: OAuthProvidersScalarFieldEnum | OAuthProvidersScalarFieldEnum[]
  }

  /**
   * OAuthProviders findMany
   */
  export type OAuthProvidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * Filter, which OAuthProviders to fetch.
     */
    where?: OAuthProvidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthProviders to fetch.
     */
    orderBy?: OAuthProvidersOrderByWithRelationInput | OAuthProvidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthProviders.
     */
    cursor?: OAuthProvidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthProviders.
     */
    skip?: number
    distinct?: OAuthProvidersScalarFieldEnum | OAuthProvidersScalarFieldEnum[]
  }

  /**
   * OAuthProviders create
   */
  export type OAuthProvidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * The data needed to create a OAuthProviders.
     */
    data: XOR<OAuthProvidersCreateInput, OAuthProvidersUncheckedCreateInput>
  }

  /**
   * OAuthProviders createMany
   */
  export type OAuthProvidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthProviders.
     */
    data: OAuthProvidersCreateManyInput | OAuthProvidersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthProviders createManyAndReturn
   */
  export type OAuthProvidersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OAuthProviders.
     */
    data: OAuthProvidersCreateManyInput | OAuthProvidersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthProviders update
   */
  export type OAuthProvidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * The data needed to update a OAuthProviders.
     */
    data: XOR<OAuthProvidersUpdateInput, OAuthProvidersUncheckedUpdateInput>
    /**
     * Choose, which OAuthProviders to update.
     */
    where: OAuthProvidersWhereUniqueInput
  }

  /**
   * OAuthProviders updateMany
   */
  export type OAuthProvidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthProviders.
     */
    data: XOR<OAuthProvidersUpdateManyMutationInput, OAuthProvidersUncheckedUpdateManyInput>
    /**
     * Filter which OAuthProviders to update
     */
    where?: OAuthProvidersWhereInput
  }

  /**
   * OAuthProviders upsert
   */
  export type OAuthProvidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * The filter to search for the OAuthProviders to update in case it exists.
     */
    where: OAuthProvidersWhereUniqueInput
    /**
     * In case the OAuthProviders found by the `where` argument doesn't exist, create a new OAuthProviders with this data.
     */
    create: XOR<OAuthProvidersCreateInput, OAuthProvidersUncheckedCreateInput>
    /**
     * In case the OAuthProviders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthProvidersUpdateInput, OAuthProvidersUncheckedUpdateInput>
  }

  /**
   * OAuthProviders delete
   */
  export type OAuthProvidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
    /**
     * Filter which OAuthProviders to delete.
     */
    where: OAuthProvidersWhereUniqueInput
  }

  /**
   * OAuthProviders deleteMany
   */
  export type OAuthProvidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthProviders to delete
     */
    where?: OAuthProvidersWhereInput
  }

  /**
   * OAuthProviders without action
   */
  export type OAuthProvidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthProviders
     */
    select?: OAuthProvidersSelect<ExtArgs> | null
  }


  /**
   * Model PlayerInventory
   */

  export type AggregatePlayerInventory = {
    _count: PlayerInventoryCountAggregateOutputType | null
    _avg: PlayerInventoryAvgAggregateOutputType | null
    _sum: PlayerInventorySumAggregateOutputType | null
    _min: PlayerInventoryMinAggregateOutputType | null
    _max: PlayerInventoryMaxAggregateOutputType | null
  }

  export type PlayerInventoryAvgAggregateOutputType = {
    quantity: number | null
    weight: number | null
    totalWeight: number | null
    volume: number | null
    totalVolume: number | null
    slot: number | null
    condition: number | null
    max_stack: number | null
  }

  export type PlayerInventorySumAggregateOutputType = {
    quantity: number | null
    weight: number | null
    totalWeight: number | null
    volume: number | null
    totalVolume: number | null
    slot: number | null
    condition: number | null
    max_stack: number | null
  }

  export type PlayerInventoryMinAggregateOutputType = {
    id: string | null
    character_id: string | null
    item_id: string | null
    quantity: number | null
    quality: string | null
    weight: number | null
    totalWeight: number | null
    volume: number | null
    totalVolume: number | null
    slot: number | null
    is_equipped: boolean | null
    equipment_slot: string | null
    condition: number | null
    is_stackable: boolean | null
    max_stack: number | null
    acquired_at: Date | null
    last_used_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlayerInventoryMaxAggregateOutputType = {
    id: string | null
    character_id: string | null
    item_id: string | null
    quantity: number | null
    quality: string | null
    weight: number | null
    totalWeight: number | null
    volume: number | null
    totalVolume: number | null
    slot: number | null
    is_equipped: boolean | null
    equipment_slot: string | null
    condition: number | null
    is_stackable: boolean | null
    max_stack: number | null
    acquired_at: Date | null
    last_used_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlayerInventoryCountAggregateOutputType = {
    id: number
    character_id: number
    item_id: number
    quantity: number
    quality: number
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot: number
    is_equipped: number
    equipment_slot: number
    condition: number
    is_stackable: number
    max_stack: number
    acquired_at: number
    last_used_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PlayerInventoryAvgAggregateInputType = {
    quantity?: true
    weight?: true
    totalWeight?: true
    volume?: true
    totalVolume?: true
    slot?: true
    condition?: true
    max_stack?: true
  }

  export type PlayerInventorySumAggregateInputType = {
    quantity?: true
    weight?: true
    totalWeight?: true
    volume?: true
    totalVolume?: true
    slot?: true
    condition?: true
    max_stack?: true
  }

  export type PlayerInventoryMinAggregateInputType = {
    id?: true
    character_id?: true
    item_id?: true
    quantity?: true
    quality?: true
    weight?: true
    totalWeight?: true
    volume?: true
    totalVolume?: true
    slot?: true
    is_equipped?: true
    equipment_slot?: true
    condition?: true
    is_stackable?: true
    max_stack?: true
    acquired_at?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
  }

  export type PlayerInventoryMaxAggregateInputType = {
    id?: true
    character_id?: true
    item_id?: true
    quantity?: true
    quality?: true
    weight?: true
    totalWeight?: true
    volume?: true
    totalVolume?: true
    slot?: true
    is_equipped?: true
    equipment_slot?: true
    condition?: true
    is_stackable?: true
    max_stack?: true
    acquired_at?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
  }

  export type PlayerInventoryCountAggregateInputType = {
    id?: true
    character_id?: true
    item_id?: true
    quantity?: true
    quality?: true
    weight?: true
    totalWeight?: true
    volume?: true
    totalVolume?: true
    slot?: true
    is_equipped?: true
    equipment_slot?: true
    condition?: true
    is_stackable?: true
    max_stack?: true
    acquired_at?: true
    last_used_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PlayerInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerInventory to aggregate.
     */
    where?: PlayerInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerInventories to fetch.
     */
    orderBy?: PlayerInventoryOrderByWithRelationInput | PlayerInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerInventories
    **/
    _count?: true | PlayerInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerInventoryMaxAggregateInputType
  }

  export type GetPlayerInventoryAggregateType<T extends PlayerInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerInventory[P]>
      : GetScalarType<T[P], AggregatePlayerInventory[P]>
  }




  export type PlayerInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerInventoryWhereInput
    orderBy?: PlayerInventoryOrderByWithAggregationInput | PlayerInventoryOrderByWithAggregationInput[]
    by: PlayerInventoryScalarFieldEnum[] | PlayerInventoryScalarFieldEnum
    having?: PlayerInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerInventoryCountAggregateInputType | true
    _avg?: PlayerInventoryAvgAggregateInputType
    _sum?: PlayerInventorySumAggregateInputType
    _min?: PlayerInventoryMinAggregateInputType
    _max?: PlayerInventoryMaxAggregateInputType
  }

  export type PlayerInventoryGroupByOutputType = {
    id: string
    character_id: string
    item_id: string
    quantity: number
    quality: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot: number | null
    is_equipped: boolean
    equipment_slot: string | null
    condition: number
    is_stackable: boolean
    max_stack: number
    acquired_at: Date
    last_used_at: Date | null
    created_at: Date
    updated_at: Date
    _count: PlayerInventoryCountAggregateOutputType | null
    _avg: PlayerInventoryAvgAggregateOutputType | null
    _sum: PlayerInventorySumAggregateOutputType | null
    _min: PlayerInventoryMinAggregateOutputType | null
    _max: PlayerInventoryMaxAggregateOutputType | null
  }

  type GetPlayerInventoryGroupByPayload<T extends PlayerInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerInventoryGroupByOutputType[P]>
        }
      >
    >


  export type PlayerInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    character_id?: boolean
    item_id?: boolean
    quantity?: boolean
    quality?: boolean
    weight?: boolean
    totalWeight?: boolean
    volume?: boolean
    totalVolume?: boolean
    slot?: boolean
    is_equipped?: boolean
    equipment_slot?: boolean
    condition?: boolean
    is_stackable?: boolean
    max_stack?: boolean
    acquired_at?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    game_characters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerInventory"]>

  export type PlayerInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    character_id?: boolean
    item_id?: boolean
    quantity?: boolean
    quality?: boolean
    weight?: boolean
    totalWeight?: boolean
    volume?: boolean
    totalVolume?: boolean
    slot?: boolean
    is_equipped?: boolean
    equipment_slot?: boolean
    condition?: boolean
    is_stackable?: boolean
    max_stack?: boolean
    acquired_at?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    game_characters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerInventory"]>

  export type PlayerInventorySelectScalar = {
    id?: boolean
    character_id?: boolean
    item_id?: boolean
    quantity?: boolean
    quality?: boolean
    weight?: boolean
    totalWeight?: boolean
    volume?: boolean
    totalVolume?: boolean
    slot?: boolean
    is_equipped?: boolean
    equipment_slot?: boolean
    condition?: boolean
    is_stackable?: boolean
    max_stack?: boolean
    acquired_at?: boolean
    last_used_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PlayerInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_characters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }
  export type PlayerInventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_characters?: boolean | GameCharacterDefaultArgs<ExtArgs>
  }

  export type $PlayerInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerInventory"
    objects: {
      game_characters: Prisma.$GameCharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      character_id: string
      item_id: string
      quantity: number
      quality: string
      weight: number
      totalWeight: number
      volume: number
      totalVolume: number
      slot: number | null
      is_equipped: boolean
      equipment_slot: string | null
      condition: number
      is_stackable: boolean
      max_stack: number
      acquired_at: Date
      last_used_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["playerInventory"]>
    composites: {}
  }

  type PlayerInventoryGetPayload<S extends boolean | null | undefined | PlayerInventoryDefaultArgs> = $Result.GetResult<Prisma.$PlayerInventoryPayload, S>

  type PlayerInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerInventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerInventoryCountAggregateInputType | true
    }

  export interface PlayerInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerInventory'], meta: { name: 'PlayerInventory' } }
    /**
     * Find zero or one PlayerInventory that matches the filter.
     * @param {PlayerInventoryFindUniqueArgs} args - Arguments to find a PlayerInventory
     * @example
     * // Get one PlayerInventory
     * const playerInventory = await prisma.playerInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerInventoryFindUniqueArgs>(args: SelectSubset<T, PlayerInventoryFindUniqueArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerInventory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerInventoryFindUniqueOrThrowArgs} args - Arguments to find a PlayerInventory
     * @example
     * // Get one PlayerInventory
     * const playerInventory = await prisma.playerInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryFindFirstArgs} args - Arguments to find a PlayerInventory
     * @example
     * // Get one PlayerInventory
     * const playerInventory = await prisma.playerInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerInventoryFindFirstArgs>(args?: SelectSubset<T, PlayerInventoryFindFirstArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryFindFirstOrThrowArgs} args - Arguments to find a PlayerInventory
     * @example
     * // Get one PlayerInventory
     * const playerInventory = await prisma.playerInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerInventories
     * const playerInventories = await prisma.playerInventory.findMany()
     * 
     * // Get first 10 PlayerInventories
     * const playerInventories = await prisma.playerInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerInventoryWithIdOnly = await prisma.playerInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerInventoryFindManyArgs>(args?: SelectSubset<T, PlayerInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerInventory.
     * @param {PlayerInventoryCreateArgs} args - Arguments to create a PlayerInventory.
     * @example
     * // Create one PlayerInventory
     * const PlayerInventory = await prisma.playerInventory.create({
     *   data: {
     *     // ... data to create a PlayerInventory
     *   }
     * })
     * 
     */
    create<T extends PlayerInventoryCreateArgs>(args: SelectSubset<T, PlayerInventoryCreateArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerInventories.
     * @param {PlayerInventoryCreateManyArgs} args - Arguments to create many PlayerInventories.
     * @example
     * // Create many PlayerInventories
     * const playerInventory = await prisma.playerInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerInventoryCreateManyArgs>(args?: SelectSubset<T, PlayerInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerInventories and returns the data saved in the database.
     * @param {PlayerInventoryCreateManyAndReturnArgs} args - Arguments to create many PlayerInventories.
     * @example
     * // Create many PlayerInventories
     * const playerInventory = await prisma.playerInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerInventories and only return the `id`
     * const playerInventoryWithIdOnly = await prisma.playerInventory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerInventory.
     * @param {PlayerInventoryDeleteArgs} args - Arguments to delete one PlayerInventory.
     * @example
     * // Delete one PlayerInventory
     * const PlayerInventory = await prisma.playerInventory.delete({
     *   where: {
     *     // ... filter to delete one PlayerInventory
     *   }
     * })
     * 
     */
    delete<T extends PlayerInventoryDeleteArgs>(args: SelectSubset<T, PlayerInventoryDeleteArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerInventory.
     * @param {PlayerInventoryUpdateArgs} args - Arguments to update one PlayerInventory.
     * @example
     * // Update one PlayerInventory
     * const playerInventory = await prisma.playerInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerInventoryUpdateArgs>(args: SelectSubset<T, PlayerInventoryUpdateArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerInventories.
     * @param {PlayerInventoryDeleteManyArgs} args - Arguments to filter PlayerInventories to delete.
     * @example
     * // Delete a few PlayerInventories
     * const { count } = await prisma.playerInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerInventoryDeleteManyArgs>(args?: SelectSubset<T, PlayerInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerInventories
     * const playerInventory = await prisma.playerInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerInventoryUpdateManyArgs>(args: SelectSubset<T, PlayerInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerInventory.
     * @param {PlayerInventoryUpsertArgs} args - Arguments to update or create a PlayerInventory.
     * @example
     * // Update or create a PlayerInventory
     * const playerInventory = await prisma.playerInventory.upsert({
     *   create: {
     *     // ... data to create a PlayerInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerInventory we want to update
     *   }
     * })
     */
    upsert<T extends PlayerInventoryUpsertArgs>(args: SelectSubset<T, PlayerInventoryUpsertArgs<ExtArgs>>): Prisma__PlayerInventoryClient<$Result.GetResult<Prisma.$PlayerInventoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryCountArgs} args - Arguments to filter PlayerInventories to count.
     * @example
     * // Count the number of PlayerInventories
     * const count = await prisma.playerInventory.count({
     *   where: {
     *     // ... the filter for the PlayerInventories we want to count
     *   }
     * })
    **/
    count<T extends PlayerInventoryCountArgs>(
      args?: Subset<T, PlayerInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerInventoryAggregateArgs>(args: Subset<T, PlayerInventoryAggregateArgs>): Prisma.PrismaPromise<GetPlayerInventoryAggregateType<T>>

    /**
     * Group by PlayerInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerInventoryGroupByArgs['orderBy'] }
        : { orderBy?: PlayerInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerInventory model
   */
  readonly fields: PlayerInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game_characters<T extends GameCharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameCharacterDefaultArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerInventory model
   */ 
  interface PlayerInventoryFieldRefs {
    readonly id: FieldRef<"PlayerInventory", 'String'>
    readonly character_id: FieldRef<"PlayerInventory", 'String'>
    readonly item_id: FieldRef<"PlayerInventory", 'String'>
    readonly quantity: FieldRef<"PlayerInventory", 'Int'>
    readonly quality: FieldRef<"PlayerInventory", 'String'>
    readonly weight: FieldRef<"PlayerInventory", 'Float'>
    readonly totalWeight: FieldRef<"PlayerInventory", 'Float'>
    readonly volume: FieldRef<"PlayerInventory", 'Float'>
    readonly totalVolume: FieldRef<"PlayerInventory", 'Float'>
    readonly slot: FieldRef<"PlayerInventory", 'Int'>
    readonly is_equipped: FieldRef<"PlayerInventory", 'Boolean'>
    readonly equipment_slot: FieldRef<"PlayerInventory", 'String'>
    readonly condition: FieldRef<"PlayerInventory", 'Float'>
    readonly is_stackable: FieldRef<"PlayerInventory", 'Boolean'>
    readonly max_stack: FieldRef<"PlayerInventory", 'Int'>
    readonly acquired_at: FieldRef<"PlayerInventory", 'DateTime'>
    readonly last_used_at: FieldRef<"PlayerInventory", 'DateTime'>
    readonly created_at: FieldRef<"PlayerInventory", 'DateTime'>
    readonly updated_at: FieldRef<"PlayerInventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerInventory findUnique
   */
  export type PlayerInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerInventory to fetch.
     */
    where: PlayerInventoryWhereUniqueInput
  }

  /**
   * PlayerInventory findUniqueOrThrow
   */
  export type PlayerInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerInventory to fetch.
     */
    where: PlayerInventoryWhereUniqueInput
  }

  /**
   * PlayerInventory findFirst
   */
  export type PlayerInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerInventory to fetch.
     */
    where?: PlayerInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerInventories to fetch.
     */
    orderBy?: PlayerInventoryOrderByWithRelationInput | PlayerInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerInventories.
     */
    cursor?: PlayerInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerInventories.
     */
    distinct?: PlayerInventoryScalarFieldEnum | PlayerInventoryScalarFieldEnum[]
  }

  /**
   * PlayerInventory findFirstOrThrow
   */
  export type PlayerInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerInventory to fetch.
     */
    where?: PlayerInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerInventories to fetch.
     */
    orderBy?: PlayerInventoryOrderByWithRelationInput | PlayerInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerInventories.
     */
    cursor?: PlayerInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerInventories.
     */
    distinct?: PlayerInventoryScalarFieldEnum | PlayerInventoryScalarFieldEnum[]
  }

  /**
   * PlayerInventory findMany
   */
  export type PlayerInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerInventories to fetch.
     */
    where?: PlayerInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerInventories to fetch.
     */
    orderBy?: PlayerInventoryOrderByWithRelationInput | PlayerInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerInventories.
     */
    cursor?: PlayerInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerInventories.
     */
    skip?: number
    distinct?: PlayerInventoryScalarFieldEnum | PlayerInventoryScalarFieldEnum[]
  }

  /**
   * PlayerInventory create
   */
  export type PlayerInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerInventory.
     */
    data: XOR<PlayerInventoryCreateInput, PlayerInventoryUncheckedCreateInput>
  }

  /**
   * PlayerInventory createMany
   */
  export type PlayerInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerInventories.
     */
    data: PlayerInventoryCreateManyInput | PlayerInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerInventory createManyAndReturn
   */
  export type PlayerInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerInventories.
     */
    data: PlayerInventoryCreateManyInput | PlayerInventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerInventory update
   */
  export type PlayerInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerInventory.
     */
    data: XOR<PlayerInventoryUpdateInput, PlayerInventoryUncheckedUpdateInput>
    /**
     * Choose, which PlayerInventory to update.
     */
    where: PlayerInventoryWhereUniqueInput
  }

  /**
   * PlayerInventory updateMany
   */
  export type PlayerInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerInventories.
     */
    data: XOR<PlayerInventoryUpdateManyMutationInput, PlayerInventoryUncheckedUpdateManyInput>
    /**
     * Filter which PlayerInventories to update
     */
    where?: PlayerInventoryWhereInput
  }

  /**
   * PlayerInventory upsert
   */
  export type PlayerInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerInventory to update in case it exists.
     */
    where: PlayerInventoryWhereUniqueInput
    /**
     * In case the PlayerInventory found by the `where` argument doesn't exist, create a new PlayerInventory with this data.
     */
    create: XOR<PlayerInventoryCreateInput, PlayerInventoryUncheckedCreateInput>
    /**
     * In case the PlayerInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerInventoryUpdateInput, PlayerInventoryUncheckedUpdateInput>
  }

  /**
   * PlayerInventory delete
   */
  export type PlayerInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
    /**
     * Filter which PlayerInventory to delete.
     */
    where: PlayerInventoryWhereUniqueInput
  }

  /**
   * PlayerInventory deleteMany
   */
  export type PlayerInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerInventories to delete
     */
    where?: PlayerInventoryWhereInput
  }

  /**
   * PlayerInventory without action
   */
  export type PlayerInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerInventory
     */
    select?: PlayerInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInventoryInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model SkillDecayLog
   */

  export type AggregateSkillDecayLog = {
    _count: SkillDecayLogCountAggregateOutputType | null
    _avg: SkillDecayLogAvgAggregateOutputType | null
    _sum: SkillDecayLogSumAggregateOutputType | null
    _min: SkillDecayLogMinAggregateOutputType | null
    _max: SkillDecayLogMaxAggregateOutputType | null
  }

  export type SkillDecayLogAvgAggregateOutputType = {
    original_value: number | null
    new_value: number | null
    decay_amount: number | null
    days_since_last_practice: number | null
  }

  export type SkillDecayLogSumAggregateOutputType = {
    original_value: number | null
    new_value: number | null
    decay_amount: number | null
    days_since_last_practice: number | null
  }

  export type SkillDecayLogMinAggregateOutputType = {
    id: string | null
    character_id: string | null
    skill_type: string | null
    knowledge_name: string | null
    event_type: string | null
    original_value: number | null
    new_value: number | null
    decay_amount: number | null
    days_since_last_practice: number | null
    action: string | null
    timestamp: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SkillDecayLogMaxAggregateOutputType = {
    id: string | null
    character_id: string | null
    skill_type: string | null
    knowledge_name: string | null
    event_type: string | null
    original_value: number | null
    new_value: number | null
    decay_amount: number | null
    days_since_last_practice: number | null
    action: string | null
    timestamp: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SkillDecayLogCountAggregateOutputType = {
    id: number
    character_id: number
    skill_type: number
    knowledge_name: number
    event_type: number
    original_value: number
    new_value: number
    decay_amount: number
    days_since_last_practice: number
    action: number
    timestamp: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SkillDecayLogAvgAggregateInputType = {
    original_value?: true
    new_value?: true
    decay_amount?: true
    days_since_last_practice?: true
  }

  export type SkillDecayLogSumAggregateInputType = {
    original_value?: true
    new_value?: true
    decay_amount?: true
    days_since_last_practice?: true
  }

  export type SkillDecayLogMinAggregateInputType = {
    id?: true
    character_id?: true
    skill_type?: true
    knowledge_name?: true
    event_type?: true
    original_value?: true
    new_value?: true
    decay_amount?: true
    days_since_last_practice?: true
    action?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
  }

  export type SkillDecayLogMaxAggregateInputType = {
    id?: true
    character_id?: true
    skill_type?: true
    knowledge_name?: true
    event_type?: true
    original_value?: true
    new_value?: true
    decay_amount?: true
    days_since_last_practice?: true
    action?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
  }

  export type SkillDecayLogCountAggregateInputType = {
    id?: true
    character_id?: true
    skill_type?: true
    knowledge_name?: true
    event_type?: true
    original_value?: true
    new_value?: true
    decay_amount?: true
    days_since_last_practice?: true
    action?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SkillDecayLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillDecayLog to aggregate.
     */
    where?: SkillDecayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillDecayLogs to fetch.
     */
    orderBy?: SkillDecayLogOrderByWithRelationInput | SkillDecayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillDecayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillDecayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillDecayLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillDecayLogs
    **/
    _count?: true | SkillDecayLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillDecayLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillDecayLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillDecayLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillDecayLogMaxAggregateInputType
  }

  export type GetSkillDecayLogAggregateType<T extends SkillDecayLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillDecayLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillDecayLog[P]>
      : GetScalarType<T[P], AggregateSkillDecayLog[P]>
  }




  export type SkillDecayLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillDecayLogWhereInput
    orderBy?: SkillDecayLogOrderByWithAggregationInput | SkillDecayLogOrderByWithAggregationInput[]
    by: SkillDecayLogScalarFieldEnum[] | SkillDecayLogScalarFieldEnum
    having?: SkillDecayLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillDecayLogCountAggregateInputType | true
    _avg?: SkillDecayLogAvgAggregateInputType
    _sum?: SkillDecayLogSumAggregateInputType
    _min?: SkillDecayLogMinAggregateInputType
    _max?: SkillDecayLogMaxAggregateInputType
  }

  export type SkillDecayLogGroupByOutputType = {
    id: string
    character_id: string
    skill_type: string
    knowledge_name: string
    event_type: string
    original_value: number
    new_value: number
    decay_amount: number
    days_since_last_practice: number
    action: string | null
    timestamp: Date
    created_at: Date
    updated_at: Date
    _count: SkillDecayLogCountAggregateOutputType | null
    _avg: SkillDecayLogAvgAggregateOutputType | null
    _sum: SkillDecayLogSumAggregateOutputType | null
    _min: SkillDecayLogMinAggregateOutputType | null
    _max: SkillDecayLogMaxAggregateOutputType | null
  }

  type GetSkillDecayLogGroupByPayload<T extends SkillDecayLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillDecayLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillDecayLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillDecayLogGroupByOutputType[P]>
            : GetScalarType<T[P], SkillDecayLogGroupByOutputType[P]>
        }
      >
    >


  export type SkillDecayLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    character_id?: boolean
    skill_type?: boolean
    knowledge_name?: boolean
    event_type?: boolean
    original_value?: boolean
    new_value?: boolean
    decay_amount?: boolean
    days_since_last_practice?: boolean
    action?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["skillDecayLog"]>

  export type SkillDecayLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    character_id?: boolean
    skill_type?: boolean
    knowledge_name?: boolean
    event_type?: boolean
    original_value?: boolean
    new_value?: boolean
    decay_amount?: boolean
    days_since_last_practice?: boolean
    action?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["skillDecayLog"]>

  export type SkillDecayLogSelectScalar = {
    id?: boolean
    character_id?: boolean
    skill_type?: boolean
    knowledge_name?: boolean
    event_type?: boolean
    original_value?: boolean
    new_value?: boolean
    decay_amount?: boolean
    days_since_last_practice?: boolean
    action?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $SkillDecayLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillDecayLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      character_id: string
      skill_type: string
      knowledge_name: string
      event_type: string
      original_value: number
      new_value: number
      decay_amount: number
      days_since_last_practice: number
      action: string | null
      timestamp: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["skillDecayLog"]>
    composites: {}
  }

  type SkillDecayLogGetPayload<S extends boolean | null | undefined | SkillDecayLogDefaultArgs> = $Result.GetResult<Prisma.$SkillDecayLogPayload, S>

  type SkillDecayLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillDecayLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillDecayLogCountAggregateInputType | true
    }

  export interface SkillDecayLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillDecayLog'], meta: { name: 'SkillDecayLog' } }
    /**
     * Find zero or one SkillDecayLog that matches the filter.
     * @param {SkillDecayLogFindUniqueArgs} args - Arguments to find a SkillDecayLog
     * @example
     * // Get one SkillDecayLog
     * const skillDecayLog = await prisma.skillDecayLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillDecayLogFindUniqueArgs>(args: SelectSubset<T, SkillDecayLogFindUniqueArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkillDecayLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillDecayLogFindUniqueOrThrowArgs} args - Arguments to find a SkillDecayLog
     * @example
     * // Get one SkillDecayLog
     * const skillDecayLog = await prisma.skillDecayLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillDecayLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillDecayLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkillDecayLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogFindFirstArgs} args - Arguments to find a SkillDecayLog
     * @example
     * // Get one SkillDecayLog
     * const skillDecayLog = await prisma.skillDecayLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillDecayLogFindFirstArgs>(args?: SelectSubset<T, SkillDecayLogFindFirstArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkillDecayLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogFindFirstOrThrowArgs} args - Arguments to find a SkillDecayLog
     * @example
     * // Get one SkillDecayLog
     * const skillDecayLog = await prisma.skillDecayLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillDecayLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillDecayLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkillDecayLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillDecayLogs
     * const skillDecayLogs = await prisma.skillDecayLog.findMany()
     * 
     * // Get first 10 SkillDecayLogs
     * const skillDecayLogs = await prisma.skillDecayLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillDecayLogWithIdOnly = await prisma.skillDecayLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillDecayLogFindManyArgs>(args?: SelectSubset<T, SkillDecayLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkillDecayLog.
     * @param {SkillDecayLogCreateArgs} args - Arguments to create a SkillDecayLog.
     * @example
     * // Create one SkillDecayLog
     * const SkillDecayLog = await prisma.skillDecayLog.create({
     *   data: {
     *     // ... data to create a SkillDecayLog
     *   }
     * })
     * 
     */
    create<T extends SkillDecayLogCreateArgs>(args: SelectSubset<T, SkillDecayLogCreateArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkillDecayLogs.
     * @param {SkillDecayLogCreateManyArgs} args - Arguments to create many SkillDecayLogs.
     * @example
     * // Create many SkillDecayLogs
     * const skillDecayLog = await prisma.skillDecayLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillDecayLogCreateManyArgs>(args?: SelectSubset<T, SkillDecayLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillDecayLogs and returns the data saved in the database.
     * @param {SkillDecayLogCreateManyAndReturnArgs} args - Arguments to create many SkillDecayLogs.
     * @example
     * // Create many SkillDecayLogs
     * const skillDecayLog = await prisma.skillDecayLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillDecayLogs and only return the `id`
     * const skillDecayLogWithIdOnly = await prisma.skillDecayLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillDecayLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillDecayLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkillDecayLog.
     * @param {SkillDecayLogDeleteArgs} args - Arguments to delete one SkillDecayLog.
     * @example
     * // Delete one SkillDecayLog
     * const SkillDecayLog = await prisma.skillDecayLog.delete({
     *   where: {
     *     // ... filter to delete one SkillDecayLog
     *   }
     * })
     * 
     */
    delete<T extends SkillDecayLogDeleteArgs>(args: SelectSubset<T, SkillDecayLogDeleteArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkillDecayLog.
     * @param {SkillDecayLogUpdateArgs} args - Arguments to update one SkillDecayLog.
     * @example
     * // Update one SkillDecayLog
     * const skillDecayLog = await prisma.skillDecayLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillDecayLogUpdateArgs>(args: SelectSubset<T, SkillDecayLogUpdateArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkillDecayLogs.
     * @param {SkillDecayLogDeleteManyArgs} args - Arguments to filter SkillDecayLogs to delete.
     * @example
     * // Delete a few SkillDecayLogs
     * const { count } = await prisma.skillDecayLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDecayLogDeleteManyArgs>(args?: SelectSubset<T, SkillDecayLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillDecayLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillDecayLogs
     * const skillDecayLog = await prisma.skillDecayLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillDecayLogUpdateManyArgs>(args: SelectSubset<T, SkillDecayLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillDecayLog.
     * @param {SkillDecayLogUpsertArgs} args - Arguments to update or create a SkillDecayLog.
     * @example
     * // Update or create a SkillDecayLog
     * const skillDecayLog = await prisma.skillDecayLog.upsert({
     *   create: {
     *     // ... data to create a SkillDecayLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillDecayLog we want to update
     *   }
     * })
     */
    upsert<T extends SkillDecayLogUpsertArgs>(args: SelectSubset<T, SkillDecayLogUpsertArgs<ExtArgs>>): Prisma__SkillDecayLogClient<$Result.GetResult<Prisma.$SkillDecayLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkillDecayLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogCountArgs} args - Arguments to filter SkillDecayLogs to count.
     * @example
     * // Count the number of SkillDecayLogs
     * const count = await prisma.skillDecayLog.count({
     *   where: {
     *     // ... the filter for the SkillDecayLogs we want to count
     *   }
     * })
    **/
    count<T extends SkillDecayLogCountArgs>(
      args?: Subset<T, SkillDecayLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillDecayLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillDecayLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillDecayLogAggregateArgs>(args: Subset<T, SkillDecayLogAggregateArgs>): Prisma.PrismaPromise<GetSkillDecayLogAggregateType<T>>

    /**
     * Group by SkillDecayLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillDecayLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillDecayLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillDecayLogGroupByArgs['orderBy'] }
        : { orderBy?: SkillDecayLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillDecayLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillDecayLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillDecayLog model
   */
  readonly fields: SkillDecayLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillDecayLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillDecayLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillDecayLog model
   */ 
  interface SkillDecayLogFieldRefs {
    readonly id: FieldRef<"SkillDecayLog", 'String'>
    readonly character_id: FieldRef<"SkillDecayLog", 'String'>
    readonly skill_type: FieldRef<"SkillDecayLog", 'String'>
    readonly knowledge_name: FieldRef<"SkillDecayLog", 'String'>
    readonly event_type: FieldRef<"SkillDecayLog", 'String'>
    readonly original_value: FieldRef<"SkillDecayLog", 'Int'>
    readonly new_value: FieldRef<"SkillDecayLog", 'Int'>
    readonly decay_amount: FieldRef<"SkillDecayLog", 'Int'>
    readonly days_since_last_practice: FieldRef<"SkillDecayLog", 'Int'>
    readonly action: FieldRef<"SkillDecayLog", 'String'>
    readonly timestamp: FieldRef<"SkillDecayLog", 'DateTime'>
    readonly created_at: FieldRef<"SkillDecayLog", 'DateTime'>
    readonly updated_at: FieldRef<"SkillDecayLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkillDecayLog findUnique
   */
  export type SkillDecayLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * Filter, which SkillDecayLog to fetch.
     */
    where: SkillDecayLogWhereUniqueInput
  }

  /**
   * SkillDecayLog findUniqueOrThrow
   */
  export type SkillDecayLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * Filter, which SkillDecayLog to fetch.
     */
    where: SkillDecayLogWhereUniqueInput
  }

  /**
   * SkillDecayLog findFirst
   */
  export type SkillDecayLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * Filter, which SkillDecayLog to fetch.
     */
    where?: SkillDecayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillDecayLogs to fetch.
     */
    orderBy?: SkillDecayLogOrderByWithRelationInput | SkillDecayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillDecayLogs.
     */
    cursor?: SkillDecayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillDecayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillDecayLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillDecayLogs.
     */
    distinct?: SkillDecayLogScalarFieldEnum | SkillDecayLogScalarFieldEnum[]
  }

  /**
   * SkillDecayLog findFirstOrThrow
   */
  export type SkillDecayLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * Filter, which SkillDecayLog to fetch.
     */
    where?: SkillDecayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillDecayLogs to fetch.
     */
    orderBy?: SkillDecayLogOrderByWithRelationInput | SkillDecayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillDecayLogs.
     */
    cursor?: SkillDecayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillDecayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillDecayLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillDecayLogs.
     */
    distinct?: SkillDecayLogScalarFieldEnum | SkillDecayLogScalarFieldEnum[]
  }

  /**
   * SkillDecayLog findMany
   */
  export type SkillDecayLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * Filter, which SkillDecayLogs to fetch.
     */
    where?: SkillDecayLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillDecayLogs to fetch.
     */
    orderBy?: SkillDecayLogOrderByWithRelationInput | SkillDecayLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillDecayLogs.
     */
    cursor?: SkillDecayLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillDecayLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillDecayLogs.
     */
    skip?: number
    distinct?: SkillDecayLogScalarFieldEnum | SkillDecayLogScalarFieldEnum[]
  }

  /**
   * SkillDecayLog create
   */
  export type SkillDecayLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * The data needed to create a SkillDecayLog.
     */
    data: XOR<SkillDecayLogCreateInput, SkillDecayLogUncheckedCreateInput>
  }

  /**
   * SkillDecayLog createMany
   */
  export type SkillDecayLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillDecayLogs.
     */
    data: SkillDecayLogCreateManyInput | SkillDecayLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillDecayLog createManyAndReturn
   */
  export type SkillDecayLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkillDecayLogs.
     */
    data: SkillDecayLogCreateManyInput | SkillDecayLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillDecayLog update
   */
  export type SkillDecayLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * The data needed to update a SkillDecayLog.
     */
    data: XOR<SkillDecayLogUpdateInput, SkillDecayLogUncheckedUpdateInput>
    /**
     * Choose, which SkillDecayLog to update.
     */
    where: SkillDecayLogWhereUniqueInput
  }

  /**
   * SkillDecayLog updateMany
   */
  export type SkillDecayLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillDecayLogs.
     */
    data: XOR<SkillDecayLogUpdateManyMutationInput, SkillDecayLogUncheckedUpdateManyInput>
    /**
     * Filter which SkillDecayLogs to update
     */
    where?: SkillDecayLogWhereInput
  }

  /**
   * SkillDecayLog upsert
   */
  export type SkillDecayLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * The filter to search for the SkillDecayLog to update in case it exists.
     */
    where: SkillDecayLogWhereUniqueInput
    /**
     * In case the SkillDecayLog found by the `where` argument doesn't exist, create a new SkillDecayLog with this data.
     */
    create: XOR<SkillDecayLogCreateInput, SkillDecayLogUncheckedCreateInput>
    /**
     * In case the SkillDecayLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillDecayLogUpdateInput, SkillDecayLogUncheckedUpdateInput>
  }

  /**
   * SkillDecayLog delete
   */
  export type SkillDecayLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
    /**
     * Filter which SkillDecayLog to delete.
     */
    where: SkillDecayLogWhereUniqueInput
  }

  /**
   * SkillDecayLog deleteMany
   */
  export type SkillDecayLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillDecayLogs to delete
     */
    where?: SkillDecayLogWhereInput
  }

  /**
   * SkillDecayLog without action
   */
  export type SkillDecayLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillDecayLog
     */
    select?: SkillDecayLogSelect<ExtArgs> | null
  }


  /**
   * Model SkillPracticeHistory
   */

  export type AggregateSkillPracticeHistory = {
    _count: SkillPracticeHistoryCountAggregateOutputType | null
    _avg: SkillPracticeHistoryAvgAggregateOutputType | null
    _sum: SkillPracticeHistorySumAggregateOutputType | null
    _min: SkillPracticeHistoryMinAggregateOutputType | null
    _max: SkillPracticeHistoryMaxAggregateOutputType | null
  }

  export type SkillPracticeHistoryAvgAggregateOutputType = {
    experience_gained: number | null
    proficiency_gained: number | null
  }

  export type SkillPracticeHistorySumAggregateOutputType = {
    experience_gained: number | null
    proficiency_gained: number | null
  }

  export type SkillPracticeHistoryMinAggregateOutputType = {
    id: string | null
    skill_id: string | null
    practice_type: string | null
    practice_intensity: string | null
    experience_gained: number | null
    proficiency_gained: number | null
    knowledge_used: string | null
    timestamp: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SkillPracticeHistoryMaxAggregateOutputType = {
    id: string | null
    skill_id: string | null
    practice_type: string | null
    practice_intensity: string | null
    experience_gained: number | null
    proficiency_gained: number | null
    knowledge_used: string | null
    timestamp: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SkillPracticeHistoryCountAggregateOutputType = {
    id: number
    skill_id: number
    practice_type: number
    practice_intensity: number
    experience_gained: number
    proficiency_gained: number
    knowledge_used: number
    timestamp: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SkillPracticeHistoryAvgAggregateInputType = {
    experience_gained?: true
    proficiency_gained?: true
  }

  export type SkillPracticeHistorySumAggregateInputType = {
    experience_gained?: true
    proficiency_gained?: true
  }

  export type SkillPracticeHistoryMinAggregateInputType = {
    id?: true
    skill_id?: true
    practice_type?: true
    practice_intensity?: true
    experience_gained?: true
    proficiency_gained?: true
    knowledge_used?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
  }

  export type SkillPracticeHistoryMaxAggregateInputType = {
    id?: true
    skill_id?: true
    practice_type?: true
    practice_intensity?: true
    experience_gained?: true
    proficiency_gained?: true
    knowledge_used?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
  }

  export type SkillPracticeHistoryCountAggregateInputType = {
    id?: true
    skill_id?: true
    practice_type?: true
    practice_intensity?: true
    experience_gained?: true
    proficiency_gained?: true
    knowledge_used?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SkillPracticeHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillPracticeHistory to aggregate.
     */
    where?: SkillPracticeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPracticeHistories to fetch.
     */
    orderBy?: SkillPracticeHistoryOrderByWithRelationInput | SkillPracticeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillPracticeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPracticeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPracticeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillPracticeHistories
    **/
    _count?: true | SkillPracticeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillPracticeHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillPracticeHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillPracticeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillPracticeHistoryMaxAggregateInputType
  }

  export type GetSkillPracticeHistoryAggregateType<T extends SkillPracticeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillPracticeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillPracticeHistory[P]>
      : GetScalarType<T[P], AggregateSkillPracticeHistory[P]>
  }




  export type SkillPracticeHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillPracticeHistoryWhereInput
    orderBy?: SkillPracticeHistoryOrderByWithAggregationInput | SkillPracticeHistoryOrderByWithAggregationInput[]
    by: SkillPracticeHistoryScalarFieldEnum[] | SkillPracticeHistoryScalarFieldEnum
    having?: SkillPracticeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillPracticeHistoryCountAggregateInputType | true
    _avg?: SkillPracticeHistoryAvgAggregateInputType
    _sum?: SkillPracticeHistorySumAggregateInputType
    _min?: SkillPracticeHistoryMinAggregateInputType
    _max?: SkillPracticeHistoryMaxAggregateInputType
  }

  export type SkillPracticeHistoryGroupByOutputType = {
    id: string
    skill_id: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used: string | null
    timestamp: Date
    created_at: Date
    updated_at: Date
    _count: SkillPracticeHistoryCountAggregateOutputType | null
    _avg: SkillPracticeHistoryAvgAggregateOutputType | null
    _sum: SkillPracticeHistorySumAggregateOutputType | null
    _min: SkillPracticeHistoryMinAggregateOutputType | null
    _max: SkillPracticeHistoryMaxAggregateOutputType | null
  }

  type GetSkillPracticeHistoryGroupByPayload<T extends SkillPracticeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillPracticeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillPracticeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillPracticeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SkillPracticeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SkillPracticeHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skill_id?: boolean
    practice_type?: boolean
    practice_intensity?: boolean
    experience_gained?: boolean
    proficiency_gained?: boolean
    knowledge_used?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
    character_skills?: boolean | CharacterSkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillPracticeHistory"]>

  export type SkillPracticeHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skill_id?: boolean
    practice_type?: boolean
    practice_intensity?: boolean
    experience_gained?: boolean
    proficiency_gained?: boolean
    knowledge_used?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
    character_skills?: boolean | CharacterSkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillPracticeHistory"]>

  export type SkillPracticeHistorySelectScalar = {
    id?: boolean
    skill_id?: boolean
    practice_type?: boolean
    practice_intensity?: boolean
    experience_gained?: boolean
    proficiency_gained?: boolean
    knowledge_used?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SkillPracticeHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_skills?: boolean | CharacterSkillDefaultArgs<ExtArgs>
  }
  export type SkillPracticeHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_skills?: boolean | CharacterSkillDefaultArgs<ExtArgs>
  }

  export type $SkillPracticeHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillPracticeHistory"
    objects: {
      character_skills: Prisma.$CharacterSkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skill_id: string
      practice_type: string
      practice_intensity: string
      experience_gained: number
      proficiency_gained: number
      knowledge_used: string | null
      timestamp: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["skillPracticeHistory"]>
    composites: {}
  }

  type SkillPracticeHistoryGetPayload<S extends boolean | null | undefined | SkillPracticeHistoryDefaultArgs> = $Result.GetResult<Prisma.$SkillPracticeHistoryPayload, S>

  type SkillPracticeHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillPracticeHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillPracticeHistoryCountAggregateInputType | true
    }

  export interface SkillPracticeHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillPracticeHistory'], meta: { name: 'SkillPracticeHistory' } }
    /**
     * Find zero or one SkillPracticeHistory that matches the filter.
     * @param {SkillPracticeHistoryFindUniqueArgs} args - Arguments to find a SkillPracticeHistory
     * @example
     * // Get one SkillPracticeHistory
     * const skillPracticeHistory = await prisma.skillPracticeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillPracticeHistoryFindUniqueArgs>(args: SelectSubset<T, SkillPracticeHistoryFindUniqueArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkillPracticeHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillPracticeHistoryFindUniqueOrThrowArgs} args - Arguments to find a SkillPracticeHistory
     * @example
     * // Get one SkillPracticeHistory
     * const skillPracticeHistory = await prisma.skillPracticeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillPracticeHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillPracticeHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkillPracticeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryFindFirstArgs} args - Arguments to find a SkillPracticeHistory
     * @example
     * // Get one SkillPracticeHistory
     * const skillPracticeHistory = await prisma.skillPracticeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillPracticeHistoryFindFirstArgs>(args?: SelectSubset<T, SkillPracticeHistoryFindFirstArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkillPracticeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryFindFirstOrThrowArgs} args - Arguments to find a SkillPracticeHistory
     * @example
     * // Get one SkillPracticeHistory
     * const skillPracticeHistory = await prisma.skillPracticeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillPracticeHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillPracticeHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkillPracticeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillPracticeHistories
     * const skillPracticeHistories = await prisma.skillPracticeHistory.findMany()
     * 
     * // Get first 10 SkillPracticeHistories
     * const skillPracticeHistories = await prisma.skillPracticeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillPracticeHistoryWithIdOnly = await prisma.skillPracticeHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillPracticeHistoryFindManyArgs>(args?: SelectSubset<T, SkillPracticeHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkillPracticeHistory.
     * @param {SkillPracticeHistoryCreateArgs} args - Arguments to create a SkillPracticeHistory.
     * @example
     * // Create one SkillPracticeHistory
     * const SkillPracticeHistory = await prisma.skillPracticeHistory.create({
     *   data: {
     *     // ... data to create a SkillPracticeHistory
     *   }
     * })
     * 
     */
    create<T extends SkillPracticeHistoryCreateArgs>(args: SelectSubset<T, SkillPracticeHistoryCreateArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkillPracticeHistories.
     * @param {SkillPracticeHistoryCreateManyArgs} args - Arguments to create many SkillPracticeHistories.
     * @example
     * // Create many SkillPracticeHistories
     * const skillPracticeHistory = await prisma.skillPracticeHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillPracticeHistoryCreateManyArgs>(args?: SelectSubset<T, SkillPracticeHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillPracticeHistories and returns the data saved in the database.
     * @param {SkillPracticeHistoryCreateManyAndReturnArgs} args - Arguments to create many SkillPracticeHistories.
     * @example
     * // Create many SkillPracticeHistories
     * const skillPracticeHistory = await prisma.skillPracticeHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillPracticeHistories and only return the `id`
     * const skillPracticeHistoryWithIdOnly = await prisma.skillPracticeHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillPracticeHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillPracticeHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkillPracticeHistory.
     * @param {SkillPracticeHistoryDeleteArgs} args - Arguments to delete one SkillPracticeHistory.
     * @example
     * // Delete one SkillPracticeHistory
     * const SkillPracticeHistory = await prisma.skillPracticeHistory.delete({
     *   where: {
     *     // ... filter to delete one SkillPracticeHistory
     *   }
     * })
     * 
     */
    delete<T extends SkillPracticeHistoryDeleteArgs>(args: SelectSubset<T, SkillPracticeHistoryDeleteArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkillPracticeHistory.
     * @param {SkillPracticeHistoryUpdateArgs} args - Arguments to update one SkillPracticeHistory.
     * @example
     * // Update one SkillPracticeHistory
     * const skillPracticeHistory = await prisma.skillPracticeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillPracticeHistoryUpdateArgs>(args: SelectSubset<T, SkillPracticeHistoryUpdateArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkillPracticeHistories.
     * @param {SkillPracticeHistoryDeleteManyArgs} args - Arguments to filter SkillPracticeHistories to delete.
     * @example
     * // Delete a few SkillPracticeHistories
     * const { count } = await prisma.skillPracticeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillPracticeHistoryDeleteManyArgs>(args?: SelectSubset<T, SkillPracticeHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillPracticeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillPracticeHistories
     * const skillPracticeHistory = await prisma.skillPracticeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillPracticeHistoryUpdateManyArgs>(args: SelectSubset<T, SkillPracticeHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillPracticeHistory.
     * @param {SkillPracticeHistoryUpsertArgs} args - Arguments to update or create a SkillPracticeHistory.
     * @example
     * // Update or create a SkillPracticeHistory
     * const skillPracticeHistory = await prisma.skillPracticeHistory.upsert({
     *   create: {
     *     // ... data to create a SkillPracticeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillPracticeHistory we want to update
     *   }
     * })
     */
    upsert<T extends SkillPracticeHistoryUpsertArgs>(args: SelectSubset<T, SkillPracticeHistoryUpsertArgs<ExtArgs>>): Prisma__SkillPracticeHistoryClient<$Result.GetResult<Prisma.$SkillPracticeHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkillPracticeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryCountArgs} args - Arguments to filter SkillPracticeHistories to count.
     * @example
     * // Count the number of SkillPracticeHistories
     * const count = await prisma.skillPracticeHistory.count({
     *   where: {
     *     // ... the filter for the SkillPracticeHistories we want to count
     *   }
     * })
    **/
    count<T extends SkillPracticeHistoryCountArgs>(
      args?: Subset<T, SkillPracticeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillPracticeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillPracticeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillPracticeHistoryAggregateArgs>(args: Subset<T, SkillPracticeHistoryAggregateArgs>): Prisma.PrismaPromise<GetSkillPracticeHistoryAggregateType<T>>

    /**
     * Group by SkillPracticeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillPracticeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillPracticeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillPracticeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SkillPracticeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillPracticeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillPracticeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillPracticeHistory model
   */
  readonly fields: SkillPracticeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillPracticeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillPracticeHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_skills<T extends CharacterSkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterSkillDefaultArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillPracticeHistory model
   */ 
  interface SkillPracticeHistoryFieldRefs {
    readonly id: FieldRef<"SkillPracticeHistory", 'String'>
    readonly skill_id: FieldRef<"SkillPracticeHistory", 'String'>
    readonly practice_type: FieldRef<"SkillPracticeHistory", 'String'>
    readonly practice_intensity: FieldRef<"SkillPracticeHistory", 'String'>
    readonly experience_gained: FieldRef<"SkillPracticeHistory", 'Int'>
    readonly proficiency_gained: FieldRef<"SkillPracticeHistory", 'Int'>
    readonly knowledge_used: FieldRef<"SkillPracticeHistory", 'String'>
    readonly timestamp: FieldRef<"SkillPracticeHistory", 'DateTime'>
    readonly created_at: FieldRef<"SkillPracticeHistory", 'DateTime'>
    readonly updated_at: FieldRef<"SkillPracticeHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkillPracticeHistory findUnique
   */
  export type SkillPracticeHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillPracticeHistory to fetch.
     */
    where: SkillPracticeHistoryWhereUniqueInput
  }

  /**
   * SkillPracticeHistory findUniqueOrThrow
   */
  export type SkillPracticeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillPracticeHistory to fetch.
     */
    where: SkillPracticeHistoryWhereUniqueInput
  }

  /**
   * SkillPracticeHistory findFirst
   */
  export type SkillPracticeHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillPracticeHistory to fetch.
     */
    where?: SkillPracticeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPracticeHistories to fetch.
     */
    orderBy?: SkillPracticeHistoryOrderByWithRelationInput | SkillPracticeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillPracticeHistories.
     */
    cursor?: SkillPracticeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPracticeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPracticeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillPracticeHistories.
     */
    distinct?: SkillPracticeHistoryScalarFieldEnum | SkillPracticeHistoryScalarFieldEnum[]
  }

  /**
   * SkillPracticeHistory findFirstOrThrow
   */
  export type SkillPracticeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillPracticeHistory to fetch.
     */
    where?: SkillPracticeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPracticeHistories to fetch.
     */
    orderBy?: SkillPracticeHistoryOrderByWithRelationInput | SkillPracticeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillPracticeHistories.
     */
    cursor?: SkillPracticeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPracticeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPracticeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillPracticeHistories.
     */
    distinct?: SkillPracticeHistoryScalarFieldEnum | SkillPracticeHistoryScalarFieldEnum[]
  }

  /**
   * SkillPracticeHistory findMany
   */
  export type SkillPracticeHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SkillPracticeHistories to fetch.
     */
    where?: SkillPracticeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillPracticeHistories to fetch.
     */
    orderBy?: SkillPracticeHistoryOrderByWithRelationInput | SkillPracticeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillPracticeHistories.
     */
    cursor?: SkillPracticeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillPracticeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillPracticeHistories.
     */
    skip?: number
    distinct?: SkillPracticeHistoryScalarFieldEnum | SkillPracticeHistoryScalarFieldEnum[]
  }

  /**
   * SkillPracticeHistory create
   */
  export type SkillPracticeHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillPracticeHistory.
     */
    data: XOR<SkillPracticeHistoryCreateInput, SkillPracticeHistoryUncheckedCreateInput>
  }

  /**
   * SkillPracticeHistory createMany
   */
  export type SkillPracticeHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillPracticeHistories.
     */
    data: SkillPracticeHistoryCreateManyInput | SkillPracticeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillPracticeHistory createManyAndReturn
   */
  export type SkillPracticeHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkillPracticeHistories.
     */
    data: SkillPracticeHistoryCreateManyInput | SkillPracticeHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillPracticeHistory update
   */
  export type SkillPracticeHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillPracticeHistory.
     */
    data: XOR<SkillPracticeHistoryUpdateInput, SkillPracticeHistoryUncheckedUpdateInput>
    /**
     * Choose, which SkillPracticeHistory to update.
     */
    where: SkillPracticeHistoryWhereUniqueInput
  }

  /**
   * SkillPracticeHistory updateMany
   */
  export type SkillPracticeHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillPracticeHistories.
     */
    data: XOR<SkillPracticeHistoryUpdateManyMutationInput, SkillPracticeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SkillPracticeHistories to update
     */
    where?: SkillPracticeHistoryWhereInput
  }

  /**
   * SkillPracticeHistory upsert
   */
  export type SkillPracticeHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillPracticeHistory to update in case it exists.
     */
    where: SkillPracticeHistoryWhereUniqueInput
    /**
     * In case the SkillPracticeHistory found by the `where` argument doesn't exist, create a new SkillPracticeHistory with this data.
     */
    create: XOR<SkillPracticeHistoryCreateInput, SkillPracticeHistoryUncheckedCreateInput>
    /**
     * In case the SkillPracticeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillPracticeHistoryUpdateInput, SkillPracticeHistoryUncheckedUpdateInput>
  }

  /**
   * SkillPracticeHistory delete
   */
  export type SkillPracticeHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
    /**
     * Filter which SkillPracticeHistory to delete.
     */
    where: SkillPracticeHistoryWhereUniqueInput
  }

  /**
   * SkillPracticeHistory deleteMany
   */
  export type SkillPracticeHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillPracticeHistories to delete
     */
    where?: SkillPracticeHistoryWhereInput
  }

  /**
   * SkillPracticeHistory without action
   */
  export type SkillPracticeHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillPracticeHistory
     */
    select?: SkillPracticeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillPracticeHistoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    username: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    username?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    username?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    username: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    account?: boolean | User$accountArgs<ExtArgs>
    gameCharacters?: boolean | User$gameCharactersArgs<ExtArgs>
    session?: boolean | User$sessionArgs<ExtArgs>
    userEmails?: boolean | User$userEmailsArgs<ExtArgs>
    userProfile?: boolean | User$userProfileArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    userPresence?: boolean | User$userPresenceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | User$accountArgs<ExtArgs>
    gameCharacters?: boolean | User$gameCharactersArgs<ExtArgs>
    session?: boolean | User$sessionArgs<ExtArgs>
    userEmails?: boolean | User$userEmailsArgs<ExtArgs>
    userProfile?: boolean | User$userProfileArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    userPresence?: boolean | User$userPresenceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>[]
      gameCharacters: Prisma.$GameCharacterPayload<ExtArgs> | null
      session: Prisma.$SessionPayload<ExtArgs>[]
      userEmails: Prisma.$UserEmailPayload<ExtArgs>[]
      userProfile: Prisma.$UserProfilePayload<ExtArgs> | null
      userSettings: Prisma.$UserSettingsPayload<ExtArgs> | null
      userPresence: Prisma.$UserPresencePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      username: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    gameCharacters<T extends User$gameCharactersArgs<ExtArgs> = {}>(args?: Subset<T, User$gameCharactersArgs<ExtArgs>>): Prisma__GameCharacterClient<$Result.GetResult<Prisma.$GameCharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    session<T extends User$sessionArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    userEmails<T extends User$userEmailsArgs<ExtArgs> = {}>(args?: Subset<T, User$userEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findMany"> | Null>
    userProfile<T extends User$userProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$userProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userSettings<T extends User$userSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userPresence<T extends User$userPresenceArgs<ExtArgs> = {}>(args?: Subset<T, User$userPresenceArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.account
   */
  export type User$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.gameCharacters
   */
  export type User$gameCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCharacter
     */
    select?: GameCharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameCharacterInclude<ExtArgs> | null
    where?: GameCharacterWhereInput
  }

  /**
   * User.session
   */
  export type User$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.userEmails
   */
  export type User$userEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    where?: UserEmailWhereInput
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    cursor?: UserEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * User.userProfile
   */
  export type User$userProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.userSettings
   */
  export type User$userSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.userPresence
   */
  export type User$userPresenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    where?: UserPresenceWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserEmail
   */

  export type AggregateUserEmail = {
    _count: UserEmailCountAggregateOutputType | null
    _min: UserEmailMinAggregateOutputType | null
    _max: UserEmailMaxAggregateOutputType | null
  }

  export type UserEmailMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserEmailMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserEmailCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserEmailMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserEmailMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserEmailCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmail to aggregate.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEmails
    **/
    _count?: true | UserEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEmailMaxAggregateInputType
  }

  export type GetUserEmailAggregateType<T extends UserEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEmail[P]>
      : GetScalarType<T[P], AggregateUserEmail[P]>
  }




  export type UserEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEmailWhereInput
    orderBy?: UserEmailOrderByWithAggregationInput | UserEmailOrderByWithAggregationInput[]
    by: UserEmailScalarFieldEnum[] | UserEmailScalarFieldEnum
    having?: UserEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEmailCountAggregateInputType | true
    _min?: UserEmailMinAggregateInputType
    _max?: UserEmailMaxAggregateInputType
  }

  export type UserEmailGroupByOutputType = {
    id: string
    userId: string
    email: string
    label: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserEmailCountAggregateOutputType | null
    _min: UserEmailMinAggregateOutputType | null
    _max: UserEmailMaxAggregateOutputType | null
  }

  type GetUserEmailGroupByPayload<T extends UserEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEmailGroupByOutputType[P]>
            : GetScalarType<T[P], UserEmailGroupByOutputType[P]>
        }
      >
    >


  export type UserEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmail"]>

  export type UserEmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEmail"]>

  export type UserEmailSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserEmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEmail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      label: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userEmail"]>
    composites: {}
  }

  type UserEmailGetPayload<S extends boolean | null | undefined | UserEmailDefaultArgs> = $Result.GetResult<Prisma.$UserEmailPayload, S>

  type UserEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserEmailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserEmailCountAggregateInputType | true
    }

  export interface UserEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEmail'], meta: { name: 'UserEmail' } }
    /**
     * Find zero or one UserEmail that matches the filter.
     * @param {UserEmailFindUniqueArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEmailFindUniqueArgs>(args: SelectSubset<T, UserEmailFindUniqueArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserEmail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserEmailFindUniqueOrThrowArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindFirstArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEmailFindFirstArgs>(args?: SelectSubset<T, UserEmailFindFirstArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindFirstOrThrowArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEmails
     * const userEmails = await prisma.userEmail.findMany()
     * 
     * // Get first 10 UserEmails
     * const userEmails = await prisma.userEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEmailWithIdOnly = await prisma.userEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserEmailFindManyArgs>(args?: SelectSubset<T, UserEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserEmail.
     * @param {UserEmailCreateArgs} args - Arguments to create a UserEmail.
     * @example
     * // Create one UserEmail
     * const UserEmail = await prisma.userEmail.create({
     *   data: {
     *     // ... data to create a UserEmail
     *   }
     * })
     * 
     */
    create<T extends UserEmailCreateArgs>(args: SelectSubset<T, UserEmailCreateArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserEmails.
     * @param {UserEmailCreateManyArgs} args - Arguments to create many UserEmails.
     * @example
     * // Create many UserEmails
     * const userEmail = await prisma.userEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEmailCreateManyArgs>(args?: SelectSubset<T, UserEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEmails and returns the data saved in the database.
     * @param {UserEmailCreateManyAndReturnArgs} args - Arguments to create many UserEmails.
     * @example
     * // Create many UserEmails
     * const userEmail = await prisma.userEmail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEmails and only return the `id`
     * const userEmailWithIdOnly = await prisma.userEmail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEmailCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserEmail.
     * @param {UserEmailDeleteArgs} args - Arguments to delete one UserEmail.
     * @example
     * // Delete one UserEmail
     * const UserEmail = await prisma.userEmail.delete({
     *   where: {
     *     // ... filter to delete one UserEmail
     *   }
     * })
     * 
     */
    delete<T extends UserEmailDeleteArgs>(args: SelectSubset<T, UserEmailDeleteArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserEmail.
     * @param {UserEmailUpdateArgs} args - Arguments to update one UserEmail.
     * @example
     * // Update one UserEmail
     * const userEmail = await prisma.userEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEmailUpdateArgs>(args: SelectSubset<T, UserEmailUpdateArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserEmails.
     * @param {UserEmailDeleteManyArgs} args - Arguments to filter UserEmails to delete.
     * @example
     * // Delete a few UserEmails
     * const { count } = await prisma.userEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEmailDeleteManyArgs>(args?: SelectSubset<T, UserEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEmails
     * const userEmail = await prisma.userEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEmailUpdateManyArgs>(args: SelectSubset<T, UserEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserEmail.
     * @param {UserEmailUpsertArgs} args - Arguments to update or create a UserEmail.
     * @example
     * // Update or create a UserEmail
     * const userEmail = await prisma.userEmail.upsert({
     *   create: {
     *     // ... data to create a UserEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEmail we want to update
     *   }
     * })
     */
    upsert<T extends UserEmailUpsertArgs>(args: SelectSubset<T, UserEmailUpsertArgs<ExtArgs>>): Prisma__UserEmailClient<$Result.GetResult<Prisma.$UserEmailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailCountArgs} args - Arguments to filter UserEmails to count.
     * @example
     * // Count the number of UserEmails
     * const count = await prisma.userEmail.count({
     *   where: {
     *     // ... the filter for the UserEmails we want to count
     *   }
     * })
    **/
    count<T extends UserEmailCountArgs>(
      args?: Subset<T, UserEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEmailAggregateArgs>(args: Subset<T, UserEmailAggregateArgs>): Prisma.PrismaPromise<GetUserEmailAggregateType<T>>

    /**
     * Group by UserEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEmailGroupByArgs['orderBy'] }
        : { orderBy?: UserEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEmail model
   */
  readonly fields: UserEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEmail model
   */ 
  interface UserEmailFieldRefs {
    readonly id: FieldRef<"UserEmail", 'String'>
    readonly userId: FieldRef<"UserEmail", 'String'>
    readonly email: FieldRef<"UserEmail", 'String'>
    readonly label: FieldRef<"UserEmail", 'String'>
    readonly createdAt: FieldRef<"UserEmail", 'DateTime'>
    readonly updatedAt: FieldRef<"UserEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEmail findUnique
   */
  export type UserEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail findUniqueOrThrow
   */
  export type UserEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail findFirst
   */
  export type UserEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmails.
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmails.
     */
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * UserEmail findFirstOrThrow
   */
  export type UserEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmail to fetch.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmails.
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmails.
     */
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * UserEmail findMany
   */
  export type UserEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter, which UserEmails to fetch.
     */
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     */
    orderBy?: UserEmailOrderByWithRelationInput | UserEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEmails.
     */
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     */
    skip?: number
    distinct?: UserEmailScalarFieldEnum | UserEmailScalarFieldEnum[]
  }

  /**
   * UserEmail create
   */
  export type UserEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEmail.
     */
    data: XOR<UserEmailCreateInput, UserEmailUncheckedCreateInput>
  }

  /**
   * UserEmail createMany
   */
  export type UserEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEmails.
     */
    data: UserEmailCreateManyInput | UserEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEmail createManyAndReturn
   */
  export type UserEmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserEmails.
     */
    data: UserEmailCreateManyInput | UserEmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserEmail update
   */
  export type UserEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEmail.
     */
    data: XOR<UserEmailUpdateInput, UserEmailUncheckedUpdateInput>
    /**
     * Choose, which UserEmail to update.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail updateMany
   */
  export type UserEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEmails.
     */
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyInput>
    /**
     * Filter which UserEmails to update
     */
    where?: UserEmailWhereInput
  }

  /**
   * UserEmail upsert
   */
  export type UserEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEmail to update in case it exists.
     */
    where: UserEmailWhereUniqueInput
    /**
     * In case the UserEmail found by the `where` argument doesn't exist, create a new UserEmail with this data.
     */
    create: XOR<UserEmailCreateInput, UserEmailUncheckedCreateInput>
    /**
     * In case the UserEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEmailUpdateInput, UserEmailUncheckedUpdateInput>
  }

  /**
   * UserEmail delete
   */
  export type UserEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
    /**
     * Filter which UserEmail to delete.
     */
    where: UserEmailWhereUniqueInput
  }

  /**
   * UserEmail deleteMany
   */
  export type UserEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEmails to delete
     */
    where?: UserEmailWhereInput
  }

  /**
   * UserEmail without action
   */
  export type UserEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEmail
     */
    select?: UserEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEmailInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    location: string | null
    motto: string | null
    title: string | null
    phone: string | null
    website: string | null
    discordTag: string | null
    githubUrl: string | null
    facebookUrl: string | null
    instagramUrl: string | null
    xUrl: string | null
    linkedinUrl: string | null
    snapchatUrl: string | null
    favoriteClass: string | null
    playStyle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    location: string | null
    motto: string | null
    title: string | null
    phone: string | null
    website: string | null
    discordTag: string | null
    githubUrl: string | null
    facebookUrl: string | null
    instagramUrl: string | null
    xUrl: string | null
    linkedinUrl: string | null
    snapchatUrl: string | null
    favoriteClass: string | null
    playStyle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    bio: number
    location: number
    motto: number
    title: number
    phone: number
    website: number
    discordTag: number
    githubUrl: number
    facebookUrl: number
    instagramUrl: number
    xUrl: number
    linkedinUrl: number
    snapchatUrl: number
    favoriteClass: number
    playStyle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    location?: true
    motto?: true
    title?: true
    phone?: true
    website?: true
    discordTag?: true
    githubUrl?: true
    facebookUrl?: true
    instagramUrl?: true
    xUrl?: true
    linkedinUrl?: true
    snapchatUrl?: true
    favoriteClass?: true
    playStyle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    location?: true
    motto?: true
    title?: true
    phone?: true
    website?: true
    discordTag?: true
    githubUrl?: true
    facebookUrl?: true
    instagramUrl?: true
    xUrl?: true
    linkedinUrl?: true
    snapchatUrl?: true
    favoriteClass?: true
    playStyle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    location?: true
    motto?: true
    title?: true
    phone?: true
    website?: true
    discordTag?: true
    githubUrl?: true
    facebookUrl?: true
    instagramUrl?: true
    xUrl?: true
    linkedinUrl?: true
    snapchatUrl?: true
    favoriteClass?: true
    playStyle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string | null
    bio: string | null
    location: string | null
    motto: string | null
    title: string | null
    phone: string | null
    website: string | null
    discordTag: string | null
    githubUrl: string | null
    facebookUrl: string | null
    instagramUrl: string | null
    xUrl: string | null
    linkedinUrl: string | null
    snapchatUrl: string | null
    favoriteClass: string | null
    playStyle: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    location?: boolean
    motto?: boolean
    title?: boolean
    phone?: boolean
    website?: boolean
    discordTag?: boolean
    githubUrl?: boolean
    facebookUrl?: boolean
    instagramUrl?: boolean
    xUrl?: boolean
    linkedinUrl?: boolean
    snapchatUrl?: boolean
    favoriteClass?: boolean
    playStyle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    location?: boolean
    motto?: boolean
    title?: boolean
    phone?: boolean
    website?: boolean
    discordTag?: boolean
    githubUrl?: boolean
    facebookUrl?: boolean
    instagramUrl?: boolean
    xUrl?: boolean
    linkedinUrl?: boolean
    snapchatUrl?: boolean
    favoriteClass?: boolean
    playStyle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    location?: boolean
    motto?: boolean
    title?: boolean
    phone?: boolean
    website?: boolean
    discordTag?: boolean
    githubUrl?: boolean
    facebookUrl?: boolean
    instagramUrl?: boolean
    xUrl?: boolean
    linkedinUrl?: boolean
    snapchatUrl?: boolean
    favoriteClass?: boolean
    playStyle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string | null
      bio: string | null
      location: string | null
      motto: string | null
      title: string | null
      phone: string | null
      website: string | null
      discordTag: string | null
      githubUrl: string | null
      facebookUrl: string | null
      instagramUrl: string | null
      xUrl: string | null
      linkedinUrl: string | null
      snapchatUrl: string | null
      favoriteClass: string | null
      playStyle: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly displayName: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly location: FieldRef<"UserProfile", 'String'>
    readonly motto: FieldRef<"UserProfile", 'String'>
    readonly title: FieldRef<"UserProfile", 'String'>
    readonly phone: FieldRef<"UserProfile", 'String'>
    readonly website: FieldRef<"UserProfile", 'String'>
    readonly discordTag: FieldRef<"UserProfile", 'String'>
    readonly githubUrl: FieldRef<"UserProfile", 'String'>
    readonly facebookUrl: FieldRef<"UserProfile", 'String'>
    readonly instagramUrl: FieldRef<"UserProfile", 'String'>
    readonly xUrl: FieldRef<"UserProfile", 'String'>
    readonly linkedinUrl: FieldRef<"UserProfile", 'String'>
    readonly snapchatUrl: FieldRef<"UserProfile", 'String'>
    readonly favoriteClass: FieldRef<"UserProfile", 'String'>
    readonly playStyle: FieldRef<"UserProfile", 'String'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardColor: string | null
    cardTheme: string | null
    publicEmailChoice: string | null
    theme: string | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isProfilePublic: boolean | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardColor: string | null
    cardTheme: string | null
    publicEmailChoice: string | null
    theme: string | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isProfilePublic: boolean | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    cardColor: number
    cardTheme: number
    publicEmailChoice: number
    theme: number
    language: number
    pinnedForums: number
    createdAt: number
    updatedAt: number
    isProfilePublic: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    cardColor?: true
    cardTheme?: true
    publicEmailChoice?: true
    theme?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    isProfilePublic?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    cardColor?: true
    cardTheme?: true
    publicEmailChoice?: true
    theme?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    isProfilePublic?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    cardColor?: true
    cardTheme?: true
    publicEmailChoice?: true
    theme?: true
    language?: true
    pinnedForums?: true
    createdAt?: true
    updatedAt?: true
    isProfilePublic?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    cardColor: string
    cardTheme: string
    publicEmailChoice: string | null
    theme: string
    language: string
    pinnedForums: string[]
    createdAt: Date
    updatedAt: Date
    isProfilePublic: boolean
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardColor?: boolean
    cardTheme?: boolean
    publicEmailChoice?: boolean
    theme?: boolean
    language?: boolean
    pinnedForums?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isProfilePublic?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardColor?: boolean
    cardTheme?: boolean
    publicEmailChoice?: boolean
    theme?: boolean
    language?: boolean
    pinnedForums?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isProfilePublic?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    cardColor?: boolean
    cardTheme?: boolean
    publicEmailChoice?: boolean
    theme?: boolean
    language?: boolean
    pinnedForums?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isProfilePublic?: boolean
  }

  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardColor: string
      cardTheme: string
      publicEmailChoice: string | null
      theme: string
      language: string
      pinnedForums: string[]
      createdAt: Date
      updatedAt: Date
      isProfilePublic: boolean
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly cardColor: FieldRef<"UserSettings", 'String'>
    readonly cardTheme: FieldRef<"UserSettings", 'String'>
    readonly publicEmailChoice: FieldRef<"UserSettings", 'String'>
    readonly theme: FieldRef<"UserSettings", 'String'>
    readonly language: FieldRef<"UserSettings", 'String'>
    readonly pinnedForums: FieldRef<"UserSettings", 'String[]'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
    readonly isProfilePublic: FieldRef<"UserSettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserPresence
   */

  export type AggregateUserPresence = {
    _count: UserPresenceCountAggregateOutputType | null
    _min: UserPresenceMinAggregateOutputType | null
    _max: UserPresenceMaxAggregateOutputType | null
  }

  export type UserPresenceMinAggregateOutputType = {
    userId: string | null
    isOnline: boolean | null
    lastSeen: Date | null
    updatedAt: Date | null
  }

  export type UserPresenceMaxAggregateOutputType = {
    userId: string | null
    isOnline: boolean | null
    lastSeen: Date | null
    updatedAt: Date | null
  }

  export type UserPresenceCountAggregateOutputType = {
    userId: number
    isOnline: number
    lastSeen: number
    updatedAt: number
    _all: number
  }


  export type UserPresenceMinAggregateInputType = {
    userId?: true
    isOnline?: true
    lastSeen?: true
    updatedAt?: true
  }

  export type UserPresenceMaxAggregateInputType = {
    userId?: true
    isOnline?: true
    lastSeen?: true
    updatedAt?: true
  }

  export type UserPresenceCountAggregateInputType = {
    userId?: true
    isOnline?: true
    lastSeen?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPresenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPresence to aggregate.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPresences
    **/
    _count?: true | UserPresenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPresenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPresenceMaxAggregateInputType
  }

  export type GetUserPresenceAggregateType<T extends UserPresenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPresence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPresence[P]>
      : GetScalarType<T[P], AggregateUserPresence[P]>
  }




  export type UserPresenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPresenceWhereInput
    orderBy?: UserPresenceOrderByWithAggregationInput | UserPresenceOrderByWithAggregationInput[]
    by: UserPresenceScalarFieldEnum[] | UserPresenceScalarFieldEnum
    having?: UserPresenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPresenceCountAggregateInputType | true
    _min?: UserPresenceMinAggregateInputType
    _max?: UserPresenceMaxAggregateInputType
  }

  export type UserPresenceGroupByOutputType = {
    userId: string
    isOnline: boolean
    lastSeen: Date | null
    updatedAt: Date
    _count: UserPresenceCountAggregateOutputType | null
    _min: UserPresenceMinAggregateOutputType | null
    _max: UserPresenceMaxAggregateOutputType | null
  }

  type GetUserPresenceGroupByPayload<T extends UserPresenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPresenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPresenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPresenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPresenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPresenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectScalar = {
    userId?: boolean
    isOnline?: boolean
    lastSeen?: boolean
    updatedAt?: boolean
  }

  export type UserPresenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPresenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPresencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPresence"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      isOnline: boolean
      lastSeen: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["userPresence"]>
    composites: {}
  }

  type UserPresenceGetPayload<S extends boolean | null | undefined | UserPresenceDefaultArgs> = $Result.GetResult<Prisma.$UserPresencePayload, S>

  type UserPresenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPresenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPresenceCountAggregateInputType | true
    }

  export interface UserPresenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPresence'], meta: { name: 'UserPresence' } }
    /**
     * Find zero or one UserPresence that matches the filter.
     * @param {UserPresenceFindUniqueArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPresenceFindUniqueArgs>(args: SelectSubset<T, UserPresenceFindUniqueArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserPresence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserPresenceFindUniqueOrThrowArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPresenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPresenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserPresence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindFirstArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPresenceFindFirstArgs>(args?: SelectSubset<T, UserPresenceFindFirstArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserPresence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindFirstOrThrowArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPresenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPresenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserPresences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPresences
     * const userPresences = await prisma.userPresence.findMany()
     * 
     * // Get first 10 UserPresences
     * const userPresences = await prisma.userPresence.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPresenceWithUserIdOnly = await prisma.userPresence.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserPresenceFindManyArgs>(args?: SelectSubset<T, UserPresenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserPresence.
     * @param {UserPresenceCreateArgs} args - Arguments to create a UserPresence.
     * @example
     * // Create one UserPresence
     * const UserPresence = await prisma.userPresence.create({
     *   data: {
     *     // ... data to create a UserPresence
     *   }
     * })
     * 
     */
    create<T extends UserPresenceCreateArgs>(args: SelectSubset<T, UserPresenceCreateArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserPresences.
     * @param {UserPresenceCreateManyArgs} args - Arguments to create many UserPresences.
     * @example
     * // Create many UserPresences
     * const userPresence = await prisma.userPresence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPresenceCreateManyArgs>(args?: SelectSubset<T, UserPresenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPresences and returns the data saved in the database.
     * @param {UserPresenceCreateManyAndReturnArgs} args - Arguments to create many UserPresences.
     * @example
     * // Create many UserPresences
     * const userPresence = await prisma.userPresence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPresences and only return the `userId`
     * const userPresenceWithUserIdOnly = await prisma.userPresence.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPresenceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPresenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserPresence.
     * @param {UserPresenceDeleteArgs} args - Arguments to delete one UserPresence.
     * @example
     * // Delete one UserPresence
     * const UserPresence = await prisma.userPresence.delete({
     *   where: {
     *     // ... filter to delete one UserPresence
     *   }
     * })
     * 
     */
    delete<T extends UserPresenceDeleteArgs>(args: SelectSubset<T, UserPresenceDeleteArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserPresence.
     * @param {UserPresenceUpdateArgs} args - Arguments to update one UserPresence.
     * @example
     * // Update one UserPresence
     * const userPresence = await prisma.userPresence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPresenceUpdateArgs>(args: SelectSubset<T, UserPresenceUpdateArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserPresences.
     * @param {UserPresenceDeleteManyArgs} args - Arguments to filter UserPresences to delete.
     * @example
     * // Delete a few UserPresences
     * const { count } = await prisma.userPresence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPresenceDeleteManyArgs>(args?: SelectSubset<T, UserPresenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPresences
     * const userPresence = await prisma.userPresence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPresenceUpdateManyArgs>(args: SelectSubset<T, UserPresenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPresence.
     * @param {UserPresenceUpsertArgs} args - Arguments to update or create a UserPresence.
     * @example
     * // Update or create a UserPresence
     * const userPresence = await prisma.userPresence.upsert({
     *   create: {
     *     // ... data to create a UserPresence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPresence we want to update
     *   }
     * })
     */
    upsert<T extends UserPresenceUpsertArgs>(args: SelectSubset<T, UserPresenceUpsertArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserPresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceCountArgs} args - Arguments to filter UserPresences to count.
     * @example
     * // Count the number of UserPresences
     * const count = await prisma.userPresence.count({
     *   where: {
     *     // ... the filter for the UserPresences we want to count
     *   }
     * })
    **/
    count<T extends UserPresenceCountArgs>(
      args?: Subset<T, UserPresenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPresenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPresenceAggregateArgs>(args: Subset<T, UserPresenceAggregateArgs>): Prisma.PrismaPromise<GetUserPresenceAggregateType<T>>

    /**
     * Group by UserPresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPresenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPresenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPresenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPresenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPresenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPresence model
   */
  readonly fields: UserPresenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPresence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPresenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPresence model
   */ 
  interface UserPresenceFieldRefs {
    readonly userId: FieldRef<"UserPresence", 'String'>
    readonly isOnline: FieldRef<"UserPresence", 'Boolean'>
    readonly lastSeen: FieldRef<"UserPresence", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPresence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPresence findUnique
   */
  export type UserPresenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence findUniqueOrThrow
   */
  export type UserPresenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence findFirst
   */
  export type UserPresenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPresences.
     */
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence findFirstOrThrow
   */
  export type UserPresenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPresences.
     */
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence findMany
   */
  export type UserPresenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresences to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence create
   */
  export type UserPresenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPresence.
     */
    data: XOR<UserPresenceCreateInput, UserPresenceUncheckedCreateInput>
  }

  /**
   * UserPresence createMany
   */
  export type UserPresenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPresences.
     */
    data: UserPresenceCreateManyInput | UserPresenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPresence createManyAndReturn
   */
  export type UserPresenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserPresences.
     */
    data: UserPresenceCreateManyInput | UserPresenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPresence update
   */
  export type UserPresenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPresence.
     */
    data: XOR<UserPresenceUpdateInput, UserPresenceUncheckedUpdateInput>
    /**
     * Choose, which UserPresence to update.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence updateMany
   */
  export type UserPresenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPresences.
     */
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPresences to update
     */
    where?: UserPresenceWhereInput
  }

  /**
   * UserPresence upsert
   */
  export type UserPresenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPresence to update in case it exists.
     */
    where: UserPresenceWhereUniqueInput
    /**
     * In case the UserPresence found by the `where` argument doesn't exist, create a new UserPresence with this data.
     */
    create: XOR<UserPresenceCreateInput, UserPresenceUncheckedCreateInput>
    /**
     * In case the UserPresence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPresenceUpdateInput, UserPresenceUncheckedUpdateInput>
  }

  /**
   * UserPresence delete
   */
  export type UserPresenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter which UserPresence to delete.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence deleteMany
   */
  export type UserPresenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPresences to delete
     */
    where?: UserPresenceWhereInput
  }

  /**
   * UserPresence without action
   */
  export type UserPresenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
  }


  /**
   * Model Jwks
   */

  export type AggregateJwks = {
    _count: JwksCountAggregateOutputType | null
    _min: JwksMinAggregateOutputType | null
    _max: JwksMaxAggregateOutputType | null
  }

  export type JwksMinAggregateOutputType = {
    id: string | null
    publicKey: string | null
    privateKey: string | null
    createdAt: Date | null
  }

  export type JwksMaxAggregateOutputType = {
    id: string | null
    publicKey: string | null
    privateKey: string | null
    createdAt: Date | null
  }

  export type JwksCountAggregateOutputType = {
    id: number
    publicKey: number
    privateKey: number
    createdAt: number
    _all: number
  }


  export type JwksMinAggregateInputType = {
    id?: true
    publicKey?: true
    privateKey?: true
    createdAt?: true
  }

  export type JwksMaxAggregateInputType = {
    id?: true
    publicKey?: true
    privateKey?: true
    createdAt?: true
  }

  export type JwksCountAggregateInputType = {
    id?: true
    publicKey?: true
    privateKey?: true
    createdAt?: true
    _all?: true
  }

  export type JwksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jwks to aggregate.
     */
    where?: JwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jwks to fetch.
     */
    orderBy?: JwksOrderByWithRelationInput | JwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jwks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jwks
    **/
    _count?: true | JwksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JwksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JwksMaxAggregateInputType
  }

  export type GetJwksAggregateType<T extends JwksAggregateArgs> = {
        [P in keyof T & keyof AggregateJwks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJwks[P]>
      : GetScalarType<T[P], AggregateJwks[P]>
  }




  export type JwksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JwksWhereInput
    orderBy?: JwksOrderByWithAggregationInput | JwksOrderByWithAggregationInput[]
    by: JwksScalarFieldEnum[] | JwksScalarFieldEnum
    having?: JwksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JwksCountAggregateInputType | true
    _min?: JwksMinAggregateInputType
    _max?: JwksMaxAggregateInputType
  }

  export type JwksGroupByOutputType = {
    id: string
    publicKey: string
    privateKey: string
    createdAt: Date
    _count: JwksCountAggregateOutputType | null
    _min: JwksMinAggregateOutputType | null
    _max: JwksMaxAggregateOutputType | null
  }

  type GetJwksGroupByPayload<T extends JwksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JwksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JwksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JwksGroupByOutputType[P]>
            : GetScalarType<T[P], JwksGroupByOutputType[P]>
        }
      >
    >


  export type JwksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicKey?: boolean
    privateKey?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jwks"]>

  export type JwksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicKey?: boolean
    privateKey?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jwks"]>

  export type JwksSelectScalar = {
    id?: boolean
    publicKey?: boolean
    privateKey?: boolean
    createdAt?: boolean
  }


  export type $JwksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jwks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publicKey: string
      privateKey: string
      createdAt: Date
    }, ExtArgs["result"]["jwks"]>
    composites: {}
  }

  type JwksGetPayload<S extends boolean | null | undefined | JwksDefaultArgs> = $Result.GetResult<Prisma.$JwksPayload, S>

  type JwksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JwksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JwksCountAggregateInputType | true
    }

  export interface JwksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jwks'], meta: { name: 'Jwks' } }
    /**
     * Find zero or one Jwks that matches the filter.
     * @param {JwksFindUniqueArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JwksFindUniqueArgs>(args: SelectSubset<T, JwksFindUniqueArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Jwks that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JwksFindUniqueOrThrowArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JwksFindUniqueOrThrowArgs>(args: SelectSubset<T, JwksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Jwks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksFindFirstArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JwksFindFirstArgs>(args?: SelectSubset<T, JwksFindFirstArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Jwks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksFindFirstOrThrowArgs} args - Arguments to find a Jwks
     * @example
     * // Get one Jwks
     * const jwks = await prisma.jwks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JwksFindFirstOrThrowArgs>(args?: SelectSubset<T, JwksFindFirstOrThrowArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jwks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jwks
     * const jwks = await prisma.jwks.findMany()
     * 
     * // Get first 10 Jwks
     * const jwks = await prisma.jwks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jwksWithIdOnly = await prisma.jwks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JwksFindManyArgs>(args?: SelectSubset<T, JwksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Jwks.
     * @param {JwksCreateArgs} args - Arguments to create a Jwks.
     * @example
     * // Create one Jwks
     * const Jwks = await prisma.jwks.create({
     *   data: {
     *     // ... data to create a Jwks
     *   }
     * })
     * 
     */
    create<T extends JwksCreateArgs>(args: SelectSubset<T, JwksCreateArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jwks.
     * @param {JwksCreateManyArgs} args - Arguments to create many Jwks.
     * @example
     * // Create many Jwks
     * const jwks = await prisma.jwks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JwksCreateManyArgs>(args?: SelectSubset<T, JwksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jwks and returns the data saved in the database.
     * @param {JwksCreateManyAndReturnArgs} args - Arguments to create many Jwks.
     * @example
     * // Create many Jwks
     * const jwks = await prisma.jwks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jwks and only return the `id`
     * const jwksWithIdOnly = await prisma.jwks.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JwksCreateManyAndReturnArgs>(args?: SelectSubset<T, JwksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Jwks.
     * @param {JwksDeleteArgs} args - Arguments to delete one Jwks.
     * @example
     * // Delete one Jwks
     * const Jwks = await prisma.jwks.delete({
     *   where: {
     *     // ... filter to delete one Jwks
     *   }
     * })
     * 
     */
    delete<T extends JwksDeleteArgs>(args: SelectSubset<T, JwksDeleteArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Jwks.
     * @param {JwksUpdateArgs} args - Arguments to update one Jwks.
     * @example
     * // Update one Jwks
     * const jwks = await prisma.jwks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JwksUpdateArgs>(args: SelectSubset<T, JwksUpdateArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jwks.
     * @param {JwksDeleteManyArgs} args - Arguments to filter Jwks to delete.
     * @example
     * // Delete a few Jwks
     * const { count } = await prisma.jwks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JwksDeleteManyArgs>(args?: SelectSubset<T, JwksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jwks
     * const jwks = await prisma.jwks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JwksUpdateManyArgs>(args: SelectSubset<T, JwksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jwks.
     * @param {JwksUpsertArgs} args - Arguments to update or create a Jwks.
     * @example
     * // Update or create a Jwks
     * const jwks = await prisma.jwks.upsert({
     *   create: {
     *     // ... data to create a Jwks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jwks we want to update
     *   }
     * })
     */
    upsert<T extends JwksUpsertArgs>(args: SelectSubset<T, JwksUpsertArgs<ExtArgs>>): Prisma__JwksClient<$Result.GetResult<Prisma.$JwksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksCountArgs} args - Arguments to filter Jwks to count.
     * @example
     * // Count the number of Jwks
     * const count = await prisma.jwks.count({
     *   where: {
     *     // ... the filter for the Jwks we want to count
     *   }
     * })
    **/
    count<T extends JwksCountArgs>(
      args?: Subset<T, JwksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JwksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JwksAggregateArgs>(args: Subset<T, JwksAggregateArgs>): Prisma.PrismaPromise<GetJwksAggregateType<T>>

    /**
     * Group by Jwks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JwksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JwksGroupByArgs['orderBy'] }
        : { orderBy?: JwksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JwksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJwksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jwks model
   */
  readonly fields: JwksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jwks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JwksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jwks model
   */ 
  interface JwksFieldRefs {
    readonly id: FieldRef<"Jwks", 'String'>
    readonly publicKey: FieldRef<"Jwks", 'String'>
    readonly privateKey: FieldRef<"Jwks", 'String'>
    readonly createdAt: FieldRef<"Jwks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Jwks findUnique
   */
  export type JwksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * Filter, which Jwks to fetch.
     */
    where: JwksWhereUniqueInput
  }

  /**
   * Jwks findUniqueOrThrow
   */
  export type JwksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * Filter, which Jwks to fetch.
     */
    where: JwksWhereUniqueInput
  }

  /**
   * Jwks findFirst
   */
  export type JwksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * Filter, which Jwks to fetch.
     */
    where?: JwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jwks to fetch.
     */
    orderBy?: JwksOrderByWithRelationInput | JwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jwks.
     */
    cursor?: JwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jwks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jwks.
     */
    distinct?: JwksScalarFieldEnum | JwksScalarFieldEnum[]
  }

  /**
   * Jwks findFirstOrThrow
   */
  export type JwksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * Filter, which Jwks to fetch.
     */
    where?: JwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jwks to fetch.
     */
    orderBy?: JwksOrderByWithRelationInput | JwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jwks.
     */
    cursor?: JwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jwks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jwks.
     */
    distinct?: JwksScalarFieldEnum | JwksScalarFieldEnum[]
  }

  /**
   * Jwks findMany
   */
  export type JwksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * Filter, which Jwks to fetch.
     */
    where?: JwksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jwks to fetch.
     */
    orderBy?: JwksOrderByWithRelationInput | JwksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jwks.
     */
    cursor?: JwksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jwks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jwks.
     */
    skip?: number
    distinct?: JwksScalarFieldEnum | JwksScalarFieldEnum[]
  }

  /**
   * Jwks create
   */
  export type JwksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * The data needed to create a Jwks.
     */
    data: XOR<JwksCreateInput, JwksUncheckedCreateInput>
  }

  /**
   * Jwks createMany
   */
  export type JwksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jwks.
     */
    data: JwksCreateManyInput | JwksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jwks createManyAndReturn
   */
  export type JwksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Jwks.
     */
    data: JwksCreateManyInput | JwksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jwks update
   */
  export type JwksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * The data needed to update a Jwks.
     */
    data: XOR<JwksUpdateInput, JwksUncheckedUpdateInput>
    /**
     * Choose, which Jwks to update.
     */
    where: JwksWhereUniqueInput
  }

  /**
   * Jwks updateMany
   */
  export type JwksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jwks.
     */
    data: XOR<JwksUpdateManyMutationInput, JwksUncheckedUpdateManyInput>
    /**
     * Filter which Jwks to update
     */
    where?: JwksWhereInput
  }

  /**
   * Jwks upsert
   */
  export type JwksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * The filter to search for the Jwks to update in case it exists.
     */
    where: JwksWhereUniqueInput
    /**
     * In case the Jwks found by the `where` argument doesn't exist, create a new Jwks with this data.
     */
    create: XOR<JwksCreateInput, JwksUncheckedCreateInput>
    /**
     * In case the Jwks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JwksUpdateInput, JwksUncheckedUpdateInput>
  }

  /**
   * Jwks delete
   */
  export type JwksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
    /**
     * Filter which Jwks to delete.
     */
    where: JwksWhereUniqueInput
  }

  /**
   * Jwks deleteMany
   */
  export type JwksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jwks to delete
     */
    where?: JwksWhereInput
  }

  /**
   * Jwks without action
   */
  export type JwksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jwks
     */
    select?: JwksSelect<ExtArgs> | null
  }


  /**
   * Model FriendRequest
   */

  export type AggregateFriendRequest = {
    _count: FriendRequestCountAggregateOutputType | null
    _min: FriendRequestMinAggregateOutputType | null
    _max: FriendRequestMaxAggregateOutputType | null
  }

  export type FriendRequestMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    status: $Enums.FriendRequestStatus | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FriendRequestMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    status: $Enums.FriendRequestStatus | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FriendRequestCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    status: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FriendRequestMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FriendRequestMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FriendRequestCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FriendRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FriendRequest to aggregate.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendRequests
    **/
    _count?: true | FriendRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendRequestMaxAggregateInputType
  }

  export type GetFriendRequestAggregateType<T extends FriendRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendRequest[P]>
      : GetScalarType<T[P], AggregateFriendRequest[P]>
  }




  export type FriendRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendRequestWhereInput
    orderBy?: FriendRequestOrderByWithAggregationInput | FriendRequestOrderByWithAggregationInput[]
    by: FriendRequestScalarFieldEnum[] | FriendRequestScalarFieldEnum
    having?: FriendRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendRequestCountAggregateInputType | true
    _min?: FriendRequestMinAggregateInputType
    _max?: FriendRequestMaxAggregateInputType
  }

  export type FriendRequestGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    status: $Enums.FriendRequestStatus
    message: string | null
    createdAt: Date
    updatedAt: Date
    _count: FriendRequestCountAggregateOutputType | null
    _min: FriendRequestMinAggregateOutputType | null
    _max: FriendRequestMaxAggregateOutputType | null
  }

  type GetFriendRequestGroupByPayload<T extends FriendRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendRequestGroupByOutputType[P]>
            : GetScalarType<T[P], FriendRequestGroupByOutputType[P]>
        }
      >
    >


  export type FriendRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["friendRequest"]>

  export type FriendRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["friendRequest"]>

  export type FriendRequestSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FriendRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FriendRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      status: $Enums.FriendRequestStatus
      message: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["friendRequest"]>
    composites: {}
  }

  type FriendRequestGetPayload<S extends boolean | null | undefined | FriendRequestDefaultArgs> = $Result.GetResult<Prisma.$FriendRequestPayload, S>

  type FriendRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendRequestCountAggregateInputType | true
    }

  export interface FriendRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FriendRequest'], meta: { name: 'FriendRequest' } }
    /**
     * Find zero or one FriendRequest that matches the filter.
     * @param {FriendRequestFindUniqueArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendRequestFindUniqueArgs>(args: SelectSubset<T, FriendRequestFindUniqueArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FriendRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendRequestFindUniqueOrThrowArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FriendRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindFirstArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendRequestFindFirstArgs>(args?: SelectSubset<T, FriendRequestFindFirstArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FriendRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindFirstOrThrowArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FriendRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendRequests
     * const friendRequests = await prisma.friendRequest.findMany()
     * 
     * // Get first 10 FriendRequests
     * const friendRequests = await prisma.friendRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendRequestWithIdOnly = await prisma.friendRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendRequestFindManyArgs>(args?: SelectSubset<T, FriendRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FriendRequest.
     * @param {FriendRequestCreateArgs} args - Arguments to create a FriendRequest.
     * @example
     * // Create one FriendRequest
     * const FriendRequest = await prisma.friendRequest.create({
     *   data: {
     *     // ... data to create a FriendRequest
     *   }
     * })
     * 
     */
    create<T extends FriendRequestCreateArgs>(args: SelectSubset<T, FriendRequestCreateArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FriendRequests.
     * @param {FriendRequestCreateManyArgs} args - Arguments to create many FriendRequests.
     * @example
     * // Create many FriendRequests
     * const friendRequest = await prisma.friendRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendRequestCreateManyArgs>(args?: SelectSubset<T, FriendRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FriendRequests and returns the data saved in the database.
     * @param {FriendRequestCreateManyAndReturnArgs} args - Arguments to create many FriendRequests.
     * @example
     * // Create many FriendRequests
     * const friendRequest = await prisma.friendRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FriendRequests and only return the `id`
     * const friendRequestWithIdOnly = await prisma.friendRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FriendRequest.
     * @param {FriendRequestDeleteArgs} args - Arguments to delete one FriendRequest.
     * @example
     * // Delete one FriendRequest
     * const FriendRequest = await prisma.friendRequest.delete({
     *   where: {
     *     // ... filter to delete one FriendRequest
     *   }
     * })
     * 
     */
    delete<T extends FriendRequestDeleteArgs>(args: SelectSubset<T, FriendRequestDeleteArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FriendRequest.
     * @param {FriendRequestUpdateArgs} args - Arguments to update one FriendRequest.
     * @example
     * // Update one FriendRequest
     * const friendRequest = await prisma.friendRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendRequestUpdateArgs>(args: SelectSubset<T, FriendRequestUpdateArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FriendRequests.
     * @param {FriendRequestDeleteManyArgs} args - Arguments to filter FriendRequests to delete.
     * @example
     * // Delete a few FriendRequests
     * const { count } = await prisma.friendRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendRequestDeleteManyArgs>(args?: SelectSubset<T, FriendRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendRequests
     * const friendRequest = await prisma.friendRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendRequestUpdateManyArgs>(args: SelectSubset<T, FriendRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FriendRequest.
     * @param {FriendRequestUpsertArgs} args - Arguments to update or create a FriendRequest.
     * @example
     * // Update or create a FriendRequest
     * const friendRequest = await prisma.friendRequest.upsert({
     *   create: {
     *     // ... data to create a FriendRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendRequest we want to update
     *   }
     * })
     */
    upsert<T extends FriendRequestUpsertArgs>(args: SelectSubset<T, FriendRequestUpsertArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestCountArgs} args - Arguments to filter FriendRequests to count.
     * @example
     * // Count the number of FriendRequests
     * const count = await prisma.friendRequest.count({
     *   where: {
     *     // ... the filter for the FriendRequests we want to count
     *   }
     * })
    **/
    count<T extends FriendRequestCountArgs>(
      args?: Subset<T, FriendRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendRequestAggregateArgs>(args: Subset<T, FriendRequestAggregateArgs>): Prisma.PrismaPromise<GetFriendRequestAggregateType<T>>

    /**
     * Group by FriendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendRequestGroupByArgs['orderBy'] }
        : { orderBy?: FriendRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FriendRequest model
   */
  readonly fields: FriendRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FriendRequest model
   */ 
  interface FriendRequestFieldRefs {
    readonly id: FieldRef<"FriendRequest", 'String'>
    readonly senderId: FieldRef<"FriendRequest", 'String'>
    readonly receiverId: FieldRef<"FriendRequest", 'String'>
    readonly status: FieldRef<"FriendRequest", 'FriendRequestStatus'>
    readonly message: FieldRef<"FriendRequest", 'String'>
    readonly createdAt: FieldRef<"FriendRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"FriendRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FriendRequest findUnique
   */
  export type FriendRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest findUniqueOrThrow
   */
  export type FriendRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest findFirst
   */
  export type FriendRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendRequests.
     */
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * FriendRequest findFirstOrThrow
   */
  export type FriendRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendRequests.
     */
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * FriendRequest findMany
   */
  export type FriendRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Filter, which FriendRequests to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * FriendRequest create
   */
  export type FriendRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a FriendRequest.
     */
    data: XOR<FriendRequestCreateInput, FriendRequestUncheckedCreateInput>
  }

  /**
   * FriendRequest createMany
   */
  export type FriendRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FriendRequests.
     */
    data: FriendRequestCreateManyInput | FriendRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FriendRequest createManyAndReturn
   */
  export type FriendRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FriendRequests.
     */
    data: FriendRequestCreateManyInput | FriendRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FriendRequest update
   */
  export type FriendRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a FriendRequest.
     */
    data: XOR<FriendRequestUpdateInput, FriendRequestUncheckedUpdateInput>
    /**
     * Choose, which FriendRequest to update.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest updateMany
   */
  export type FriendRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FriendRequests.
     */
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyInput>
    /**
     * Filter which FriendRequests to update
     */
    where?: FriendRequestWhereInput
  }

  /**
   * FriendRequest upsert
   */
  export type FriendRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the FriendRequest to update in case it exists.
     */
    where: FriendRequestWhereUniqueInput
    /**
     * In case the FriendRequest found by the `where` argument doesn't exist, create a new FriendRequest with this data.
     */
    create: XOR<FriendRequestCreateInput, FriendRequestUncheckedCreateInput>
    /**
     * In case the FriendRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendRequestUpdateInput, FriendRequestUncheckedUpdateInput>
  }

  /**
   * FriendRequest delete
   */
  export type FriendRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Filter which FriendRequest to delete.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest deleteMany
   */
  export type FriendRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FriendRequests to delete
     */
    where?: FriendRequestWhereInput
  }

  /**
   * FriendRequest without action
   */
  export type FriendRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    createdAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    createdAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    user1Id: number
    user2Id: number
    createdAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    createdAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    createdAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    createdAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    user1Id: string
    user2Id: string
    createdAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    createdAt?: boolean
  }


  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user1Id: string
      user2Id: string
      createdAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */ 
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly user1Id: FieldRef<"Friendship", 'String'>
    readonly user2Id: FieldRef<"Friendship", 'String'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
  }


  /**
   * Model BlockedUser
   */

  export type AggregateBlockedUser = {
    _count: BlockedUserCountAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  export type BlockedUserMinAggregateOutputType = {
    id: string | null
    blockedById: string | null
    blockedUserId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockedUserMaxAggregateOutputType = {
    id: string | null
    blockedById: string | null
    blockedUserId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockedUserCountAggregateOutputType = {
    id: number
    blockedById: number
    blockedUserId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type BlockedUserMinAggregateInputType = {
    id?: true
    blockedById?: true
    blockedUserId?: true
    reason?: true
    createdAt?: true
  }

  export type BlockedUserMaxAggregateInputType = {
    id?: true
    blockedById?: true
    blockedUserId?: true
    reason?: true
    createdAt?: true
  }

  export type BlockedUserCountAggregateInputType = {
    id?: true
    blockedById?: true
    blockedUserId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type BlockedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUser to aggregate.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedUsers
    **/
    _count?: true | BlockedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedUserMaxAggregateInputType
  }

  export type GetBlockedUserAggregateType<T extends BlockedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedUser[P]>
      : GetScalarType<T[P], AggregateBlockedUser[P]>
  }




  export type BlockedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithAggregationInput | BlockedUserOrderByWithAggregationInput[]
    by: BlockedUserScalarFieldEnum[] | BlockedUserScalarFieldEnum
    having?: BlockedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedUserCountAggregateInputType | true
    _min?: BlockedUserMinAggregateInputType
    _max?: BlockedUserMaxAggregateInputType
  }

  export type BlockedUserGroupByOutputType = {
    id: string
    blockedById: string
    blockedUserId: string
    reason: string | null
    createdAt: Date
    _count: BlockedUserCountAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  type GetBlockedUserGroupByPayload<T extends BlockedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
        }
      >
    >


  export type BlockedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockedById?: boolean
    blockedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockedById?: boolean
    blockedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectScalar = {
    id?: boolean
    blockedById?: boolean
    blockedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
  }


  export type $BlockedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockedById: string
      blockedUserId: string
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["blockedUser"]>
    composites: {}
  }

  type BlockedUserGetPayload<S extends boolean | null | undefined | BlockedUserDefaultArgs> = $Result.GetResult<Prisma.$BlockedUserPayload, S>

  type BlockedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockedUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockedUserCountAggregateInputType | true
    }

  export interface BlockedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedUser'], meta: { name: 'BlockedUser' } }
    /**
     * Find zero or one BlockedUser that matches the filter.
     * @param {BlockedUserFindUniqueArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedUserFindUniqueArgs>(args: SelectSubset<T, BlockedUserFindUniqueArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockedUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockedUserFindUniqueOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedUserFindFirstArgs>(args?: SelectSubset<T, BlockedUserFindFirstArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany()
     * 
     * // Get first 10 BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedUserFindManyArgs>(args?: SelectSubset<T, BlockedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockedUser.
     * @param {BlockedUserCreateArgs} args - Arguments to create a BlockedUser.
     * @example
     * // Create one BlockedUser
     * const BlockedUser = await prisma.blockedUser.create({
     *   data: {
     *     // ... data to create a BlockedUser
     *   }
     * })
     * 
     */
    create<T extends BlockedUserCreateArgs>(args: SelectSubset<T, BlockedUserCreateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockedUsers.
     * @param {BlockedUserCreateManyArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedUserCreateManyArgs>(args?: SelectSubset<T, BlockedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedUsers and returns the data saved in the database.
     * @param {BlockedUserCreateManyAndReturnArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedUsers and only return the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedUserCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockedUser.
     * @param {BlockedUserDeleteArgs} args - Arguments to delete one BlockedUser.
     * @example
     * // Delete one BlockedUser
     * const BlockedUser = await prisma.blockedUser.delete({
     *   where: {
     *     // ... filter to delete one BlockedUser
     *   }
     * })
     * 
     */
    delete<T extends BlockedUserDeleteArgs>(args: SelectSubset<T, BlockedUserDeleteArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockedUser.
     * @param {BlockedUserUpdateArgs} args - Arguments to update one BlockedUser.
     * @example
     * // Update one BlockedUser
     * const blockedUser = await prisma.blockedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedUserUpdateArgs>(args: SelectSubset<T, BlockedUserUpdateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockedUsers.
     * @param {BlockedUserDeleteManyArgs} args - Arguments to filter BlockedUsers to delete.
     * @example
     * // Delete a few BlockedUsers
     * const { count } = await prisma.blockedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedUserDeleteManyArgs>(args?: SelectSubset<T, BlockedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedUserUpdateManyArgs>(args: SelectSubset<T, BlockedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockedUser.
     * @param {BlockedUserUpsertArgs} args - Arguments to update or create a BlockedUser.
     * @example
     * // Update or create a BlockedUser
     * const blockedUser = await prisma.blockedUser.upsert({
     *   create: {
     *     // ... data to create a BlockedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedUser we want to update
     *   }
     * })
     */
    upsert<T extends BlockedUserUpsertArgs>(args: SelectSubset<T, BlockedUserUpsertArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserCountArgs} args - Arguments to filter BlockedUsers to count.
     * @example
     * // Count the number of BlockedUsers
     * const count = await prisma.blockedUser.count({
     *   where: {
     *     // ... the filter for the BlockedUsers we want to count
     *   }
     * })
    **/
    count<T extends BlockedUserCountArgs>(
      args?: Subset<T, BlockedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedUserAggregateArgs>(args: Subset<T, BlockedUserAggregateArgs>): Prisma.PrismaPromise<GetBlockedUserAggregateType<T>>

    /**
     * Group by BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedUserGroupByArgs['orderBy'] }
        : { orderBy?: BlockedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedUser model
   */
  readonly fields: BlockedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedUser model
   */ 
  interface BlockedUserFieldRefs {
    readonly id: FieldRef<"BlockedUser", 'String'>
    readonly blockedById: FieldRef<"BlockedUser", 'String'>
    readonly blockedUserId: FieldRef<"BlockedUser", 'String'>
    readonly reason: FieldRef<"BlockedUser", 'String'>
    readonly createdAt: FieldRef<"BlockedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedUser findUnique
   */
  export type BlockedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findUniqueOrThrow
   */
  export type BlockedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findFirst
   */
  export type BlockedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findFirstOrThrow
   */
  export type BlockedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findMany
   */
  export type BlockedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Filter, which BlockedUsers to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser create
   */
  export type BlockedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * The data needed to create a BlockedUser.
     */
    data: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
  }

  /**
   * BlockedUser createMany
   */
  export type BlockedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedUser createManyAndReturn
   */
  export type BlockedUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedUser update
   */
  export type BlockedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * The data needed to update a BlockedUser.
     */
    data: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
    /**
     * Choose, which BlockedUser to update.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser updateMany
   */
  export type BlockedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
  }

  /**
   * BlockedUser upsert
   */
  export type BlockedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * The filter to search for the BlockedUser to update in case it exists.
     */
    where: BlockedUserWhereUniqueInput
    /**
     * In case the BlockedUser found by the `where` argument doesn't exist, create a new BlockedUser with this data.
     */
    create: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
    /**
     * In case the BlockedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
  }

  /**
   * BlockedUser delete
   */
  export type BlockedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Filter which BlockedUser to delete.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser deleteMany
   */
  export type BlockedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUsers to delete
     */
    where?: BlockedUserWhereInput
  }

  /**
   * BlockedUser without action
   */
  export type BlockedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    type: $Enums.MessageType | null
    isRead: boolean | null
    isDelivered: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    type: $Enums.MessageType | null
    isRead: boolean | null
    isDelivered: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    type: number
    isRead: number
    isDelivered: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    type?: true
    isRead?: true
    isDelivered?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    type?: true
    isRead?: true
    isDelivered?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    type?: true
    isRead?: true
    isDelivered?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    content: string
    type: $Enums.MessageType
    isRead: boolean
    isDelivered: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    isDelivered?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    isDelivered?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    isDelivered?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      content: string
      type: $Enums.MessageType
      isRead: boolean
      isDelivered: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly isDelivered: FieldRef<"Message", 'Boolean'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    title: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    title: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    title: number
    content: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    authorId: string
    title: string | null
    content: string
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Post$commentsArgs<ExtArgs>
    likes?: boolean | Post$likesArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      title: string | null
      content: string
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends Post$likesArgs<ExtArgs> = {}>(args?: Subset<T, Post$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly imageUrl: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.likes
   */
  export type Post$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      authorId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    postId: string
    userId: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly postId: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model ForumTopic
   */

  export type AggregateForumTopic = {
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  export type ForumTopicAvgAggregateOutputType = {
    views: number | null
  }

  export type ForumTopicSumAggregateOutputType = {
    views: number | null
  }

  export type ForumTopicMinAggregateOutputType = {
    id: string | null
    forumId: $Enums.ForumCategory | null
    title: string | null
    content: string | null
    type: $Enums.TopicType | null
    authorId: string | null
    views: number | null
    isPinned: boolean | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumTopicMaxAggregateOutputType = {
    id: string | null
    forumId: $Enums.ForumCategory | null
    title: string | null
    content: string | null
    type: $Enums.TopicType | null
    authorId: string | null
    views: number | null
    isPinned: boolean | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumTopicCountAggregateOutputType = {
    id: number
    forumId: number
    title: number
    content: number
    type: number
    tags: number
    authorId: number
    views: number
    isPinned: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumTopicAvgAggregateInputType = {
    views?: true
  }

  export type ForumTopicSumAggregateInputType = {
    views?: true
  }

  export type ForumTopicMinAggregateInputType = {
    id?: true
    forumId?: true
    title?: true
    content?: true
    type?: true
    authorId?: true
    views?: true
    isPinned?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumTopicMaxAggregateInputType = {
    id?: true
    forumId?: true
    title?: true
    content?: true
    type?: true
    authorId?: true
    views?: true
    isPinned?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumTopicCountAggregateInputType = {
    id?: true
    forumId?: true
    title?: true
    content?: true
    type?: true
    tags?: true
    authorId?: true
    views?: true
    isPinned?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopic to aggregate.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumTopics
    **/
    _count?: true | ForumTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumTopicMaxAggregateInputType
  }

  export type GetForumTopicAggregateType<T extends ForumTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateForumTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumTopic[P]>
      : GetScalarType<T[P], AggregateForumTopic[P]>
  }




  export type ForumTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicWhereInput
    orderBy?: ForumTopicOrderByWithAggregationInput | ForumTopicOrderByWithAggregationInput[]
    by: ForumTopicScalarFieldEnum[] | ForumTopicScalarFieldEnum
    having?: ForumTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumTopicCountAggregateInputType | true
    _avg?: ForumTopicAvgAggregateInputType
    _sum?: ForumTopicSumAggregateInputType
    _min?: ForumTopicMinAggregateInputType
    _max?: ForumTopicMaxAggregateInputType
  }

  export type ForumTopicGroupByOutputType = {
    id: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type: $Enums.TopicType
    tags: string[]
    authorId: string
    views: number
    isPinned: boolean
    isClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  type GetForumTopicGroupByPayload<T extends ForumTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
            : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
        }
      >
    >


  export type ForumTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    tags?: boolean
    authorId?: boolean
    views?: boolean
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    replies?: boolean | ForumTopic$repliesArgs<ExtArgs>
    likes?: boolean | ForumTopic$likesArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    tags?: boolean
    authorId?: boolean
    views?: boolean
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectScalar = {
    id?: boolean
    forumId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    tags?: boolean
    authorId?: boolean
    views?: boolean
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | ForumTopic$repliesArgs<ExtArgs>
    likes?: boolean | ForumTopic$likesArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ForumTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumTopic"
    objects: {
      replies: Prisma.$ForumReplyPayload<ExtArgs>[]
      likes: Prisma.$ForumTopicLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      forumId: $Enums.ForumCategory
      title: string
      content: string
      type: $Enums.TopicType
      tags: string[]
      authorId: string
      views: number
      isPinned: boolean
      isClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumTopic"]>
    composites: {}
  }

  type ForumTopicGetPayload<S extends boolean | null | undefined | ForumTopicDefaultArgs> = $Result.GetResult<Prisma.$ForumTopicPayload, S>

  type ForumTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumTopicCountAggregateInputType | true
    }

  export interface ForumTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumTopic'], meta: { name: 'ForumTopic' } }
    /**
     * Find zero or one ForumTopic that matches the filter.
     * @param {ForumTopicFindUniqueArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumTopicFindUniqueArgs>(args: SelectSubset<T, ForumTopicFindUniqueArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumTopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumTopicFindUniqueOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindFirstArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumTopicFindFirstArgs>(args?: SelectSubset<T, ForumTopicFindFirstArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindFirstOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany()
     * 
     * // Get first 10 ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumTopicFindManyArgs>(args?: SelectSubset<T, ForumTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumTopic.
     * @param {ForumTopicCreateArgs} args - Arguments to create a ForumTopic.
     * @example
     * // Create one ForumTopic
     * const ForumTopic = await prisma.forumTopic.create({
     *   data: {
     *     // ... data to create a ForumTopic
     *   }
     * })
     * 
     */
    create<T extends ForumTopicCreateArgs>(args: SelectSubset<T, ForumTopicCreateArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumTopics.
     * @param {ForumTopicCreateManyArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumTopicCreateManyArgs>(args?: SelectSubset<T, ForumTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumTopics and returns the data saved in the database.
     * @param {ForumTopicCreateManyAndReturnArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumTopics and only return the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumTopic.
     * @param {ForumTopicDeleteArgs} args - Arguments to delete one ForumTopic.
     * @example
     * // Delete one ForumTopic
     * const ForumTopic = await prisma.forumTopic.delete({
     *   where: {
     *     // ... filter to delete one ForumTopic
     *   }
     * })
     * 
     */
    delete<T extends ForumTopicDeleteArgs>(args: SelectSubset<T, ForumTopicDeleteArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumTopic.
     * @param {ForumTopicUpdateArgs} args - Arguments to update one ForumTopic.
     * @example
     * // Update one ForumTopic
     * const forumTopic = await prisma.forumTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumTopicUpdateArgs>(args: SelectSubset<T, ForumTopicUpdateArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumTopics.
     * @param {ForumTopicDeleteManyArgs} args - Arguments to filter ForumTopics to delete.
     * @example
     * // Delete a few ForumTopics
     * const { count } = await prisma.forumTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumTopicDeleteManyArgs>(args?: SelectSubset<T, ForumTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumTopics
     * const forumTopic = await prisma.forumTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumTopicUpdateManyArgs>(args: SelectSubset<T, ForumTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumTopic.
     * @param {ForumTopicUpsertArgs} args - Arguments to update or create a ForumTopic.
     * @example
     * // Update or create a ForumTopic
     * const forumTopic = await prisma.forumTopic.upsert({
     *   create: {
     *     // ... data to create a ForumTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumTopic we want to update
     *   }
     * })
     */
    upsert<T extends ForumTopicUpsertArgs>(args: SelectSubset<T, ForumTopicUpsertArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicCountArgs} args - Arguments to filter ForumTopics to count.
     * @example
     * // Count the number of ForumTopics
     * const count = await prisma.forumTopic.count({
     *   where: {
     *     // ... the filter for the ForumTopics we want to count
     *   }
     * })
    **/
    count<T extends ForumTopicCountArgs>(
      args?: Subset<T, ForumTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumTopicAggregateArgs>(args: Subset<T, ForumTopicAggregateArgs>): Prisma.PrismaPromise<GetForumTopicAggregateType<T>>

    /**
     * Group by ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumTopicGroupByArgs['orderBy'] }
        : { orderBy?: ForumTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumTopic model
   */
  readonly fields: ForumTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    replies<T extends ForumTopic$repliesArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopic$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends ForumTopic$likesArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopic$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumTopic model
   */ 
  interface ForumTopicFieldRefs {
    readonly id: FieldRef<"ForumTopic", 'String'>
    readonly forumId: FieldRef<"ForumTopic", 'ForumCategory'>
    readonly title: FieldRef<"ForumTopic", 'String'>
    readonly content: FieldRef<"ForumTopic", 'String'>
    readonly type: FieldRef<"ForumTopic", 'TopicType'>
    readonly tags: FieldRef<"ForumTopic", 'String[]'>
    readonly authorId: FieldRef<"ForumTopic", 'String'>
    readonly views: FieldRef<"ForumTopic", 'Int'>
    readonly isPinned: FieldRef<"ForumTopic", 'Boolean'>
    readonly isClosed: FieldRef<"ForumTopic", 'Boolean'>
    readonly createdAt: FieldRef<"ForumTopic", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumTopic findUnique
   */
  export type ForumTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic findUniqueOrThrow
   */
  export type ForumTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic findFirst
   */
  export type ForumTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic findFirstOrThrow
   */
  export type ForumTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic findMany
   */
  export type ForumTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopics to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic create
   */
  export type ForumTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumTopic.
     */
    data: XOR<ForumTopicCreateInput, ForumTopicUncheckedCreateInput>
  }

  /**
   * ForumTopic createMany
   */
  export type ForumTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumTopics.
     */
    data: ForumTopicCreateManyInput | ForumTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumTopic createManyAndReturn
   */
  export type ForumTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumTopics.
     */
    data: ForumTopicCreateManyInput | ForumTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumTopic update
   */
  export type ForumTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumTopic.
     */
    data: XOR<ForumTopicUpdateInput, ForumTopicUncheckedUpdateInput>
    /**
     * Choose, which ForumTopic to update.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic updateMany
   */
  export type ForumTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumTopics.
     */
    data: XOR<ForumTopicUpdateManyMutationInput, ForumTopicUncheckedUpdateManyInput>
    /**
     * Filter which ForumTopics to update
     */
    where?: ForumTopicWhereInput
  }

  /**
   * ForumTopic upsert
   */
  export type ForumTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumTopic to update in case it exists.
     */
    where: ForumTopicWhereUniqueInput
    /**
     * In case the ForumTopic found by the `where` argument doesn't exist, create a new ForumTopic with this data.
     */
    create: XOR<ForumTopicCreateInput, ForumTopicUncheckedCreateInput>
    /**
     * In case the ForumTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumTopicUpdateInput, ForumTopicUncheckedUpdateInput>
  }

  /**
   * ForumTopic delete
   */
  export type ForumTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter which ForumTopic to delete.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic deleteMany
   */
  export type ForumTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopics to delete
     */
    where?: ForumTopicWhereInput
  }

  /**
   * ForumTopic.replies
   */
  export type ForumTopic$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    cursor?: ForumReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumTopic.likes
   */
  export type ForumTopic$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    where?: ForumTopicLikeWhereInput
    orderBy?: ForumTopicLikeOrderByWithRelationInput | ForumTopicLikeOrderByWithRelationInput[]
    cursor?: ForumTopicLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumTopicLikeScalarFieldEnum | ForumTopicLikeScalarFieldEnum[]
  }

  /**
   * ForumTopic without action
   */
  export type ForumTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
  }


  /**
   * Model ForumReply
   */

  export type AggregateForumReply = {
    _count: ForumReplyCountAggregateOutputType | null
    _min: ForumReplyMinAggregateOutputType | null
    _max: ForumReplyMaxAggregateOutputType | null
  }

  export type ForumReplyMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumReplyMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumReplyCountAggregateOutputType = {
    id: number
    topicId: number
    content: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumReplyMinAggregateInputType = {
    id?: true
    topicId?: true
    content?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumReplyMaxAggregateInputType = {
    id?: true
    topicId?: true
    content?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumReplyCountAggregateInputType = {
    id?: true
    topicId?: true
    content?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReply to aggregate.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumReplies
    **/
    _count?: true | ForumReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumReplyMaxAggregateInputType
  }

  export type GetForumReplyAggregateType<T extends ForumReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateForumReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumReply[P]>
      : GetScalarType<T[P], AggregateForumReply[P]>
  }




  export type ForumReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithAggregationInput | ForumReplyOrderByWithAggregationInput[]
    by: ForumReplyScalarFieldEnum[] | ForumReplyScalarFieldEnum
    having?: ForumReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumReplyCountAggregateInputType | true
    _min?: ForumReplyMinAggregateInputType
    _max?: ForumReplyMaxAggregateInputType
  }

  export type ForumReplyGroupByOutputType = {
    id: string
    topicId: string
    content: string
    authorId: string
    createdAt: Date
    updatedAt: Date
    _count: ForumReplyCountAggregateOutputType | null
    _min: ForumReplyMinAggregateOutputType | null
    _max: ForumReplyMaxAggregateOutputType | null
  }

  type GetForumReplyGroupByPayload<T extends ForumReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ForumReplyGroupByOutputType[P]>
        }
      >
    >


  export type ForumReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    content?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    likes?: boolean | ForumReply$likesArgs<ExtArgs>
    _count?: boolean | ForumReplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReply"]>

  export type ForumReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    content?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReply"]>

  export type ForumReplySelectScalar = {
    id?: boolean
    topicId?: boolean
    content?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    likes?: boolean | ForumReply$likesArgs<ExtArgs>
    _count?: boolean | ForumReplyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }

  export type $ForumReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumReply"
    objects: {
      topic: Prisma.$ForumTopicPayload<ExtArgs>
      likes: Prisma.$ForumReplyLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      content: string
      authorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumReply"]>
    composites: {}
  }

  type ForumReplyGetPayload<S extends boolean | null | undefined | ForumReplyDefaultArgs> = $Result.GetResult<Prisma.$ForumReplyPayload, S>

  type ForumReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumReplyCountAggregateInputType | true
    }

  export interface ForumReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumReply'], meta: { name: 'ForumReply' } }
    /**
     * Find zero or one ForumReply that matches the filter.
     * @param {ForumReplyFindUniqueArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumReplyFindUniqueArgs>(args: SelectSubset<T, ForumReplyFindUniqueArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumReplyFindUniqueOrThrowArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyFindFirstArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumReplyFindFirstArgs>(args?: SelectSubset<T, ForumReplyFindFirstArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyFindFirstOrThrowArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumReplies
     * const forumReplies = await prisma.forumReply.findMany()
     * 
     * // Get first 10 ForumReplies
     * const forumReplies = await prisma.forumReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumReplyWithIdOnly = await prisma.forumReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumReplyFindManyArgs>(args?: SelectSubset<T, ForumReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumReply.
     * @param {ForumReplyCreateArgs} args - Arguments to create a ForumReply.
     * @example
     * // Create one ForumReply
     * const ForumReply = await prisma.forumReply.create({
     *   data: {
     *     // ... data to create a ForumReply
     *   }
     * })
     * 
     */
    create<T extends ForumReplyCreateArgs>(args: SelectSubset<T, ForumReplyCreateArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumReplies.
     * @param {ForumReplyCreateManyArgs} args - Arguments to create many ForumReplies.
     * @example
     * // Create many ForumReplies
     * const forumReply = await prisma.forumReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumReplyCreateManyArgs>(args?: SelectSubset<T, ForumReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumReplies and returns the data saved in the database.
     * @param {ForumReplyCreateManyAndReturnArgs} args - Arguments to create many ForumReplies.
     * @example
     * // Create many ForumReplies
     * const forumReply = await prisma.forumReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumReplies and only return the `id`
     * const forumReplyWithIdOnly = await prisma.forumReply.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumReply.
     * @param {ForumReplyDeleteArgs} args - Arguments to delete one ForumReply.
     * @example
     * // Delete one ForumReply
     * const ForumReply = await prisma.forumReply.delete({
     *   where: {
     *     // ... filter to delete one ForumReply
     *   }
     * })
     * 
     */
    delete<T extends ForumReplyDeleteArgs>(args: SelectSubset<T, ForumReplyDeleteArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumReply.
     * @param {ForumReplyUpdateArgs} args - Arguments to update one ForumReply.
     * @example
     * // Update one ForumReply
     * const forumReply = await prisma.forumReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumReplyUpdateArgs>(args: SelectSubset<T, ForumReplyUpdateArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumReplies.
     * @param {ForumReplyDeleteManyArgs} args - Arguments to filter ForumReplies to delete.
     * @example
     * // Delete a few ForumReplies
     * const { count } = await prisma.forumReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumReplyDeleteManyArgs>(args?: SelectSubset<T, ForumReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumReplies
     * const forumReply = await prisma.forumReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumReplyUpdateManyArgs>(args: SelectSubset<T, ForumReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumReply.
     * @param {ForumReplyUpsertArgs} args - Arguments to update or create a ForumReply.
     * @example
     * // Update or create a ForumReply
     * const forumReply = await prisma.forumReply.upsert({
     *   create: {
     *     // ... data to create a ForumReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumReply we want to update
     *   }
     * })
     */
    upsert<T extends ForumReplyUpsertArgs>(args: SelectSubset<T, ForumReplyUpsertArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyCountArgs} args - Arguments to filter ForumReplies to count.
     * @example
     * // Count the number of ForumReplies
     * const count = await prisma.forumReply.count({
     *   where: {
     *     // ... the filter for the ForumReplies we want to count
     *   }
     * })
    **/
    count<T extends ForumReplyCountArgs>(
      args?: Subset<T, ForumReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumReplyAggregateArgs>(args: Subset<T, ForumReplyAggregateArgs>): Prisma.PrismaPromise<GetForumReplyAggregateType<T>>

    /**
     * Group by ForumReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumReplyGroupByArgs['orderBy'] }
        : { orderBy?: ForumReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumReply model
   */
  readonly fields: ForumReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends ForumTopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopicDefaultArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    likes<T extends ForumReply$likesArgs<ExtArgs> = {}>(args?: Subset<T, ForumReply$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumReply model
   */ 
  interface ForumReplyFieldRefs {
    readonly id: FieldRef<"ForumReply", 'String'>
    readonly topicId: FieldRef<"ForumReply", 'String'>
    readonly content: FieldRef<"ForumReply", 'String'>
    readonly authorId: FieldRef<"ForumReply", 'String'>
    readonly createdAt: FieldRef<"ForumReply", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumReply findUnique
   */
  export type ForumReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply findUniqueOrThrow
   */
  export type ForumReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply findFirst
   */
  export type ForumReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplies.
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplies.
     */
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply findFirstOrThrow
   */
  export type ForumReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplies.
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplies.
     */
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply findMany
   */
  export type ForumReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplies to fetch.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumReplies.
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply create
   */
  export type ForumReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumReply.
     */
    data: XOR<ForumReplyCreateInput, ForumReplyUncheckedCreateInput>
  }

  /**
   * ForumReply createMany
   */
  export type ForumReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumReplies.
     */
    data: ForumReplyCreateManyInput | ForumReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumReply createManyAndReturn
   */
  export type ForumReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumReplies.
     */
    data: ForumReplyCreateManyInput | ForumReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumReply update
   */
  export type ForumReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumReply.
     */
    data: XOR<ForumReplyUpdateInput, ForumReplyUncheckedUpdateInput>
    /**
     * Choose, which ForumReply to update.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply updateMany
   */
  export type ForumReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumReplies.
     */
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyInput>
    /**
     * Filter which ForumReplies to update
     */
    where?: ForumReplyWhereInput
  }

  /**
   * ForumReply upsert
   */
  export type ForumReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumReply to update in case it exists.
     */
    where: ForumReplyWhereUniqueInput
    /**
     * In case the ForumReply found by the `where` argument doesn't exist, create a new ForumReply with this data.
     */
    create: XOR<ForumReplyCreateInput, ForumReplyUncheckedCreateInput>
    /**
     * In case the ForumReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumReplyUpdateInput, ForumReplyUncheckedUpdateInput>
  }

  /**
   * ForumReply delete
   */
  export type ForumReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter which ForumReply to delete.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply deleteMany
   */
  export type ForumReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReplies to delete
     */
    where?: ForumReplyWhereInput
  }

  /**
   * ForumReply.likes
   */
  export type ForumReply$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    where?: ForumReplyLikeWhereInput
    orderBy?: ForumReplyLikeOrderByWithRelationInput | ForumReplyLikeOrderByWithRelationInput[]
    cursor?: ForumReplyLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyLikeScalarFieldEnum | ForumReplyLikeScalarFieldEnum[]
  }

  /**
   * ForumReply without action
   */
  export type ForumReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
  }


  /**
   * Model ForumTopicLike
   */

  export type AggregateForumTopicLike = {
    _count: ForumTopicLikeCountAggregateOutputType | null
    _min: ForumTopicLikeMinAggregateOutputType | null
    _max: ForumTopicLikeMaxAggregateOutputType | null
  }

  export type ForumTopicLikeMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ForumTopicLikeMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ForumTopicLikeCountAggregateOutputType = {
    id: number
    topicId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ForumTopicLikeMinAggregateInputType = {
    id?: true
    topicId?: true
    userId?: true
    createdAt?: true
  }

  export type ForumTopicLikeMaxAggregateInputType = {
    id?: true
    topicId?: true
    userId?: true
    createdAt?: true
  }

  export type ForumTopicLikeCountAggregateInputType = {
    id?: true
    topicId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ForumTopicLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopicLike to aggregate.
     */
    where?: ForumTopicLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopicLikes to fetch.
     */
    orderBy?: ForumTopicLikeOrderByWithRelationInput | ForumTopicLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumTopicLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopicLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopicLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumTopicLikes
    **/
    _count?: true | ForumTopicLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumTopicLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumTopicLikeMaxAggregateInputType
  }

  export type GetForumTopicLikeAggregateType<T extends ForumTopicLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateForumTopicLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumTopicLike[P]>
      : GetScalarType<T[P], AggregateForumTopicLike[P]>
  }




  export type ForumTopicLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicLikeWhereInput
    orderBy?: ForumTopicLikeOrderByWithAggregationInput | ForumTopicLikeOrderByWithAggregationInput[]
    by: ForumTopicLikeScalarFieldEnum[] | ForumTopicLikeScalarFieldEnum
    having?: ForumTopicLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumTopicLikeCountAggregateInputType | true
    _min?: ForumTopicLikeMinAggregateInputType
    _max?: ForumTopicLikeMaxAggregateInputType
  }

  export type ForumTopicLikeGroupByOutputType = {
    id: string
    topicId: string
    userId: string
    createdAt: Date
    _count: ForumTopicLikeCountAggregateOutputType | null
    _min: ForumTopicLikeMinAggregateOutputType | null
    _max: ForumTopicLikeMaxAggregateOutputType | null
  }

  type GetForumTopicLikeGroupByPayload<T extends ForumTopicLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumTopicLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumTopicLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumTopicLikeGroupByOutputType[P]>
            : GetScalarType<T[P], ForumTopicLikeGroupByOutputType[P]>
        }
      >
    >


  export type ForumTopicLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    userId?: boolean
    createdAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopicLike"]>

  export type ForumTopicLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    userId?: boolean
    createdAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopicLike"]>

  export type ForumTopicLikeSelectScalar = {
    id?: boolean
    topicId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ForumTopicLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }
  export type ForumTopicLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }

  export type $ForumTopicLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumTopicLike"
    objects: {
      topic: Prisma.$ForumTopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["forumTopicLike"]>
    composites: {}
  }

  type ForumTopicLikeGetPayload<S extends boolean | null | undefined | ForumTopicLikeDefaultArgs> = $Result.GetResult<Prisma.$ForumTopicLikePayload, S>

  type ForumTopicLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumTopicLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumTopicLikeCountAggregateInputType | true
    }

  export interface ForumTopicLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumTopicLike'], meta: { name: 'ForumTopicLike' } }
    /**
     * Find zero or one ForumTopicLike that matches the filter.
     * @param {ForumTopicLikeFindUniqueArgs} args - Arguments to find a ForumTopicLike
     * @example
     * // Get one ForumTopicLike
     * const forumTopicLike = await prisma.forumTopicLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumTopicLikeFindUniqueArgs>(args: SelectSubset<T, ForumTopicLikeFindUniqueArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumTopicLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumTopicLikeFindUniqueOrThrowArgs} args - Arguments to find a ForumTopicLike
     * @example
     * // Get one ForumTopicLike
     * const forumTopicLike = await prisma.forumTopicLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumTopicLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumTopicLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumTopicLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeFindFirstArgs} args - Arguments to find a ForumTopicLike
     * @example
     * // Get one ForumTopicLike
     * const forumTopicLike = await prisma.forumTopicLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumTopicLikeFindFirstArgs>(args?: SelectSubset<T, ForumTopicLikeFindFirstArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumTopicLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeFindFirstOrThrowArgs} args - Arguments to find a ForumTopicLike
     * @example
     * // Get one ForumTopicLike
     * const forumTopicLike = await prisma.forumTopicLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumTopicLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumTopicLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumTopicLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumTopicLikes
     * const forumTopicLikes = await prisma.forumTopicLike.findMany()
     * 
     * // Get first 10 ForumTopicLikes
     * const forumTopicLikes = await prisma.forumTopicLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumTopicLikeWithIdOnly = await prisma.forumTopicLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumTopicLikeFindManyArgs>(args?: SelectSubset<T, ForumTopicLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumTopicLike.
     * @param {ForumTopicLikeCreateArgs} args - Arguments to create a ForumTopicLike.
     * @example
     * // Create one ForumTopicLike
     * const ForumTopicLike = await prisma.forumTopicLike.create({
     *   data: {
     *     // ... data to create a ForumTopicLike
     *   }
     * })
     * 
     */
    create<T extends ForumTopicLikeCreateArgs>(args: SelectSubset<T, ForumTopicLikeCreateArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumTopicLikes.
     * @param {ForumTopicLikeCreateManyArgs} args - Arguments to create many ForumTopicLikes.
     * @example
     * // Create many ForumTopicLikes
     * const forumTopicLike = await prisma.forumTopicLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumTopicLikeCreateManyArgs>(args?: SelectSubset<T, ForumTopicLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumTopicLikes and returns the data saved in the database.
     * @param {ForumTopicLikeCreateManyAndReturnArgs} args - Arguments to create many ForumTopicLikes.
     * @example
     * // Create many ForumTopicLikes
     * const forumTopicLike = await prisma.forumTopicLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumTopicLikes and only return the `id`
     * const forumTopicLikeWithIdOnly = await prisma.forumTopicLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumTopicLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumTopicLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumTopicLike.
     * @param {ForumTopicLikeDeleteArgs} args - Arguments to delete one ForumTopicLike.
     * @example
     * // Delete one ForumTopicLike
     * const ForumTopicLike = await prisma.forumTopicLike.delete({
     *   where: {
     *     // ... filter to delete one ForumTopicLike
     *   }
     * })
     * 
     */
    delete<T extends ForumTopicLikeDeleteArgs>(args: SelectSubset<T, ForumTopicLikeDeleteArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumTopicLike.
     * @param {ForumTopicLikeUpdateArgs} args - Arguments to update one ForumTopicLike.
     * @example
     * // Update one ForumTopicLike
     * const forumTopicLike = await prisma.forumTopicLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumTopicLikeUpdateArgs>(args: SelectSubset<T, ForumTopicLikeUpdateArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumTopicLikes.
     * @param {ForumTopicLikeDeleteManyArgs} args - Arguments to filter ForumTopicLikes to delete.
     * @example
     * // Delete a few ForumTopicLikes
     * const { count } = await prisma.forumTopicLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumTopicLikeDeleteManyArgs>(args?: SelectSubset<T, ForumTopicLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopicLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumTopicLikes
     * const forumTopicLike = await prisma.forumTopicLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumTopicLikeUpdateManyArgs>(args: SelectSubset<T, ForumTopicLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumTopicLike.
     * @param {ForumTopicLikeUpsertArgs} args - Arguments to update or create a ForumTopicLike.
     * @example
     * // Update or create a ForumTopicLike
     * const forumTopicLike = await prisma.forumTopicLike.upsert({
     *   create: {
     *     // ... data to create a ForumTopicLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumTopicLike we want to update
     *   }
     * })
     */
    upsert<T extends ForumTopicLikeUpsertArgs>(args: SelectSubset<T, ForumTopicLikeUpsertArgs<ExtArgs>>): Prisma__ForumTopicLikeClient<$Result.GetResult<Prisma.$ForumTopicLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumTopicLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeCountArgs} args - Arguments to filter ForumTopicLikes to count.
     * @example
     * // Count the number of ForumTopicLikes
     * const count = await prisma.forumTopicLike.count({
     *   where: {
     *     // ... the filter for the ForumTopicLikes we want to count
     *   }
     * })
    **/
    count<T extends ForumTopicLikeCountArgs>(
      args?: Subset<T, ForumTopicLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumTopicLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumTopicLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumTopicLikeAggregateArgs>(args: Subset<T, ForumTopicLikeAggregateArgs>): Prisma.PrismaPromise<GetForumTopicLikeAggregateType<T>>

    /**
     * Group by ForumTopicLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumTopicLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumTopicLikeGroupByArgs['orderBy'] }
        : { orderBy?: ForumTopicLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumTopicLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumTopicLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumTopicLike model
   */
  readonly fields: ForumTopicLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumTopicLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumTopicLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends ForumTopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopicDefaultArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumTopicLike model
   */ 
  interface ForumTopicLikeFieldRefs {
    readonly id: FieldRef<"ForumTopicLike", 'String'>
    readonly topicId: FieldRef<"ForumTopicLike", 'String'>
    readonly userId: FieldRef<"ForumTopicLike", 'String'>
    readonly createdAt: FieldRef<"ForumTopicLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumTopicLike findUnique
   */
  export type ForumTopicLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopicLike to fetch.
     */
    where: ForumTopicLikeWhereUniqueInput
  }

  /**
   * ForumTopicLike findUniqueOrThrow
   */
  export type ForumTopicLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopicLike to fetch.
     */
    where: ForumTopicLikeWhereUniqueInput
  }

  /**
   * ForumTopicLike findFirst
   */
  export type ForumTopicLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopicLike to fetch.
     */
    where?: ForumTopicLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopicLikes to fetch.
     */
    orderBy?: ForumTopicLikeOrderByWithRelationInput | ForumTopicLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopicLikes.
     */
    cursor?: ForumTopicLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopicLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopicLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopicLikes.
     */
    distinct?: ForumTopicLikeScalarFieldEnum | ForumTopicLikeScalarFieldEnum[]
  }

  /**
   * ForumTopicLike findFirstOrThrow
   */
  export type ForumTopicLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopicLike to fetch.
     */
    where?: ForumTopicLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopicLikes to fetch.
     */
    orderBy?: ForumTopicLikeOrderByWithRelationInput | ForumTopicLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopicLikes.
     */
    cursor?: ForumTopicLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopicLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopicLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopicLikes.
     */
    distinct?: ForumTopicLikeScalarFieldEnum | ForumTopicLikeScalarFieldEnum[]
  }

  /**
   * ForumTopicLike findMany
   */
  export type ForumTopicLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopicLikes to fetch.
     */
    where?: ForumTopicLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopicLikes to fetch.
     */
    orderBy?: ForumTopicLikeOrderByWithRelationInput | ForumTopicLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumTopicLikes.
     */
    cursor?: ForumTopicLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopicLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopicLikes.
     */
    skip?: number
    distinct?: ForumTopicLikeScalarFieldEnum | ForumTopicLikeScalarFieldEnum[]
  }

  /**
   * ForumTopicLike create
   */
  export type ForumTopicLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumTopicLike.
     */
    data: XOR<ForumTopicLikeCreateInput, ForumTopicLikeUncheckedCreateInput>
  }

  /**
   * ForumTopicLike createMany
   */
  export type ForumTopicLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumTopicLikes.
     */
    data: ForumTopicLikeCreateManyInput | ForumTopicLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumTopicLike createManyAndReturn
   */
  export type ForumTopicLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumTopicLikes.
     */
    data: ForumTopicLikeCreateManyInput | ForumTopicLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumTopicLike update
   */
  export type ForumTopicLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumTopicLike.
     */
    data: XOR<ForumTopicLikeUpdateInput, ForumTopicLikeUncheckedUpdateInput>
    /**
     * Choose, which ForumTopicLike to update.
     */
    where: ForumTopicLikeWhereUniqueInput
  }

  /**
   * ForumTopicLike updateMany
   */
  export type ForumTopicLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumTopicLikes.
     */
    data: XOR<ForumTopicLikeUpdateManyMutationInput, ForumTopicLikeUncheckedUpdateManyInput>
    /**
     * Filter which ForumTopicLikes to update
     */
    where?: ForumTopicLikeWhereInput
  }

  /**
   * ForumTopicLike upsert
   */
  export type ForumTopicLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumTopicLike to update in case it exists.
     */
    where: ForumTopicLikeWhereUniqueInput
    /**
     * In case the ForumTopicLike found by the `where` argument doesn't exist, create a new ForumTopicLike with this data.
     */
    create: XOR<ForumTopicLikeCreateInput, ForumTopicLikeUncheckedCreateInput>
    /**
     * In case the ForumTopicLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumTopicLikeUpdateInput, ForumTopicLikeUncheckedUpdateInput>
  }

  /**
   * ForumTopicLike delete
   */
  export type ForumTopicLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
    /**
     * Filter which ForumTopicLike to delete.
     */
    where: ForumTopicLikeWhereUniqueInput
  }

  /**
   * ForumTopicLike deleteMany
   */
  export type ForumTopicLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopicLikes to delete
     */
    where?: ForumTopicLikeWhereInput
  }

  /**
   * ForumTopicLike without action
   */
  export type ForumTopicLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicLike
     */
    select?: ForumTopicLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicLikeInclude<ExtArgs> | null
  }


  /**
   * Model ForumReplyLike
   */

  export type AggregateForumReplyLike = {
    _count: ForumReplyLikeCountAggregateOutputType | null
    _min: ForumReplyLikeMinAggregateOutputType | null
    _max: ForumReplyLikeMaxAggregateOutputType | null
  }

  export type ForumReplyLikeMinAggregateOutputType = {
    id: string | null
    replyId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ForumReplyLikeMaxAggregateOutputType = {
    id: string | null
    replyId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ForumReplyLikeCountAggregateOutputType = {
    id: number
    replyId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ForumReplyLikeMinAggregateInputType = {
    id?: true
    replyId?: true
    userId?: true
    createdAt?: true
  }

  export type ForumReplyLikeMaxAggregateInputType = {
    id?: true
    replyId?: true
    userId?: true
    createdAt?: true
  }

  export type ForumReplyLikeCountAggregateInputType = {
    id?: true
    replyId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ForumReplyLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReplyLike to aggregate.
     */
    where?: ForumReplyLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyLikes to fetch.
     */
    orderBy?: ForumReplyLikeOrderByWithRelationInput | ForumReplyLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumReplyLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumReplyLikes
    **/
    _count?: true | ForumReplyLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumReplyLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumReplyLikeMaxAggregateInputType
  }

  export type GetForumReplyLikeAggregateType<T extends ForumReplyLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateForumReplyLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumReplyLike[P]>
      : GetScalarType<T[P], AggregateForumReplyLike[P]>
  }




  export type ForumReplyLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyLikeWhereInput
    orderBy?: ForumReplyLikeOrderByWithAggregationInput | ForumReplyLikeOrderByWithAggregationInput[]
    by: ForumReplyLikeScalarFieldEnum[] | ForumReplyLikeScalarFieldEnum
    having?: ForumReplyLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumReplyLikeCountAggregateInputType | true
    _min?: ForumReplyLikeMinAggregateInputType
    _max?: ForumReplyLikeMaxAggregateInputType
  }

  export type ForumReplyLikeGroupByOutputType = {
    id: string
    replyId: string
    userId: string
    createdAt: Date
    _count: ForumReplyLikeCountAggregateOutputType | null
    _min: ForumReplyLikeMinAggregateOutputType | null
    _max: ForumReplyLikeMaxAggregateOutputType | null
  }

  type GetForumReplyLikeGroupByPayload<T extends ForumReplyLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumReplyLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumReplyLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumReplyLikeGroupByOutputType[P]>
            : GetScalarType<T[P], ForumReplyLikeGroupByOutputType[P]>
        }
      >
    >


  export type ForumReplyLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    replyId?: boolean
    userId?: boolean
    createdAt?: boolean
    reply?: boolean | ForumReplyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReplyLike"]>

  export type ForumReplyLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    replyId?: boolean
    userId?: boolean
    createdAt?: boolean
    reply?: boolean | ForumReplyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReplyLike"]>

  export type ForumReplyLikeSelectScalar = {
    id?: boolean
    replyId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ForumReplyLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reply?: boolean | ForumReplyDefaultArgs<ExtArgs>
  }
  export type ForumReplyLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reply?: boolean | ForumReplyDefaultArgs<ExtArgs>
  }

  export type $ForumReplyLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumReplyLike"
    objects: {
      reply: Prisma.$ForumReplyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      replyId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["forumReplyLike"]>
    composites: {}
  }

  type ForumReplyLikeGetPayload<S extends boolean | null | undefined | ForumReplyLikeDefaultArgs> = $Result.GetResult<Prisma.$ForumReplyLikePayload, S>

  type ForumReplyLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumReplyLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumReplyLikeCountAggregateInputType | true
    }

  export interface ForumReplyLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumReplyLike'], meta: { name: 'ForumReplyLike' } }
    /**
     * Find zero or one ForumReplyLike that matches the filter.
     * @param {ForumReplyLikeFindUniqueArgs} args - Arguments to find a ForumReplyLike
     * @example
     * // Get one ForumReplyLike
     * const forumReplyLike = await prisma.forumReplyLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumReplyLikeFindUniqueArgs>(args: SelectSubset<T, ForumReplyLikeFindUniqueArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumReplyLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumReplyLikeFindUniqueOrThrowArgs} args - Arguments to find a ForumReplyLike
     * @example
     * // Get one ForumReplyLike
     * const forumReplyLike = await prisma.forumReplyLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumReplyLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumReplyLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumReplyLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeFindFirstArgs} args - Arguments to find a ForumReplyLike
     * @example
     * // Get one ForumReplyLike
     * const forumReplyLike = await prisma.forumReplyLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumReplyLikeFindFirstArgs>(args?: SelectSubset<T, ForumReplyLikeFindFirstArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumReplyLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeFindFirstOrThrowArgs} args - Arguments to find a ForumReplyLike
     * @example
     * // Get one ForumReplyLike
     * const forumReplyLike = await prisma.forumReplyLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumReplyLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumReplyLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumReplyLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumReplyLikes
     * const forumReplyLikes = await prisma.forumReplyLike.findMany()
     * 
     * // Get first 10 ForumReplyLikes
     * const forumReplyLikes = await prisma.forumReplyLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumReplyLikeWithIdOnly = await prisma.forumReplyLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumReplyLikeFindManyArgs>(args?: SelectSubset<T, ForumReplyLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumReplyLike.
     * @param {ForumReplyLikeCreateArgs} args - Arguments to create a ForumReplyLike.
     * @example
     * // Create one ForumReplyLike
     * const ForumReplyLike = await prisma.forumReplyLike.create({
     *   data: {
     *     // ... data to create a ForumReplyLike
     *   }
     * })
     * 
     */
    create<T extends ForumReplyLikeCreateArgs>(args: SelectSubset<T, ForumReplyLikeCreateArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumReplyLikes.
     * @param {ForumReplyLikeCreateManyArgs} args - Arguments to create many ForumReplyLikes.
     * @example
     * // Create many ForumReplyLikes
     * const forumReplyLike = await prisma.forumReplyLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumReplyLikeCreateManyArgs>(args?: SelectSubset<T, ForumReplyLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumReplyLikes and returns the data saved in the database.
     * @param {ForumReplyLikeCreateManyAndReturnArgs} args - Arguments to create many ForumReplyLikes.
     * @example
     * // Create many ForumReplyLikes
     * const forumReplyLike = await prisma.forumReplyLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumReplyLikes and only return the `id`
     * const forumReplyLikeWithIdOnly = await prisma.forumReplyLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumReplyLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumReplyLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumReplyLike.
     * @param {ForumReplyLikeDeleteArgs} args - Arguments to delete one ForumReplyLike.
     * @example
     * // Delete one ForumReplyLike
     * const ForumReplyLike = await prisma.forumReplyLike.delete({
     *   where: {
     *     // ... filter to delete one ForumReplyLike
     *   }
     * })
     * 
     */
    delete<T extends ForumReplyLikeDeleteArgs>(args: SelectSubset<T, ForumReplyLikeDeleteArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumReplyLike.
     * @param {ForumReplyLikeUpdateArgs} args - Arguments to update one ForumReplyLike.
     * @example
     * // Update one ForumReplyLike
     * const forumReplyLike = await prisma.forumReplyLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumReplyLikeUpdateArgs>(args: SelectSubset<T, ForumReplyLikeUpdateArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumReplyLikes.
     * @param {ForumReplyLikeDeleteManyArgs} args - Arguments to filter ForumReplyLikes to delete.
     * @example
     * // Delete a few ForumReplyLikes
     * const { count } = await prisma.forumReplyLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumReplyLikeDeleteManyArgs>(args?: SelectSubset<T, ForumReplyLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumReplyLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumReplyLikes
     * const forumReplyLike = await prisma.forumReplyLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumReplyLikeUpdateManyArgs>(args: SelectSubset<T, ForumReplyLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumReplyLike.
     * @param {ForumReplyLikeUpsertArgs} args - Arguments to update or create a ForumReplyLike.
     * @example
     * // Update or create a ForumReplyLike
     * const forumReplyLike = await prisma.forumReplyLike.upsert({
     *   create: {
     *     // ... data to create a ForumReplyLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumReplyLike we want to update
     *   }
     * })
     */
    upsert<T extends ForumReplyLikeUpsertArgs>(args: SelectSubset<T, ForumReplyLikeUpsertArgs<ExtArgs>>): Prisma__ForumReplyLikeClient<$Result.GetResult<Prisma.$ForumReplyLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumReplyLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeCountArgs} args - Arguments to filter ForumReplyLikes to count.
     * @example
     * // Count the number of ForumReplyLikes
     * const count = await prisma.forumReplyLike.count({
     *   where: {
     *     // ... the filter for the ForumReplyLikes we want to count
     *   }
     * })
    **/
    count<T extends ForumReplyLikeCountArgs>(
      args?: Subset<T, ForumReplyLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumReplyLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumReplyLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumReplyLikeAggregateArgs>(args: Subset<T, ForumReplyLikeAggregateArgs>): Prisma.PrismaPromise<GetForumReplyLikeAggregateType<T>>

    /**
     * Group by ForumReplyLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumReplyLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumReplyLikeGroupByArgs['orderBy'] }
        : { orderBy?: ForumReplyLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumReplyLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumReplyLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumReplyLike model
   */
  readonly fields: ForumReplyLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumReplyLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumReplyLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reply<T extends ForumReplyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumReplyDefaultArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumReplyLike model
   */ 
  interface ForumReplyLikeFieldRefs {
    readonly id: FieldRef<"ForumReplyLike", 'String'>
    readonly replyId: FieldRef<"ForumReplyLike", 'String'>
    readonly userId: FieldRef<"ForumReplyLike", 'String'>
    readonly createdAt: FieldRef<"ForumReplyLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumReplyLike findUnique
   */
  export type ForumReplyLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyLike to fetch.
     */
    where: ForumReplyLikeWhereUniqueInput
  }

  /**
   * ForumReplyLike findUniqueOrThrow
   */
  export type ForumReplyLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyLike to fetch.
     */
    where: ForumReplyLikeWhereUniqueInput
  }

  /**
   * ForumReplyLike findFirst
   */
  export type ForumReplyLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyLike to fetch.
     */
    where?: ForumReplyLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyLikes to fetch.
     */
    orderBy?: ForumReplyLikeOrderByWithRelationInput | ForumReplyLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplyLikes.
     */
    cursor?: ForumReplyLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplyLikes.
     */
    distinct?: ForumReplyLikeScalarFieldEnum | ForumReplyLikeScalarFieldEnum[]
  }

  /**
   * ForumReplyLike findFirstOrThrow
   */
  export type ForumReplyLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyLike to fetch.
     */
    where?: ForumReplyLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyLikes to fetch.
     */
    orderBy?: ForumReplyLikeOrderByWithRelationInput | ForumReplyLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplyLikes.
     */
    cursor?: ForumReplyLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplyLikes.
     */
    distinct?: ForumReplyLikeScalarFieldEnum | ForumReplyLikeScalarFieldEnum[]
  }

  /**
   * ForumReplyLike findMany
   */
  export type ForumReplyLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyLikes to fetch.
     */
    where?: ForumReplyLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyLikes to fetch.
     */
    orderBy?: ForumReplyLikeOrderByWithRelationInput | ForumReplyLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumReplyLikes.
     */
    cursor?: ForumReplyLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyLikes.
     */
    skip?: number
    distinct?: ForumReplyLikeScalarFieldEnum | ForumReplyLikeScalarFieldEnum[]
  }

  /**
   * ForumReplyLike create
   */
  export type ForumReplyLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumReplyLike.
     */
    data: XOR<ForumReplyLikeCreateInput, ForumReplyLikeUncheckedCreateInput>
  }

  /**
   * ForumReplyLike createMany
   */
  export type ForumReplyLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumReplyLikes.
     */
    data: ForumReplyLikeCreateManyInput | ForumReplyLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumReplyLike createManyAndReturn
   */
  export type ForumReplyLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumReplyLikes.
     */
    data: ForumReplyLikeCreateManyInput | ForumReplyLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumReplyLike update
   */
  export type ForumReplyLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumReplyLike.
     */
    data: XOR<ForumReplyLikeUpdateInput, ForumReplyLikeUncheckedUpdateInput>
    /**
     * Choose, which ForumReplyLike to update.
     */
    where: ForumReplyLikeWhereUniqueInput
  }

  /**
   * ForumReplyLike updateMany
   */
  export type ForumReplyLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumReplyLikes.
     */
    data: XOR<ForumReplyLikeUpdateManyMutationInput, ForumReplyLikeUncheckedUpdateManyInput>
    /**
     * Filter which ForumReplyLikes to update
     */
    where?: ForumReplyLikeWhereInput
  }

  /**
   * ForumReplyLike upsert
   */
  export type ForumReplyLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumReplyLike to update in case it exists.
     */
    where: ForumReplyLikeWhereUniqueInput
    /**
     * In case the ForumReplyLike found by the `where` argument doesn't exist, create a new ForumReplyLike with this data.
     */
    create: XOR<ForumReplyLikeCreateInput, ForumReplyLikeUncheckedCreateInput>
    /**
     * In case the ForumReplyLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumReplyLikeUpdateInput, ForumReplyLikeUncheckedUpdateInput>
  }

  /**
   * ForumReplyLike delete
   */
  export type ForumReplyLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
    /**
     * Filter which ForumReplyLike to delete.
     */
    where: ForumReplyLikeWhereUniqueInput
  }

  /**
   * ForumReplyLike deleteMany
   */
  export type ForumReplyLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReplyLikes to delete
     */
    where?: ForumReplyLikeWhereInput
  }

  /**
   * ForumReplyLike without action
   */
  export type ForumReplyLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyLike
     */
    select?: ForumReplyLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyLikeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    accountType: 'accountType',
    balance: 'balance',
    creditScore: 'creditScore',
    creditLimit: 'creditLimit',
    interestRate: 'interestRate',
    accountStatus: 'accountStatus',
    openedAt: 'openedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const BankTransactionScalarFieldEnum: {
    id: 'id',
    bankAccountId: 'bankAccountId',
    transactionType: 'transactionType',
    amount: 'amount',
    balanceAfter: 'balanceAfter',
    description: 'description',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankTransactionScalarFieldEnum = (typeof BankTransactionScalarFieldEnum)[keyof typeof BankTransactionScalarFieldEnum]


  export const CharacterKnowledgeScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    skillType: 'skillType',
    knowledgeType: 'knowledgeType',
    knowledgeName: 'knowledgeName',
    description: 'description',
    proficiency: 'proficiency',
    learnedAt: 'learnedAt',
    teacherNpcId: 'teacherNpcId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterKnowledgeScalarFieldEnum = (typeof CharacterKnowledgeScalarFieldEnum)[keyof typeof CharacterKnowledgeScalarFieldEnum]


  export const CharacterSkillScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    skillType: 'skillType',
    experience: 'experience',
    level: 'level',
    unlockedAt: 'unlockedAt',
    lastPracticed: 'lastPracticed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterSkillScalarFieldEnum = (typeof CharacterSkillScalarFieldEnum)[keyof typeof CharacterSkillScalarFieldEnum]


  export const DeliveryQuestScalarFieldEnum: {
    id: 'id',
    questId: 'questId',
    deliveryType: 'deliveryType',
    fromNpcId: 'fromNpcId',
    toNpcId: 'toNpcId',
    fromLocation: 'fromLocation',
    toLocation: 'toLocation',
    itemId: 'itemId',
    itemQuality: 'itemQuality',
    quantity: 'quantity',
    totalWeight: 'totalWeight',
    requiredCapacity: 'requiredCapacity',
    timeLimit: 'timeLimit',
    distance: 'distance',
    difficulty: 'difficulty',
    goldReward: 'goldReward',
    experienceReward: 'experienceReward',
    reputationReward: 'reputationReward',
    status: 'status',
    assignedTo: 'assignedTo',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    pickupConfirmed: 'pickupConfirmed',
    deliveryConfirmed: 'deliveryConfirmed',
    currentLocation: 'currentLocation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryQuestScalarFieldEnum = (typeof DeliveryQuestScalarFieldEnum)[keyof typeof DeliveryQuestScalarFieldEnum]


  export const GameCharacterScalarFieldEnum: {
    id: 'id',
    characterName: 'characterName',
    level: 'level',
    experience: 'experience',
    health: 'health',
    maxHealth: 'maxHealth',
    mana: 'mana',
    maxMana: 'maxMana',
    strength: 'strength',
    dexterity: 'dexterity',
    intelligence: 'intelligence',
    vitality: 'vitality',
    luck: 'luck',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    availableStatPoints: 'availableStatPoints',
    baseCarryingCapacity: 'baseCarryingCapacity',
    carryingCapacity: 'carryingCapacity',
    characterClass: 'characterClass',
    currentMapLocation: 'currentMapLocation',
    currentVolume: 'currentVolume',
    currentWeight: 'currentWeight',
    equippedArmor: 'equippedArmor',
    equippedBackpack: 'equippedBackpack',
    equippedWeapon: 'equippedWeapon',
    goldAmount: 'goldAmount',
    isResting: 'isResting',
    lastSaveTimestamp: 'lastSaveTimestamp',
    lastStaminaUpdate: 'lastStaminaUpdate',
    magicalStorageCapacity: 'magicalStorageCapacity',
    magicalStorageUsed: 'magicalStorageUsed',
    maxStamina: 'maxStamina',
    maxVolume: 'maxVolume',
    movementPenalty: 'movementPenalty',
    positionX: 'positionX',
    positionY: 'positionY',
    restStartTime: 'restStartTime',
    stamina: 'stamina',
    staminaRegenRate: 'staminaRegenRate',
    baseStamina: 'baseStamina',
    equippedGloves: 'equippedGloves',
    equippedPants: 'equippedPants',
    equippedShield: 'equippedShield',
    equippedShirt: 'equippedShirt',
    equippedShoes: 'equippedShoes',
    luckPercentage: 'luckPercentage'
  };

  export type GameCharacterScalarFieldEnum = (typeof GameCharacterScalarFieldEnum)[keyof typeof GameCharacterScalarFieldEnum]


  export const JobChangeHistoryScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    fromClass: 'fromClass',
    toClass: 'toClass',
    changedAt: 'changedAt',
    npcTrainerId: 'npcTrainerId',
    costPaid: 'costPaid',
    levelAtChange: 'levelAtChange',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobChangeHistoryScalarFieldEnum = (typeof JobChangeHistoryScalarFieldEnum)[keyof typeof JobChangeHistoryScalarFieldEnum]


  export const LoanPaymentScalarFieldEnum: {
    id: 'id',
    loanId: 'loanId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    principalPaid: 'principalPaid',
    interestPaid: 'interestPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanPaymentScalarFieldEnum = (typeof LoanPaymentScalarFieldEnum)[keyof typeof LoanPaymentScalarFieldEnum]


  export const LoanScalarFieldEnum: {
    id: 'id',
    bankAccountId: 'bankAccountId',
    principalAmount: 'principalAmount',
    interestRate: 'interestRate',
    termMonths: 'termMonths',
    monthlyPayment: 'monthlyPayment',
    remainingBalance: 'remainingBalance',
    status: 'status',
    loanPurpose: 'loanPurpose',
    nextPaymentDue: 'nextPaymentDue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanScalarFieldEnum = (typeof LoanScalarFieldEnum)[keyof typeof LoanScalarFieldEnum]


  export const LogisticsTrackingScalarFieldEnum: {
    id: 'id',
    trackingNumber: 'trackingNumber',
    deliveryQuestId: 'deliveryQuestId',
    routeId: 'routeId',
    itemId: 'itemId',
    quantity: 'quantity',
    weight: 'weight',
    status: 'status',
    currentLocation: 'currentLocation',
    scheduledPickup: 'scheduledPickup',
    actualPickup: 'actualPickup',
    scheduledDelivery: 'scheduledDelivery',
    actualDelivery: 'actualDelivery',
    handlerType: 'handlerType',
    handlerId: 'handlerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LogisticsTrackingScalarFieldEnum = (typeof LogisticsTrackingScalarFieldEnum)[keyof typeof LogisticsTrackingScalarFieldEnum]


  export const MagicalStorageScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    itemId: 'itemId',
    quantity: 'quantity',
    quality: 'quality',
    manaUsed: 'manaUsed',
    storedAt: 'storedAt',
    lastAccessedAt: 'lastAccessedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MagicalStorageScalarFieldEnum = (typeof MagicalStorageScalarFieldEnum)[keyof typeof MagicalStorageScalarFieldEnum]


  export const NpcDeliveryRouteScalarFieldEnum: {
    id: 'id',
    deliveryNpcId: 'deliveryNpcId',
    routeName: 'routeName',
    startLocation: 'startLocation',
    endLocation: 'endLocation',
    waypoints: 'waypoints',
    totalDistance: 'totalDistance',
    estimatedTime: 'estimatedTime',
    isActive: 'isActive',
    priority: 'priority',
    frequency: 'frequency',
    lastRun: 'lastRun',
    nextScheduledRun: 'nextScheduledRun',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NpcDeliveryRouteScalarFieldEnum = (typeof NpcDeliveryRouteScalarFieldEnum)[keyof typeof NpcDeliveryRouteScalarFieldEnum]


  export const OAuthProvidersScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    description: 'description',
    iconName: 'iconName',
    enabled: 'enabled',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OAuthProvidersScalarFieldEnum = (typeof OAuthProvidersScalarFieldEnum)[keyof typeof OAuthProvidersScalarFieldEnum]


  export const PlayerInventoryScalarFieldEnum: {
    id: 'id',
    character_id: 'character_id',
    item_id: 'item_id',
    quantity: 'quantity',
    quality: 'quality',
    weight: 'weight',
    totalWeight: 'totalWeight',
    volume: 'volume',
    totalVolume: 'totalVolume',
    slot: 'slot',
    is_equipped: 'is_equipped',
    equipment_slot: 'equipment_slot',
    condition: 'condition',
    is_stackable: 'is_stackable',
    max_stack: 'max_stack',
    acquired_at: 'acquired_at',
    last_used_at: 'last_used_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PlayerInventoryScalarFieldEnum = (typeof PlayerInventoryScalarFieldEnum)[keyof typeof PlayerInventoryScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SkillDecayLogScalarFieldEnum: {
    id: 'id',
    character_id: 'character_id',
    skill_type: 'skill_type',
    knowledge_name: 'knowledge_name',
    event_type: 'event_type',
    original_value: 'original_value',
    new_value: 'new_value',
    decay_amount: 'decay_amount',
    days_since_last_practice: 'days_since_last_practice',
    action: 'action',
    timestamp: 'timestamp',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SkillDecayLogScalarFieldEnum = (typeof SkillDecayLogScalarFieldEnum)[keyof typeof SkillDecayLogScalarFieldEnum]


  export const SkillPracticeHistoryScalarFieldEnum: {
    id: 'id',
    skill_id: 'skill_id',
    practice_type: 'practice_type',
    practice_intensity: 'practice_intensity',
    experience_gained: 'experience_gained',
    proficiency_gained: 'proficiency_gained',
    knowledge_used: 'knowledge_used',
    timestamp: 'timestamp',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SkillPracticeHistoryScalarFieldEnum = (typeof SkillPracticeHistoryScalarFieldEnum)[keyof typeof SkillPracticeHistoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserEmailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserEmailScalarFieldEnum = (typeof UserEmailScalarFieldEnum)[keyof typeof UserEmailScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    bio: 'bio',
    location: 'location',
    motto: 'motto',
    title: 'title',
    phone: 'phone',
    website: 'website',
    discordTag: 'discordTag',
    githubUrl: 'githubUrl',
    facebookUrl: 'facebookUrl',
    instagramUrl: 'instagramUrl',
    xUrl: 'xUrl',
    linkedinUrl: 'linkedinUrl',
    snapchatUrl: 'snapchatUrl',
    favoriteClass: 'favoriteClass',
    playStyle: 'playStyle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardColor: 'cardColor',
    cardTheme: 'cardTheme',
    publicEmailChoice: 'publicEmailChoice',
    theme: 'theme',
    language: 'language',
    pinnedForums: 'pinnedForums',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isProfilePublic: 'isProfilePublic'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const UserPresenceScalarFieldEnum: {
    userId: 'userId',
    isOnline: 'isOnline',
    lastSeen: 'lastSeen',
    updatedAt: 'updatedAt'
  };

  export type UserPresenceScalarFieldEnum = (typeof UserPresenceScalarFieldEnum)[keyof typeof UserPresenceScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const JwksScalarFieldEnum: {
    id: 'id',
    publicKey: 'publicKey',
    privateKey: 'privateKey',
    createdAt: 'createdAt'
  };

  export type JwksScalarFieldEnum = (typeof JwksScalarFieldEnum)[keyof typeof JwksScalarFieldEnum]


  export const FriendRequestScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FriendRequestScalarFieldEnum = (typeof FriendRequestScalarFieldEnum)[keyof typeof FriendRequestScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    user1Id: 'user1Id',
    user2Id: 'user2Id',
    createdAt: 'createdAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const BlockedUserScalarFieldEnum: {
    id: 'id',
    blockedById: 'blockedById',
    blockedUserId: 'blockedUserId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type BlockedUserScalarFieldEnum = (typeof BlockedUserScalarFieldEnum)[keyof typeof BlockedUserScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    type: 'type',
    isRead: 'isRead',
    isDelivered: 'isDelivered',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    title: 'title',
    content: 'content',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const ForumTopicScalarFieldEnum: {
    id: 'id',
    forumId: 'forumId',
    title: 'title',
    content: 'content',
    type: 'type',
    tags: 'tags',
    authorId: 'authorId',
    views: 'views',
    isPinned: 'isPinned',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumTopicScalarFieldEnum = (typeof ForumTopicScalarFieldEnum)[keyof typeof ForumTopicScalarFieldEnum]


  export const ForumReplyScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    content: 'content',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumReplyScalarFieldEnum = (typeof ForumReplyScalarFieldEnum)[keyof typeof ForumReplyScalarFieldEnum]


  export const ForumTopicLikeScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ForumTopicLikeScalarFieldEnum = (typeof ForumTopicLikeScalarFieldEnum)[keyof typeof ForumTopicLikeScalarFieldEnum]


  export const ForumReplyLikeScalarFieldEnum: {
    id: 'id',
    replyId: 'replyId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ForumReplyLikeScalarFieldEnum = (typeof ForumReplyLikeScalarFieldEnum)[keyof typeof ForumReplyLikeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FriendRequestStatus'
   */
  export type EnumFriendRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendRequestStatus'>
    


  /**
   * Reference to a field of type 'FriendRequestStatus[]'
   */
  export type ListEnumFriendRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendRequestStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'ForumCategory'
   */
  export type EnumForumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForumCategory'>
    


  /**
   * Reference to a field of type 'ForumCategory[]'
   */
  export type ListEnumForumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForumCategory[]'>
    


  /**
   * Reference to a field of type 'TopicType'
   */
  export type EnumTopicTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicType'>
    


  /**
   * Reference to a field of type 'TopicType[]'
   */
  export type ListEnumTopicTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicType[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    characterId?: StringFilter<"BankAccount"> | string
    accountType?: StringFilter<"BankAccount"> | string
    balance?: FloatFilter<"BankAccount"> | number
    creditScore?: IntFilter<"BankAccount"> | number
    creditLimit?: FloatFilter<"BankAccount"> | number
    interestRate?: FloatFilter<"BankAccount"> | number
    accountStatus?: StringFilter<"BankAccount"> | string
    openedAt?: DateTimeFilter<"BankAccount"> | Date | string
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
    bankTransactions?: BankTransactionListRelationFilter
    loans?: LoanListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
    accountStatus?: SortOrder
    openedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameCharacter?: GameCharacterOrderByWithRelationInput
    bankTransactions?: BankTransactionOrderByRelationAggregateInput
    loans?: LoanOrderByRelationAggregateInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    accountType?: StringFilter<"BankAccount"> | string
    balance?: FloatFilter<"BankAccount"> | number
    creditScore?: IntFilter<"BankAccount"> | number
    creditLimit?: FloatFilter<"BankAccount"> | number
    interestRate?: FloatFilter<"BankAccount"> | number
    accountStatus?: StringFilter<"BankAccount"> | string
    openedAt?: DateTimeFilter<"BankAccount"> | Date | string
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
    bankTransactions?: BankTransactionListRelationFilter
    loans?: LoanListRelationFilter
  }, "id" | "characterId">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
    accountStatus?: SortOrder
    openedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    characterId?: StringWithAggregatesFilter<"BankAccount"> | string
    accountType?: StringWithAggregatesFilter<"BankAccount"> | string
    balance?: FloatWithAggregatesFilter<"BankAccount"> | number
    creditScore?: IntWithAggregatesFilter<"BankAccount"> | number
    creditLimit?: FloatWithAggregatesFilter<"BankAccount"> | number
    interestRate?: FloatWithAggregatesFilter<"BankAccount"> | number
    accountStatus?: StringWithAggregatesFilter<"BankAccount"> | string
    openedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type BankTransactionWhereInput = {
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    id?: StringFilter<"BankTransaction"> | string
    bankAccountId?: StringFilter<"BankTransaction"> | string
    transactionType?: StringFilter<"BankTransaction"> | string
    amount?: FloatFilter<"BankTransaction"> | number
    balanceAfter?: FloatFilter<"BankTransaction"> | number
    description?: StringNullableFilter<"BankTransaction"> | string | null
    timestamp?: DateTimeFilter<"BankTransaction"> | Date | string
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccount?: XOR<BankAccountRelationFilter, BankAccountWhereInput>
  }

  export type BankTransactionOrderByWithRelationInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bankAccount?: BankAccountOrderByWithRelationInput
  }

  export type BankTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    bankAccountId?: StringFilter<"BankTransaction"> | string
    transactionType?: StringFilter<"BankTransaction"> | string
    amount?: FloatFilter<"BankTransaction"> | number
    balanceAfter?: FloatFilter<"BankTransaction"> | number
    description?: StringNullableFilter<"BankTransaction"> | string | null
    timestamp?: DateTimeFilter<"BankTransaction"> | Date | string
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
    bankAccount?: XOR<BankAccountRelationFilter, BankAccountWhereInput>
  }, "id">

  export type BankTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankTransactionCountOrderByAggregateInput
    _avg?: BankTransactionAvgOrderByAggregateInput
    _max?: BankTransactionMaxOrderByAggregateInput
    _min?: BankTransactionMinOrderByAggregateInput
    _sum?: BankTransactionSumOrderByAggregateInput
  }

  export type BankTransactionScalarWhereWithAggregatesInput = {
    AND?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    OR?: BankTransactionScalarWhereWithAggregatesInput[]
    NOT?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankTransaction"> | string
    bankAccountId?: StringWithAggregatesFilter<"BankTransaction"> | string
    transactionType?: StringWithAggregatesFilter<"BankTransaction"> | string
    amount?: FloatWithAggregatesFilter<"BankTransaction"> | number
    balanceAfter?: FloatWithAggregatesFilter<"BankTransaction"> | number
    description?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
  }

  export type CharacterKnowledgeWhereInput = {
    AND?: CharacterKnowledgeWhereInput | CharacterKnowledgeWhereInput[]
    OR?: CharacterKnowledgeWhereInput[]
    NOT?: CharacterKnowledgeWhereInput | CharacterKnowledgeWhereInput[]
    id?: StringFilter<"CharacterKnowledge"> | string
    characterId?: StringFilter<"CharacterKnowledge"> | string
    skillType?: StringFilter<"CharacterKnowledge"> | string
    knowledgeType?: StringFilter<"CharacterKnowledge"> | string
    knowledgeName?: StringFilter<"CharacterKnowledge"> | string
    description?: StringNullableFilter<"CharacterKnowledge"> | string | null
    proficiency?: IntFilter<"CharacterKnowledge"> | number
    learnedAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    teacherNpcId?: StringNullableFilter<"CharacterKnowledge"> | string | null
    createdAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }

  export type CharacterKnowledgeOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    knowledgeType?: SortOrder
    knowledgeName?: SortOrder
    description?: SortOrderInput | SortOrder
    proficiency?: SortOrder
    learnedAt?: SortOrder
    teacherNpcId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameCharacter?: GameCharacterOrderByWithRelationInput
  }

  export type CharacterKnowledgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_skillType_knowledgeName?: CharacterKnowledgeCharacterIdSkillTypeKnowledgeNameCompoundUniqueInput
    AND?: CharacterKnowledgeWhereInput | CharacterKnowledgeWhereInput[]
    OR?: CharacterKnowledgeWhereInput[]
    NOT?: CharacterKnowledgeWhereInput | CharacterKnowledgeWhereInput[]
    characterId?: StringFilter<"CharacterKnowledge"> | string
    skillType?: StringFilter<"CharacterKnowledge"> | string
    knowledgeType?: StringFilter<"CharacterKnowledge"> | string
    knowledgeName?: StringFilter<"CharacterKnowledge"> | string
    description?: StringNullableFilter<"CharacterKnowledge"> | string | null
    proficiency?: IntFilter<"CharacterKnowledge"> | number
    learnedAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    teacherNpcId?: StringNullableFilter<"CharacterKnowledge"> | string | null
    createdAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }, "id" | "characterId_skillType_knowledgeName">

  export type CharacterKnowledgeOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    knowledgeType?: SortOrder
    knowledgeName?: SortOrder
    description?: SortOrderInput | SortOrder
    proficiency?: SortOrder
    learnedAt?: SortOrder
    teacherNpcId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterKnowledgeCountOrderByAggregateInput
    _avg?: CharacterKnowledgeAvgOrderByAggregateInput
    _max?: CharacterKnowledgeMaxOrderByAggregateInput
    _min?: CharacterKnowledgeMinOrderByAggregateInput
    _sum?: CharacterKnowledgeSumOrderByAggregateInput
  }

  export type CharacterKnowledgeScalarWhereWithAggregatesInput = {
    AND?: CharacterKnowledgeScalarWhereWithAggregatesInput | CharacterKnowledgeScalarWhereWithAggregatesInput[]
    OR?: CharacterKnowledgeScalarWhereWithAggregatesInput[]
    NOT?: CharacterKnowledgeScalarWhereWithAggregatesInput | CharacterKnowledgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterKnowledge"> | string
    characterId?: StringWithAggregatesFilter<"CharacterKnowledge"> | string
    skillType?: StringWithAggregatesFilter<"CharacterKnowledge"> | string
    knowledgeType?: StringWithAggregatesFilter<"CharacterKnowledge"> | string
    knowledgeName?: StringWithAggregatesFilter<"CharacterKnowledge"> | string
    description?: StringNullableWithAggregatesFilter<"CharacterKnowledge"> | string | null
    proficiency?: IntWithAggregatesFilter<"CharacterKnowledge"> | number
    learnedAt?: DateTimeWithAggregatesFilter<"CharacterKnowledge"> | Date | string
    teacherNpcId?: StringNullableWithAggregatesFilter<"CharacterKnowledge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CharacterKnowledge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterKnowledge"> | Date | string
  }

  export type CharacterSkillWhereInput = {
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    characterId?: StringFilter<"CharacterSkill"> | string
    skillType?: StringFilter<"CharacterSkill"> | string
    experience?: IntFilter<"CharacterSkill"> | number
    level?: StringFilter<"CharacterSkill"> | string
    unlockedAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    lastPracticed?: DateTimeNullableFilter<"CharacterSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
    skillPracticeHistory?: SkillPracticeHistoryListRelationFilter
  }

  export type CharacterSkillOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    experience?: SortOrder
    level?: SortOrder
    unlockedAt?: SortOrder
    lastPracticed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameCharacter?: GameCharacterOrderByWithRelationInput
    skillPracticeHistory?: SkillPracticeHistoryOrderByRelationAggregateInput
  }

  export type CharacterSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_skillType?: CharacterSkillCharacterIdSkillTypeCompoundUniqueInput
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    characterId?: StringFilter<"CharacterSkill"> | string
    skillType?: StringFilter<"CharacterSkill"> | string
    experience?: IntFilter<"CharacterSkill"> | number
    level?: StringFilter<"CharacterSkill"> | string
    unlockedAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    lastPracticed?: DateTimeNullableFilter<"CharacterSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
    skillPracticeHistory?: SkillPracticeHistoryListRelationFilter
  }, "id" | "characterId_skillType">

  export type CharacterSkillOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    experience?: SortOrder
    level?: SortOrder
    unlockedAt?: SortOrder
    lastPracticed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterSkillCountOrderByAggregateInput
    _avg?: CharacterSkillAvgOrderByAggregateInput
    _max?: CharacterSkillMaxOrderByAggregateInput
    _min?: CharacterSkillMinOrderByAggregateInput
    _sum?: CharacterSkillSumOrderByAggregateInput
  }

  export type CharacterSkillScalarWhereWithAggregatesInput = {
    AND?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    OR?: CharacterSkillScalarWhereWithAggregatesInput[]
    NOT?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterSkill"> | string
    characterId?: StringWithAggregatesFilter<"CharacterSkill"> | string
    skillType?: StringWithAggregatesFilter<"CharacterSkill"> | string
    experience?: IntWithAggregatesFilter<"CharacterSkill"> | number
    level?: StringWithAggregatesFilter<"CharacterSkill"> | string
    unlockedAt?: DateTimeWithAggregatesFilter<"CharacterSkill"> | Date | string
    lastPracticed?: DateTimeNullableWithAggregatesFilter<"CharacterSkill"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CharacterSkill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CharacterSkill"> | Date | string
  }

  export type DeliveryQuestWhereInput = {
    AND?: DeliveryQuestWhereInput | DeliveryQuestWhereInput[]
    OR?: DeliveryQuestWhereInput[]
    NOT?: DeliveryQuestWhereInput | DeliveryQuestWhereInput[]
    id?: StringFilter<"DeliveryQuest"> | string
    questId?: StringFilter<"DeliveryQuest"> | string
    deliveryType?: StringFilter<"DeliveryQuest"> | string
    fromNpcId?: StringFilter<"DeliveryQuest"> | string
    toNpcId?: StringFilter<"DeliveryQuest"> | string
    fromLocation?: StringFilter<"DeliveryQuest"> | string
    toLocation?: StringFilter<"DeliveryQuest"> | string
    itemId?: StringFilter<"DeliveryQuest"> | string
    itemQuality?: StringFilter<"DeliveryQuest"> | string
    quantity?: IntFilter<"DeliveryQuest"> | number
    totalWeight?: FloatFilter<"DeliveryQuest"> | number
    requiredCapacity?: FloatFilter<"DeliveryQuest"> | number
    timeLimit?: IntNullableFilter<"DeliveryQuest"> | number | null
    distance?: FloatFilter<"DeliveryQuest"> | number
    difficulty?: StringFilter<"DeliveryQuest"> | string
    goldReward?: IntFilter<"DeliveryQuest"> | number
    experienceReward?: IntFilter<"DeliveryQuest"> | number
    reputationReward?: IntFilter<"DeliveryQuest"> | number
    status?: StringFilter<"DeliveryQuest"> | string
    assignedTo?: StringNullableFilter<"DeliveryQuest"> | string | null
    startedAt?: DateTimeNullableFilter<"DeliveryQuest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryQuest"> | Date | string | null
    pickupConfirmed?: BoolFilter<"DeliveryQuest"> | boolean
    deliveryConfirmed?: BoolFilter<"DeliveryQuest"> | boolean
    currentLocation?: StringNullableFilter<"DeliveryQuest"> | string | null
    createdAt?: DateTimeFilter<"DeliveryQuest"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryQuest"> | Date | string
  }

  export type DeliveryQuestOrderByWithRelationInput = {
    id?: SortOrder
    questId?: SortOrder
    deliveryType?: SortOrder
    fromNpcId?: SortOrder
    toNpcId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    itemId?: SortOrder
    itemQuality?: SortOrder
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pickupConfirmed?: SortOrder
    deliveryConfirmed?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryQuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questId?: string
    AND?: DeliveryQuestWhereInput | DeliveryQuestWhereInput[]
    OR?: DeliveryQuestWhereInput[]
    NOT?: DeliveryQuestWhereInput | DeliveryQuestWhereInput[]
    deliveryType?: StringFilter<"DeliveryQuest"> | string
    fromNpcId?: StringFilter<"DeliveryQuest"> | string
    toNpcId?: StringFilter<"DeliveryQuest"> | string
    fromLocation?: StringFilter<"DeliveryQuest"> | string
    toLocation?: StringFilter<"DeliveryQuest"> | string
    itemId?: StringFilter<"DeliveryQuest"> | string
    itemQuality?: StringFilter<"DeliveryQuest"> | string
    quantity?: IntFilter<"DeliveryQuest"> | number
    totalWeight?: FloatFilter<"DeliveryQuest"> | number
    requiredCapacity?: FloatFilter<"DeliveryQuest"> | number
    timeLimit?: IntNullableFilter<"DeliveryQuest"> | number | null
    distance?: FloatFilter<"DeliveryQuest"> | number
    difficulty?: StringFilter<"DeliveryQuest"> | string
    goldReward?: IntFilter<"DeliveryQuest"> | number
    experienceReward?: IntFilter<"DeliveryQuest"> | number
    reputationReward?: IntFilter<"DeliveryQuest"> | number
    status?: StringFilter<"DeliveryQuest"> | string
    assignedTo?: StringNullableFilter<"DeliveryQuest"> | string | null
    startedAt?: DateTimeNullableFilter<"DeliveryQuest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeliveryQuest"> | Date | string | null
    pickupConfirmed?: BoolFilter<"DeliveryQuest"> | boolean
    deliveryConfirmed?: BoolFilter<"DeliveryQuest"> | boolean
    currentLocation?: StringNullableFilter<"DeliveryQuest"> | string | null
    createdAt?: DateTimeFilter<"DeliveryQuest"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryQuest"> | Date | string
  }, "id" | "questId">

  export type DeliveryQuestOrderByWithAggregationInput = {
    id?: SortOrder
    questId?: SortOrder
    deliveryType?: SortOrder
    fromNpcId?: SortOrder
    toNpcId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    itemId?: SortOrder
    itemQuality?: SortOrder
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pickupConfirmed?: SortOrder
    deliveryConfirmed?: SortOrder
    currentLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryQuestCountOrderByAggregateInput
    _avg?: DeliveryQuestAvgOrderByAggregateInput
    _max?: DeliveryQuestMaxOrderByAggregateInput
    _min?: DeliveryQuestMinOrderByAggregateInput
    _sum?: DeliveryQuestSumOrderByAggregateInput
  }

  export type DeliveryQuestScalarWhereWithAggregatesInput = {
    AND?: DeliveryQuestScalarWhereWithAggregatesInput | DeliveryQuestScalarWhereWithAggregatesInput[]
    OR?: DeliveryQuestScalarWhereWithAggregatesInput[]
    NOT?: DeliveryQuestScalarWhereWithAggregatesInput | DeliveryQuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    questId?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    deliveryType?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    fromNpcId?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    toNpcId?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    fromLocation?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    toLocation?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    itemId?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    itemQuality?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    quantity?: IntWithAggregatesFilter<"DeliveryQuest"> | number
    totalWeight?: FloatWithAggregatesFilter<"DeliveryQuest"> | number
    requiredCapacity?: FloatWithAggregatesFilter<"DeliveryQuest"> | number
    timeLimit?: IntNullableWithAggregatesFilter<"DeliveryQuest"> | number | null
    distance?: FloatWithAggregatesFilter<"DeliveryQuest"> | number
    difficulty?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    goldReward?: IntWithAggregatesFilter<"DeliveryQuest"> | number
    experienceReward?: IntWithAggregatesFilter<"DeliveryQuest"> | number
    reputationReward?: IntWithAggregatesFilter<"DeliveryQuest"> | number
    status?: StringWithAggregatesFilter<"DeliveryQuest"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"DeliveryQuest"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeliveryQuest"> | Date | string | null
    pickupConfirmed?: BoolWithAggregatesFilter<"DeliveryQuest"> | boolean
    deliveryConfirmed?: BoolWithAggregatesFilter<"DeliveryQuest"> | boolean
    currentLocation?: StringNullableWithAggregatesFilter<"DeliveryQuest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryQuest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryQuest"> | Date | string
  }

  export type GameCharacterWhereInput = {
    AND?: GameCharacterWhereInput | GameCharacterWhereInput[]
    OR?: GameCharacterWhereInput[]
    NOT?: GameCharacterWhereInput | GameCharacterWhereInput[]
    id?: StringFilter<"GameCharacter"> | string
    characterName?: StringFilter<"GameCharacter"> | string
    level?: IntFilter<"GameCharacter"> | number
    experience?: IntFilter<"GameCharacter"> | number
    health?: IntFilter<"GameCharacter"> | number
    maxHealth?: IntFilter<"GameCharacter"> | number
    mana?: IntFilter<"GameCharacter"> | number
    maxMana?: IntFilter<"GameCharacter"> | number
    strength?: IntFilter<"GameCharacter"> | number
    dexterity?: IntFilter<"GameCharacter"> | number
    intelligence?: IntFilter<"GameCharacter"> | number
    vitality?: IntFilter<"GameCharacter"> | number
    luck?: IntFilter<"GameCharacter"> | number
    createdAt?: DateTimeFilter<"GameCharacter"> | Date | string
    updatedAt?: DateTimeFilter<"GameCharacter"> | Date | string
    userId?: StringFilter<"GameCharacter"> | string
    availableStatPoints?: IntFilter<"GameCharacter"> | number
    baseCarryingCapacity?: FloatFilter<"GameCharacter"> | number
    carryingCapacity?: FloatFilter<"GameCharacter"> | number
    characterClass?: StringFilter<"GameCharacter"> | string
    currentMapLocation?: StringFilter<"GameCharacter"> | string
    currentVolume?: FloatFilter<"GameCharacter"> | number
    currentWeight?: FloatFilter<"GameCharacter"> | number
    equippedArmor?: StringNullableFilter<"GameCharacter"> | string | null
    equippedBackpack?: StringNullableFilter<"GameCharacter"> | string | null
    equippedWeapon?: StringNullableFilter<"GameCharacter"> | string | null
    goldAmount?: IntFilter<"GameCharacter"> | number
    isResting?: BoolFilter<"GameCharacter"> | boolean
    lastSaveTimestamp?: DateTimeFilter<"GameCharacter"> | Date | string
    lastStaminaUpdate?: DateTimeFilter<"GameCharacter"> | Date | string
    magicalStorageCapacity?: FloatFilter<"GameCharacter"> | number
    magicalStorageUsed?: FloatFilter<"GameCharacter"> | number
    maxStamina?: FloatFilter<"GameCharacter"> | number
    maxVolume?: FloatFilter<"GameCharacter"> | number
    movementPenalty?: FloatFilter<"GameCharacter"> | number
    positionX?: FloatFilter<"GameCharacter"> | number
    positionY?: FloatFilter<"GameCharacter"> | number
    restStartTime?: DateTimeNullableFilter<"GameCharacter"> | Date | string | null
    stamina?: FloatFilter<"GameCharacter"> | number
    staminaRegenRate?: FloatFilter<"GameCharacter"> | number
    baseStamina?: IntFilter<"GameCharacter"> | number
    equippedGloves?: StringNullableFilter<"GameCharacter"> | string | null
    equippedPants?: StringNullableFilter<"GameCharacter"> | string | null
    equippedShield?: StringNullableFilter<"GameCharacter"> | string | null
    equippedShirt?: StringNullableFilter<"GameCharacter"> | string | null
    equippedShoes?: StringNullableFilter<"GameCharacter"> | string | null
    luckPercentage?: FloatFilter<"GameCharacter"> | number
    bankAccounts?: XOR<BankAccountNullableRelationFilter, BankAccountWhereInput> | null
    characterKnowledges?: CharacterKnowledgeListRelationFilter
    characterSkills?: CharacterSkillListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    jobChangeHistory?: JobChangeHistoryListRelationFilter
    magicalStorage?: MagicalStorageListRelationFilter
    playerInventories?: PlayerInventoryListRelationFilter
  }

  export type GameCharacterOrderByWithRelationInput = {
    id?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    characterClass?: SortOrder
    currentMapLocation?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    equippedArmor?: SortOrderInput | SortOrder
    equippedBackpack?: SortOrderInput | SortOrder
    equippedWeapon?: SortOrderInput | SortOrder
    goldAmount?: SortOrder
    isResting?: SortOrder
    lastSaveTimestamp?: SortOrder
    lastStaminaUpdate?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    restStartTime?: SortOrderInput | SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    equippedGloves?: SortOrderInput | SortOrder
    equippedPants?: SortOrderInput | SortOrder
    equippedShield?: SortOrderInput | SortOrder
    equippedShirt?: SortOrderInput | SortOrder
    equippedShoes?: SortOrderInput | SortOrder
    luckPercentage?: SortOrder
    bankAccounts?: BankAccountOrderByWithRelationInput
    characterKnowledges?: CharacterKnowledgeOrderByRelationAggregateInput
    characterSkills?: CharacterSkillOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    jobChangeHistory?: JobChangeHistoryOrderByRelationAggregateInput
    magicalStorage?: MagicalStorageOrderByRelationAggregateInput
    playerInventories?: PlayerInventoryOrderByRelationAggregateInput
  }

  export type GameCharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GameCharacterWhereInput | GameCharacterWhereInput[]
    OR?: GameCharacterWhereInput[]
    NOT?: GameCharacterWhereInput | GameCharacterWhereInput[]
    characterName?: StringFilter<"GameCharacter"> | string
    level?: IntFilter<"GameCharacter"> | number
    experience?: IntFilter<"GameCharacter"> | number
    health?: IntFilter<"GameCharacter"> | number
    maxHealth?: IntFilter<"GameCharacter"> | number
    mana?: IntFilter<"GameCharacter"> | number
    maxMana?: IntFilter<"GameCharacter"> | number
    strength?: IntFilter<"GameCharacter"> | number
    dexterity?: IntFilter<"GameCharacter"> | number
    intelligence?: IntFilter<"GameCharacter"> | number
    vitality?: IntFilter<"GameCharacter"> | number
    luck?: IntFilter<"GameCharacter"> | number
    createdAt?: DateTimeFilter<"GameCharacter"> | Date | string
    updatedAt?: DateTimeFilter<"GameCharacter"> | Date | string
    availableStatPoints?: IntFilter<"GameCharacter"> | number
    baseCarryingCapacity?: FloatFilter<"GameCharacter"> | number
    carryingCapacity?: FloatFilter<"GameCharacter"> | number
    characterClass?: StringFilter<"GameCharacter"> | string
    currentMapLocation?: StringFilter<"GameCharacter"> | string
    currentVolume?: FloatFilter<"GameCharacter"> | number
    currentWeight?: FloatFilter<"GameCharacter"> | number
    equippedArmor?: StringNullableFilter<"GameCharacter"> | string | null
    equippedBackpack?: StringNullableFilter<"GameCharacter"> | string | null
    equippedWeapon?: StringNullableFilter<"GameCharacter"> | string | null
    goldAmount?: IntFilter<"GameCharacter"> | number
    isResting?: BoolFilter<"GameCharacter"> | boolean
    lastSaveTimestamp?: DateTimeFilter<"GameCharacter"> | Date | string
    lastStaminaUpdate?: DateTimeFilter<"GameCharacter"> | Date | string
    magicalStorageCapacity?: FloatFilter<"GameCharacter"> | number
    magicalStorageUsed?: FloatFilter<"GameCharacter"> | number
    maxStamina?: FloatFilter<"GameCharacter"> | number
    maxVolume?: FloatFilter<"GameCharacter"> | number
    movementPenalty?: FloatFilter<"GameCharacter"> | number
    positionX?: FloatFilter<"GameCharacter"> | number
    positionY?: FloatFilter<"GameCharacter"> | number
    restStartTime?: DateTimeNullableFilter<"GameCharacter"> | Date | string | null
    stamina?: FloatFilter<"GameCharacter"> | number
    staminaRegenRate?: FloatFilter<"GameCharacter"> | number
    baseStamina?: IntFilter<"GameCharacter"> | number
    equippedGloves?: StringNullableFilter<"GameCharacter"> | string | null
    equippedPants?: StringNullableFilter<"GameCharacter"> | string | null
    equippedShield?: StringNullableFilter<"GameCharacter"> | string | null
    equippedShirt?: StringNullableFilter<"GameCharacter"> | string | null
    equippedShoes?: StringNullableFilter<"GameCharacter"> | string | null
    luckPercentage?: FloatFilter<"GameCharacter"> | number
    bankAccounts?: XOR<BankAccountNullableRelationFilter, BankAccountWhereInput> | null
    characterKnowledges?: CharacterKnowledgeListRelationFilter
    characterSkills?: CharacterSkillListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    jobChangeHistory?: JobChangeHistoryListRelationFilter
    magicalStorage?: MagicalStorageListRelationFilter
    playerInventories?: PlayerInventoryListRelationFilter
  }, "id" | "userId">

  export type GameCharacterOrderByWithAggregationInput = {
    id?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    characterClass?: SortOrder
    currentMapLocation?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    equippedArmor?: SortOrderInput | SortOrder
    equippedBackpack?: SortOrderInput | SortOrder
    equippedWeapon?: SortOrderInput | SortOrder
    goldAmount?: SortOrder
    isResting?: SortOrder
    lastSaveTimestamp?: SortOrder
    lastStaminaUpdate?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    restStartTime?: SortOrderInput | SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    equippedGloves?: SortOrderInput | SortOrder
    equippedPants?: SortOrderInput | SortOrder
    equippedShield?: SortOrderInput | SortOrder
    equippedShirt?: SortOrderInput | SortOrder
    equippedShoes?: SortOrderInput | SortOrder
    luckPercentage?: SortOrder
    _count?: GameCharacterCountOrderByAggregateInput
    _avg?: GameCharacterAvgOrderByAggregateInput
    _max?: GameCharacterMaxOrderByAggregateInput
    _min?: GameCharacterMinOrderByAggregateInput
    _sum?: GameCharacterSumOrderByAggregateInput
  }

  export type GameCharacterScalarWhereWithAggregatesInput = {
    AND?: GameCharacterScalarWhereWithAggregatesInput | GameCharacterScalarWhereWithAggregatesInput[]
    OR?: GameCharacterScalarWhereWithAggregatesInput[]
    NOT?: GameCharacterScalarWhereWithAggregatesInput | GameCharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameCharacter"> | string
    characterName?: StringWithAggregatesFilter<"GameCharacter"> | string
    level?: IntWithAggregatesFilter<"GameCharacter"> | number
    experience?: IntWithAggregatesFilter<"GameCharacter"> | number
    health?: IntWithAggregatesFilter<"GameCharacter"> | number
    maxHealth?: IntWithAggregatesFilter<"GameCharacter"> | number
    mana?: IntWithAggregatesFilter<"GameCharacter"> | number
    maxMana?: IntWithAggregatesFilter<"GameCharacter"> | number
    strength?: IntWithAggregatesFilter<"GameCharacter"> | number
    dexterity?: IntWithAggregatesFilter<"GameCharacter"> | number
    intelligence?: IntWithAggregatesFilter<"GameCharacter"> | number
    vitality?: IntWithAggregatesFilter<"GameCharacter"> | number
    luck?: IntWithAggregatesFilter<"GameCharacter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GameCharacter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameCharacter"> | Date | string
    userId?: StringWithAggregatesFilter<"GameCharacter"> | string
    availableStatPoints?: IntWithAggregatesFilter<"GameCharacter"> | number
    baseCarryingCapacity?: FloatWithAggregatesFilter<"GameCharacter"> | number
    carryingCapacity?: FloatWithAggregatesFilter<"GameCharacter"> | number
    characterClass?: StringWithAggregatesFilter<"GameCharacter"> | string
    currentMapLocation?: StringWithAggregatesFilter<"GameCharacter"> | string
    currentVolume?: FloatWithAggregatesFilter<"GameCharacter"> | number
    currentWeight?: FloatWithAggregatesFilter<"GameCharacter"> | number
    equippedArmor?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    equippedBackpack?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    equippedWeapon?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    goldAmount?: IntWithAggregatesFilter<"GameCharacter"> | number
    isResting?: BoolWithAggregatesFilter<"GameCharacter"> | boolean
    lastSaveTimestamp?: DateTimeWithAggregatesFilter<"GameCharacter"> | Date | string
    lastStaminaUpdate?: DateTimeWithAggregatesFilter<"GameCharacter"> | Date | string
    magicalStorageCapacity?: FloatWithAggregatesFilter<"GameCharacter"> | number
    magicalStorageUsed?: FloatWithAggregatesFilter<"GameCharacter"> | number
    maxStamina?: FloatWithAggregatesFilter<"GameCharacter"> | number
    maxVolume?: FloatWithAggregatesFilter<"GameCharacter"> | number
    movementPenalty?: FloatWithAggregatesFilter<"GameCharacter"> | number
    positionX?: FloatWithAggregatesFilter<"GameCharacter"> | number
    positionY?: FloatWithAggregatesFilter<"GameCharacter"> | number
    restStartTime?: DateTimeNullableWithAggregatesFilter<"GameCharacter"> | Date | string | null
    stamina?: FloatWithAggregatesFilter<"GameCharacter"> | number
    staminaRegenRate?: FloatWithAggregatesFilter<"GameCharacter"> | number
    baseStamina?: IntWithAggregatesFilter<"GameCharacter"> | number
    equippedGloves?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    equippedPants?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    equippedShield?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    equippedShirt?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    equippedShoes?: StringNullableWithAggregatesFilter<"GameCharacter"> | string | null
    luckPercentage?: FloatWithAggregatesFilter<"GameCharacter"> | number
  }

  export type JobChangeHistoryWhereInput = {
    AND?: JobChangeHistoryWhereInput | JobChangeHistoryWhereInput[]
    OR?: JobChangeHistoryWhereInput[]
    NOT?: JobChangeHistoryWhereInput | JobChangeHistoryWhereInput[]
    id?: StringFilter<"JobChangeHistory"> | string
    characterId?: StringFilter<"JobChangeHistory"> | string
    fromClass?: StringFilter<"JobChangeHistory"> | string
    toClass?: StringFilter<"JobChangeHistory"> | string
    changedAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    npcTrainerId?: StringFilter<"JobChangeHistory"> | string
    costPaid?: IntFilter<"JobChangeHistory"> | number
    levelAtChange?: IntFilter<"JobChangeHistory"> | number
    notes?: StringNullableFilter<"JobChangeHistory"> | string | null
    createdAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    updatedAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    gameCharacters?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }

  export type JobChangeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    fromClass?: SortOrder
    toClass?: SortOrder
    changedAt?: SortOrder
    npcTrainerId?: SortOrder
    costPaid?: SortOrder
    levelAtChange?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameCharacters?: GameCharacterOrderByWithRelationInput
  }

  export type JobChangeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobChangeHistoryWhereInput | JobChangeHistoryWhereInput[]
    OR?: JobChangeHistoryWhereInput[]
    NOT?: JobChangeHistoryWhereInput | JobChangeHistoryWhereInput[]
    characterId?: StringFilter<"JobChangeHistory"> | string
    fromClass?: StringFilter<"JobChangeHistory"> | string
    toClass?: StringFilter<"JobChangeHistory"> | string
    changedAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    npcTrainerId?: StringFilter<"JobChangeHistory"> | string
    costPaid?: IntFilter<"JobChangeHistory"> | number
    levelAtChange?: IntFilter<"JobChangeHistory"> | number
    notes?: StringNullableFilter<"JobChangeHistory"> | string | null
    createdAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    updatedAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    gameCharacters?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }, "id">

  export type JobChangeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    fromClass?: SortOrder
    toClass?: SortOrder
    changedAt?: SortOrder
    npcTrainerId?: SortOrder
    costPaid?: SortOrder
    levelAtChange?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobChangeHistoryCountOrderByAggregateInput
    _avg?: JobChangeHistoryAvgOrderByAggregateInput
    _max?: JobChangeHistoryMaxOrderByAggregateInput
    _min?: JobChangeHistoryMinOrderByAggregateInput
    _sum?: JobChangeHistorySumOrderByAggregateInput
  }

  export type JobChangeHistoryScalarWhereWithAggregatesInput = {
    AND?: JobChangeHistoryScalarWhereWithAggregatesInput | JobChangeHistoryScalarWhereWithAggregatesInput[]
    OR?: JobChangeHistoryScalarWhereWithAggregatesInput[]
    NOT?: JobChangeHistoryScalarWhereWithAggregatesInput | JobChangeHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobChangeHistory"> | string
    characterId?: StringWithAggregatesFilter<"JobChangeHistory"> | string
    fromClass?: StringWithAggregatesFilter<"JobChangeHistory"> | string
    toClass?: StringWithAggregatesFilter<"JobChangeHistory"> | string
    changedAt?: DateTimeWithAggregatesFilter<"JobChangeHistory"> | Date | string
    npcTrainerId?: StringWithAggregatesFilter<"JobChangeHistory"> | string
    costPaid?: IntWithAggregatesFilter<"JobChangeHistory"> | number
    levelAtChange?: IntWithAggregatesFilter<"JobChangeHistory"> | number
    notes?: StringNullableWithAggregatesFilter<"JobChangeHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JobChangeHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobChangeHistory"> | Date | string
  }

  export type LoanPaymentWhereInput = {
    AND?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    OR?: LoanPaymentWhereInput[]
    NOT?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    id?: StringFilter<"LoanPayment"> | string
    loanId?: StringFilter<"LoanPayment"> | string
    amount?: FloatFilter<"LoanPayment"> | number
    paymentDate?: DateTimeFilter<"LoanPayment"> | Date | string
    principalPaid?: FloatFilter<"LoanPayment"> | number
    interestPaid?: FloatFilter<"LoanPayment"> | number
    createdAt?: DateTimeFilter<"LoanPayment"> | Date | string
    updatedAt?: DateTimeFilter<"LoanPayment"> | Date | string
    loans?: XOR<LoanRelationFilter, LoanWhereInput>
  }

  export type LoanPaymentOrderByWithRelationInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loans?: LoanOrderByWithRelationInput
  }

  export type LoanPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    OR?: LoanPaymentWhereInput[]
    NOT?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    loanId?: StringFilter<"LoanPayment"> | string
    amount?: FloatFilter<"LoanPayment"> | number
    paymentDate?: DateTimeFilter<"LoanPayment"> | Date | string
    principalPaid?: FloatFilter<"LoanPayment"> | number
    interestPaid?: FloatFilter<"LoanPayment"> | number
    createdAt?: DateTimeFilter<"LoanPayment"> | Date | string
    updatedAt?: DateTimeFilter<"LoanPayment"> | Date | string
    loans?: XOR<LoanRelationFilter, LoanWhereInput>
  }, "id">

  export type LoanPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanPaymentCountOrderByAggregateInput
    _avg?: LoanPaymentAvgOrderByAggregateInput
    _max?: LoanPaymentMaxOrderByAggregateInput
    _min?: LoanPaymentMinOrderByAggregateInput
    _sum?: LoanPaymentSumOrderByAggregateInput
  }

  export type LoanPaymentScalarWhereWithAggregatesInput = {
    AND?: LoanPaymentScalarWhereWithAggregatesInput | LoanPaymentScalarWhereWithAggregatesInput[]
    OR?: LoanPaymentScalarWhereWithAggregatesInput[]
    NOT?: LoanPaymentScalarWhereWithAggregatesInput | LoanPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanPayment"> | string
    loanId?: StringWithAggregatesFilter<"LoanPayment"> | string
    amount?: FloatWithAggregatesFilter<"LoanPayment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"LoanPayment"> | Date | string
    principalPaid?: FloatWithAggregatesFilter<"LoanPayment"> | number
    interestPaid?: FloatWithAggregatesFilter<"LoanPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LoanPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoanPayment"> | Date | string
  }

  export type LoanWhereInput = {
    AND?: LoanWhereInput | LoanWhereInput[]
    OR?: LoanWhereInput[]
    NOT?: LoanWhereInput | LoanWhereInput[]
    id?: StringFilter<"Loan"> | string
    bankAccountId?: StringFilter<"Loan"> | string
    principalAmount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    termMonths?: IntFilter<"Loan"> | number
    monthlyPayment?: FloatFilter<"Loan"> | number
    remainingBalance?: FloatFilter<"Loan"> | number
    status?: StringFilter<"Loan"> | string
    loanPurpose?: StringFilter<"Loan"> | string
    nextPaymentDue?: DateTimeNullableFilter<"Loan"> | Date | string | null
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
    loanPayments?: LoanPaymentListRelationFilter
    bankAccounts?: XOR<BankAccountRelationFilter, BankAccountWhereInput>
  }

  export type LoanOrderByWithRelationInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    loanPurpose?: SortOrder
    nextPaymentDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loanPayments?: LoanPaymentOrderByRelationAggregateInput
    bankAccounts?: BankAccountOrderByWithRelationInput
  }

  export type LoanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoanWhereInput | LoanWhereInput[]
    OR?: LoanWhereInput[]
    NOT?: LoanWhereInput | LoanWhereInput[]
    bankAccountId?: StringFilter<"Loan"> | string
    principalAmount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    termMonths?: IntFilter<"Loan"> | number
    monthlyPayment?: FloatFilter<"Loan"> | number
    remainingBalance?: FloatFilter<"Loan"> | number
    status?: StringFilter<"Loan"> | string
    loanPurpose?: StringFilter<"Loan"> | string
    nextPaymentDue?: DateTimeNullableFilter<"Loan"> | Date | string | null
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
    loanPayments?: LoanPaymentListRelationFilter
    bankAccounts?: XOR<BankAccountRelationFilter, BankAccountWhereInput>
  }, "id">

  export type LoanOrderByWithAggregationInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    loanPurpose?: SortOrder
    nextPaymentDue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanCountOrderByAggregateInput
    _avg?: LoanAvgOrderByAggregateInput
    _max?: LoanMaxOrderByAggregateInput
    _min?: LoanMinOrderByAggregateInput
    _sum?: LoanSumOrderByAggregateInput
  }

  export type LoanScalarWhereWithAggregatesInput = {
    AND?: LoanScalarWhereWithAggregatesInput | LoanScalarWhereWithAggregatesInput[]
    OR?: LoanScalarWhereWithAggregatesInput[]
    NOT?: LoanScalarWhereWithAggregatesInput | LoanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Loan"> | string
    bankAccountId?: StringWithAggregatesFilter<"Loan"> | string
    principalAmount?: FloatWithAggregatesFilter<"Loan"> | number
    interestRate?: FloatWithAggregatesFilter<"Loan"> | number
    termMonths?: IntWithAggregatesFilter<"Loan"> | number
    monthlyPayment?: FloatWithAggregatesFilter<"Loan"> | number
    remainingBalance?: FloatWithAggregatesFilter<"Loan"> | number
    status?: StringWithAggregatesFilter<"Loan"> | string
    loanPurpose?: StringWithAggregatesFilter<"Loan"> | string
    nextPaymentDue?: DateTimeNullableWithAggregatesFilter<"Loan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
  }

  export type LogisticsTrackingWhereInput = {
    AND?: LogisticsTrackingWhereInput | LogisticsTrackingWhereInput[]
    OR?: LogisticsTrackingWhereInput[]
    NOT?: LogisticsTrackingWhereInput | LogisticsTrackingWhereInput[]
    id?: StringFilter<"LogisticsTracking"> | string
    trackingNumber?: StringFilter<"LogisticsTracking"> | string
    deliveryQuestId?: StringNullableFilter<"LogisticsTracking"> | string | null
    routeId?: StringNullableFilter<"LogisticsTracking"> | string | null
    itemId?: StringFilter<"LogisticsTracking"> | string
    quantity?: IntFilter<"LogisticsTracking"> | number
    weight?: FloatFilter<"LogisticsTracking"> | number
    status?: StringFilter<"LogisticsTracking"> | string
    currentLocation?: StringFilter<"LogisticsTracking"> | string
    scheduledPickup?: DateTimeFilter<"LogisticsTracking"> | Date | string
    actualPickup?: DateTimeNullableFilter<"LogisticsTracking"> | Date | string | null
    scheduledDelivery?: DateTimeFilter<"LogisticsTracking"> | Date | string
    actualDelivery?: DateTimeNullableFilter<"LogisticsTracking"> | Date | string | null
    handlerType?: StringFilter<"LogisticsTracking"> | string
    handlerId?: StringFilter<"LogisticsTracking"> | string
    createdAt?: DateTimeFilter<"LogisticsTracking"> | Date | string
    updatedAt?: DateTimeFilter<"LogisticsTracking"> | Date | string
  }

  export type LogisticsTrackingOrderByWithRelationInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    deliveryQuestId?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    currentLocation?: SortOrder
    scheduledPickup?: SortOrder
    actualPickup?: SortOrderInput | SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    handlerType?: SortOrder
    handlerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogisticsTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackingNumber?: string
    AND?: LogisticsTrackingWhereInput | LogisticsTrackingWhereInput[]
    OR?: LogisticsTrackingWhereInput[]
    NOT?: LogisticsTrackingWhereInput | LogisticsTrackingWhereInput[]
    deliveryQuestId?: StringNullableFilter<"LogisticsTracking"> | string | null
    routeId?: StringNullableFilter<"LogisticsTracking"> | string | null
    itemId?: StringFilter<"LogisticsTracking"> | string
    quantity?: IntFilter<"LogisticsTracking"> | number
    weight?: FloatFilter<"LogisticsTracking"> | number
    status?: StringFilter<"LogisticsTracking"> | string
    currentLocation?: StringFilter<"LogisticsTracking"> | string
    scheduledPickup?: DateTimeFilter<"LogisticsTracking"> | Date | string
    actualPickup?: DateTimeNullableFilter<"LogisticsTracking"> | Date | string | null
    scheduledDelivery?: DateTimeFilter<"LogisticsTracking"> | Date | string
    actualDelivery?: DateTimeNullableFilter<"LogisticsTracking"> | Date | string | null
    handlerType?: StringFilter<"LogisticsTracking"> | string
    handlerId?: StringFilter<"LogisticsTracking"> | string
    createdAt?: DateTimeFilter<"LogisticsTracking"> | Date | string
    updatedAt?: DateTimeFilter<"LogisticsTracking"> | Date | string
  }, "id" | "trackingNumber">

  export type LogisticsTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    deliveryQuestId?: SortOrderInput | SortOrder
    routeId?: SortOrderInput | SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    currentLocation?: SortOrder
    scheduledPickup?: SortOrder
    actualPickup?: SortOrderInput | SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrderInput | SortOrder
    handlerType?: SortOrder
    handlerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LogisticsTrackingCountOrderByAggregateInput
    _avg?: LogisticsTrackingAvgOrderByAggregateInput
    _max?: LogisticsTrackingMaxOrderByAggregateInput
    _min?: LogisticsTrackingMinOrderByAggregateInput
    _sum?: LogisticsTrackingSumOrderByAggregateInput
  }

  export type LogisticsTrackingScalarWhereWithAggregatesInput = {
    AND?: LogisticsTrackingScalarWhereWithAggregatesInput | LogisticsTrackingScalarWhereWithAggregatesInput[]
    OR?: LogisticsTrackingScalarWhereWithAggregatesInput[]
    NOT?: LogisticsTrackingScalarWhereWithAggregatesInput | LogisticsTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    trackingNumber?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    deliveryQuestId?: StringNullableWithAggregatesFilter<"LogisticsTracking"> | string | null
    routeId?: StringNullableWithAggregatesFilter<"LogisticsTracking"> | string | null
    itemId?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    quantity?: IntWithAggregatesFilter<"LogisticsTracking"> | number
    weight?: FloatWithAggregatesFilter<"LogisticsTracking"> | number
    status?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    currentLocation?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    scheduledPickup?: DateTimeWithAggregatesFilter<"LogisticsTracking"> | Date | string
    actualPickup?: DateTimeNullableWithAggregatesFilter<"LogisticsTracking"> | Date | string | null
    scheduledDelivery?: DateTimeWithAggregatesFilter<"LogisticsTracking"> | Date | string
    actualDelivery?: DateTimeNullableWithAggregatesFilter<"LogisticsTracking"> | Date | string | null
    handlerType?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    handlerId?: StringWithAggregatesFilter<"LogisticsTracking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LogisticsTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LogisticsTracking"> | Date | string
  }

  export type MagicalStorageWhereInput = {
    AND?: MagicalStorageWhereInput | MagicalStorageWhereInput[]
    OR?: MagicalStorageWhereInput[]
    NOT?: MagicalStorageWhereInput | MagicalStorageWhereInput[]
    id?: StringFilter<"MagicalStorage"> | string
    characterId?: StringFilter<"MagicalStorage"> | string
    itemId?: StringFilter<"MagicalStorage"> | string
    quantity?: IntFilter<"MagicalStorage"> | number
    quality?: StringFilter<"MagicalStorage"> | string
    manaUsed?: FloatFilter<"MagicalStorage"> | number
    storedAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"MagicalStorage"> | Date | string | null
    createdAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    updatedAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }

  export type MagicalStorageOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    manaUsed?: SortOrder
    storedAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameCharacter?: GameCharacterOrderByWithRelationInput
  }

  export type MagicalStorageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MagicalStorageWhereInput | MagicalStorageWhereInput[]
    OR?: MagicalStorageWhereInput[]
    NOT?: MagicalStorageWhereInput | MagicalStorageWhereInput[]
    characterId?: StringFilter<"MagicalStorage"> | string
    itemId?: StringFilter<"MagicalStorage"> | string
    quantity?: IntFilter<"MagicalStorage"> | number
    quality?: StringFilter<"MagicalStorage"> | string
    manaUsed?: FloatFilter<"MagicalStorage"> | number
    storedAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"MagicalStorage"> | Date | string | null
    createdAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    updatedAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    gameCharacter?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }, "id">

  export type MagicalStorageOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    manaUsed?: SortOrder
    storedAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MagicalStorageCountOrderByAggregateInput
    _avg?: MagicalStorageAvgOrderByAggregateInput
    _max?: MagicalStorageMaxOrderByAggregateInput
    _min?: MagicalStorageMinOrderByAggregateInput
    _sum?: MagicalStorageSumOrderByAggregateInput
  }

  export type MagicalStorageScalarWhereWithAggregatesInput = {
    AND?: MagicalStorageScalarWhereWithAggregatesInput | MagicalStorageScalarWhereWithAggregatesInput[]
    OR?: MagicalStorageScalarWhereWithAggregatesInput[]
    NOT?: MagicalStorageScalarWhereWithAggregatesInput | MagicalStorageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MagicalStorage"> | string
    characterId?: StringWithAggregatesFilter<"MagicalStorage"> | string
    itemId?: StringWithAggregatesFilter<"MagicalStorage"> | string
    quantity?: IntWithAggregatesFilter<"MagicalStorage"> | number
    quality?: StringWithAggregatesFilter<"MagicalStorage"> | string
    manaUsed?: FloatWithAggregatesFilter<"MagicalStorage"> | number
    storedAt?: DateTimeWithAggregatesFilter<"MagicalStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableWithAggregatesFilter<"MagicalStorage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MagicalStorage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MagicalStorage"> | Date | string
  }

  export type NpcDeliveryRouteWhereInput = {
    AND?: NpcDeliveryRouteWhereInput | NpcDeliveryRouteWhereInput[]
    OR?: NpcDeliveryRouteWhereInput[]
    NOT?: NpcDeliveryRouteWhereInput | NpcDeliveryRouteWhereInput[]
    id?: StringFilter<"NpcDeliveryRoute"> | string
    deliveryNpcId?: StringFilter<"NpcDeliveryRoute"> | string
    routeName?: StringFilter<"NpcDeliveryRoute"> | string
    startLocation?: StringFilter<"NpcDeliveryRoute"> | string
    endLocation?: StringFilter<"NpcDeliveryRoute"> | string
    waypoints?: StringFilter<"NpcDeliveryRoute"> | string
    totalDistance?: FloatFilter<"NpcDeliveryRoute"> | number
    estimatedTime?: IntFilter<"NpcDeliveryRoute"> | number
    isActive?: BoolFilter<"NpcDeliveryRoute"> | boolean
    priority?: IntFilter<"NpcDeliveryRoute"> | number
    frequency?: StringFilter<"NpcDeliveryRoute"> | string
    lastRun?: DateTimeNullableFilter<"NpcDeliveryRoute"> | Date | string | null
    nextScheduledRun?: DateTimeNullableFilter<"NpcDeliveryRoute"> | Date | string | null
    createdAt?: DateTimeFilter<"NpcDeliveryRoute"> | Date | string
    updatedAt?: DateTimeFilter<"NpcDeliveryRoute"> | Date | string
  }

  export type NpcDeliveryRouteOrderByWithRelationInput = {
    id?: SortOrder
    deliveryNpcId?: SortOrder
    routeName?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    waypoints?: SortOrder
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    frequency?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextScheduledRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NpcDeliveryRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NpcDeliveryRouteWhereInput | NpcDeliveryRouteWhereInput[]
    OR?: NpcDeliveryRouteWhereInput[]
    NOT?: NpcDeliveryRouteWhereInput | NpcDeliveryRouteWhereInput[]
    deliveryNpcId?: StringFilter<"NpcDeliveryRoute"> | string
    routeName?: StringFilter<"NpcDeliveryRoute"> | string
    startLocation?: StringFilter<"NpcDeliveryRoute"> | string
    endLocation?: StringFilter<"NpcDeliveryRoute"> | string
    waypoints?: StringFilter<"NpcDeliveryRoute"> | string
    totalDistance?: FloatFilter<"NpcDeliveryRoute"> | number
    estimatedTime?: IntFilter<"NpcDeliveryRoute"> | number
    isActive?: BoolFilter<"NpcDeliveryRoute"> | boolean
    priority?: IntFilter<"NpcDeliveryRoute"> | number
    frequency?: StringFilter<"NpcDeliveryRoute"> | string
    lastRun?: DateTimeNullableFilter<"NpcDeliveryRoute"> | Date | string | null
    nextScheduledRun?: DateTimeNullableFilter<"NpcDeliveryRoute"> | Date | string | null
    createdAt?: DateTimeFilter<"NpcDeliveryRoute"> | Date | string
    updatedAt?: DateTimeFilter<"NpcDeliveryRoute"> | Date | string
  }, "id">

  export type NpcDeliveryRouteOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryNpcId?: SortOrder
    routeName?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    waypoints?: SortOrder
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    frequency?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    nextScheduledRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NpcDeliveryRouteCountOrderByAggregateInput
    _avg?: NpcDeliveryRouteAvgOrderByAggregateInput
    _max?: NpcDeliveryRouteMaxOrderByAggregateInput
    _min?: NpcDeliveryRouteMinOrderByAggregateInput
    _sum?: NpcDeliveryRouteSumOrderByAggregateInput
  }

  export type NpcDeliveryRouteScalarWhereWithAggregatesInput = {
    AND?: NpcDeliveryRouteScalarWhereWithAggregatesInput | NpcDeliveryRouteScalarWhereWithAggregatesInput[]
    OR?: NpcDeliveryRouteScalarWhereWithAggregatesInput[]
    NOT?: NpcDeliveryRouteScalarWhereWithAggregatesInput | NpcDeliveryRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    deliveryNpcId?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    routeName?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    startLocation?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    endLocation?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    waypoints?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    totalDistance?: FloatWithAggregatesFilter<"NpcDeliveryRoute"> | number
    estimatedTime?: IntWithAggregatesFilter<"NpcDeliveryRoute"> | number
    isActive?: BoolWithAggregatesFilter<"NpcDeliveryRoute"> | boolean
    priority?: IntWithAggregatesFilter<"NpcDeliveryRoute"> | number
    frequency?: StringWithAggregatesFilter<"NpcDeliveryRoute"> | string
    lastRun?: DateTimeNullableWithAggregatesFilter<"NpcDeliveryRoute"> | Date | string | null
    nextScheduledRun?: DateTimeNullableWithAggregatesFilter<"NpcDeliveryRoute"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NpcDeliveryRoute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NpcDeliveryRoute"> | Date | string
  }

  export type OAuthProvidersWhereInput = {
    AND?: OAuthProvidersWhereInput | OAuthProvidersWhereInput[]
    OR?: OAuthProvidersWhereInput[]
    NOT?: OAuthProvidersWhereInput | OAuthProvidersWhereInput[]
    id?: StringFilter<"OAuthProviders"> | string
    providerId?: StringFilter<"OAuthProviders"> | string
    name?: StringFilter<"OAuthProviders"> | string
    description?: StringFilter<"OAuthProviders"> | string
    iconName?: StringFilter<"OAuthProviders"> | string
    enabled?: BoolFilter<"OAuthProviders"> | boolean
    displayOrder?: IntFilter<"OAuthProviders"> | number
    createdAt?: DateTimeFilter<"OAuthProviders"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthProviders"> | Date | string
  }

  export type OAuthProvidersOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    enabled?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthProvidersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId?: string
    AND?: OAuthProvidersWhereInput | OAuthProvidersWhereInput[]
    OR?: OAuthProvidersWhereInput[]
    NOT?: OAuthProvidersWhereInput | OAuthProvidersWhereInput[]
    name?: StringFilter<"OAuthProviders"> | string
    description?: StringFilter<"OAuthProviders"> | string
    iconName?: StringFilter<"OAuthProviders"> | string
    enabled?: BoolFilter<"OAuthProviders"> | boolean
    displayOrder?: IntFilter<"OAuthProviders"> | number
    createdAt?: DateTimeFilter<"OAuthProviders"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthProviders"> | Date | string
  }, "id" | "providerId">

  export type OAuthProvidersOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    enabled?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OAuthProvidersCountOrderByAggregateInput
    _avg?: OAuthProvidersAvgOrderByAggregateInput
    _max?: OAuthProvidersMaxOrderByAggregateInput
    _min?: OAuthProvidersMinOrderByAggregateInput
    _sum?: OAuthProvidersSumOrderByAggregateInput
  }

  export type OAuthProvidersScalarWhereWithAggregatesInput = {
    AND?: OAuthProvidersScalarWhereWithAggregatesInput | OAuthProvidersScalarWhereWithAggregatesInput[]
    OR?: OAuthProvidersScalarWhereWithAggregatesInput[]
    NOT?: OAuthProvidersScalarWhereWithAggregatesInput | OAuthProvidersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthProviders"> | string
    providerId?: StringWithAggregatesFilter<"OAuthProviders"> | string
    name?: StringWithAggregatesFilter<"OAuthProviders"> | string
    description?: StringWithAggregatesFilter<"OAuthProviders"> | string
    iconName?: StringWithAggregatesFilter<"OAuthProviders"> | string
    enabled?: BoolWithAggregatesFilter<"OAuthProviders"> | boolean
    displayOrder?: IntWithAggregatesFilter<"OAuthProviders"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OAuthProviders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OAuthProviders"> | Date | string
  }

  export type PlayerInventoryWhereInput = {
    AND?: PlayerInventoryWhereInput | PlayerInventoryWhereInput[]
    OR?: PlayerInventoryWhereInput[]
    NOT?: PlayerInventoryWhereInput | PlayerInventoryWhereInput[]
    id?: StringFilter<"PlayerInventory"> | string
    character_id?: StringFilter<"PlayerInventory"> | string
    item_id?: StringFilter<"PlayerInventory"> | string
    quantity?: IntFilter<"PlayerInventory"> | number
    quality?: StringFilter<"PlayerInventory"> | string
    weight?: FloatFilter<"PlayerInventory"> | number
    totalWeight?: FloatFilter<"PlayerInventory"> | number
    volume?: FloatFilter<"PlayerInventory"> | number
    totalVolume?: FloatFilter<"PlayerInventory"> | number
    slot?: IntNullableFilter<"PlayerInventory"> | number | null
    is_equipped?: BoolFilter<"PlayerInventory"> | boolean
    equipment_slot?: StringNullableFilter<"PlayerInventory"> | string | null
    condition?: FloatFilter<"PlayerInventory"> | number
    is_stackable?: BoolFilter<"PlayerInventory"> | boolean
    max_stack?: IntFilter<"PlayerInventory"> | number
    acquired_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    last_used_at?: DateTimeNullableFilter<"PlayerInventory"> | Date | string | null
    created_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    updated_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    game_characters?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }

  export type PlayerInventoryOrderByWithRelationInput = {
    id?: SortOrder
    character_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrderInput | SortOrder
    is_equipped?: SortOrder
    equipment_slot?: SortOrderInput | SortOrder
    condition?: SortOrder
    is_stackable?: SortOrder
    max_stack?: SortOrder
    acquired_at?: SortOrder
    last_used_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    game_characters?: GameCharacterOrderByWithRelationInput
  }

  export type PlayerInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    character_id_item_id_quality?: PlayerInventoryCharacter_idItem_idQualityCompoundUniqueInput
    AND?: PlayerInventoryWhereInput | PlayerInventoryWhereInput[]
    OR?: PlayerInventoryWhereInput[]
    NOT?: PlayerInventoryWhereInput | PlayerInventoryWhereInput[]
    character_id?: StringFilter<"PlayerInventory"> | string
    item_id?: StringFilter<"PlayerInventory"> | string
    quantity?: IntFilter<"PlayerInventory"> | number
    quality?: StringFilter<"PlayerInventory"> | string
    weight?: FloatFilter<"PlayerInventory"> | number
    totalWeight?: FloatFilter<"PlayerInventory"> | number
    volume?: FloatFilter<"PlayerInventory"> | number
    totalVolume?: FloatFilter<"PlayerInventory"> | number
    slot?: IntNullableFilter<"PlayerInventory"> | number | null
    is_equipped?: BoolFilter<"PlayerInventory"> | boolean
    equipment_slot?: StringNullableFilter<"PlayerInventory"> | string | null
    condition?: FloatFilter<"PlayerInventory"> | number
    is_stackable?: BoolFilter<"PlayerInventory"> | boolean
    max_stack?: IntFilter<"PlayerInventory"> | number
    acquired_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    last_used_at?: DateTimeNullableFilter<"PlayerInventory"> | Date | string | null
    created_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    updated_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    game_characters?: XOR<GameCharacterRelationFilter, GameCharacterWhereInput>
  }, "id" | "character_id_item_id_quality">

  export type PlayerInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    character_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrderInput | SortOrder
    is_equipped?: SortOrder
    equipment_slot?: SortOrderInput | SortOrder
    condition?: SortOrder
    is_stackable?: SortOrder
    max_stack?: SortOrder
    acquired_at?: SortOrder
    last_used_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PlayerInventoryCountOrderByAggregateInput
    _avg?: PlayerInventoryAvgOrderByAggregateInput
    _max?: PlayerInventoryMaxOrderByAggregateInput
    _min?: PlayerInventoryMinOrderByAggregateInput
    _sum?: PlayerInventorySumOrderByAggregateInput
  }

  export type PlayerInventoryScalarWhereWithAggregatesInput = {
    AND?: PlayerInventoryScalarWhereWithAggregatesInput | PlayerInventoryScalarWhereWithAggregatesInput[]
    OR?: PlayerInventoryScalarWhereWithAggregatesInput[]
    NOT?: PlayerInventoryScalarWhereWithAggregatesInput | PlayerInventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerInventory"> | string
    character_id?: StringWithAggregatesFilter<"PlayerInventory"> | string
    item_id?: StringWithAggregatesFilter<"PlayerInventory"> | string
    quantity?: IntWithAggregatesFilter<"PlayerInventory"> | number
    quality?: StringWithAggregatesFilter<"PlayerInventory"> | string
    weight?: FloatWithAggregatesFilter<"PlayerInventory"> | number
    totalWeight?: FloatWithAggregatesFilter<"PlayerInventory"> | number
    volume?: FloatWithAggregatesFilter<"PlayerInventory"> | number
    totalVolume?: FloatWithAggregatesFilter<"PlayerInventory"> | number
    slot?: IntNullableWithAggregatesFilter<"PlayerInventory"> | number | null
    is_equipped?: BoolWithAggregatesFilter<"PlayerInventory"> | boolean
    equipment_slot?: StringNullableWithAggregatesFilter<"PlayerInventory"> | string | null
    condition?: FloatWithAggregatesFilter<"PlayerInventory"> | number
    is_stackable?: BoolWithAggregatesFilter<"PlayerInventory"> | boolean
    max_stack?: IntWithAggregatesFilter<"PlayerInventory"> | number
    acquired_at?: DateTimeWithAggregatesFilter<"PlayerInventory"> | Date | string
    last_used_at?: DateTimeNullableWithAggregatesFilter<"PlayerInventory"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"PlayerInventory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PlayerInventory"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type SkillDecayLogWhereInput = {
    AND?: SkillDecayLogWhereInput | SkillDecayLogWhereInput[]
    OR?: SkillDecayLogWhereInput[]
    NOT?: SkillDecayLogWhereInput | SkillDecayLogWhereInput[]
    id?: StringFilter<"SkillDecayLog"> | string
    character_id?: StringFilter<"SkillDecayLog"> | string
    skill_type?: StringFilter<"SkillDecayLog"> | string
    knowledge_name?: StringFilter<"SkillDecayLog"> | string
    event_type?: StringFilter<"SkillDecayLog"> | string
    original_value?: IntFilter<"SkillDecayLog"> | number
    new_value?: IntFilter<"SkillDecayLog"> | number
    decay_amount?: IntFilter<"SkillDecayLog"> | number
    days_since_last_practice?: IntFilter<"SkillDecayLog"> | number
    action?: StringNullableFilter<"SkillDecayLog"> | string | null
    timestamp?: DateTimeFilter<"SkillDecayLog"> | Date | string
    created_at?: DateTimeFilter<"SkillDecayLog"> | Date | string
    updated_at?: DateTimeFilter<"SkillDecayLog"> | Date | string
  }

  export type SkillDecayLogOrderByWithRelationInput = {
    id?: SortOrder
    character_id?: SortOrder
    skill_type?: SortOrder
    knowledge_name?: SortOrder
    event_type?: SortOrder
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
    action?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillDecayLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillDecayLogWhereInput | SkillDecayLogWhereInput[]
    OR?: SkillDecayLogWhereInput[]
    NOT?: SkillDecayLogWhereInput | SkillDecayLogWhereInput[]
    character_id?: StringFilter<"SkillDecayLog"> | string
    skill_type?: StringFilter<"SkillDecayLog"> | string
    knowledge_name?: StringFilter<"SkillDecayLog"> | string
    event_type?: StringFilter<"SkillDecayLog"> | string
    original_value?: IntFilter<"SkillDecayLog"> | number
    new_value?: IntFilter<"SkillDecayLog"> | number
    decay_amount?: IntFilter<"SkillDecayLog"> | number
    days_since_last_practice?: IntFilter<"SkillDecayLog"> | number
    action?: StringNullableFilter<"SkillDecayLog"> | string | null
    timestamp?: DateTimeFilter<"SkillDecayLog"> | Date | string
    created_at?: DateTimeFilter<"SkillDecayLog"> | Date | string
    updated_at?: DateTimeFilter<"SkillDecayLog"> | Date | string
  }, "id">

  export type SkillDecayLogOrderByWithAggregationInput = {
    id?: SortOrder
    character_id?: SortOrder
    skill_type?: SortOrder
    knowledge_name?: SortOrder
    event_type?: SortOrder
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
    action?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SkillDecayLogCountOrderByAggregateInput
    _avg?: SkillDecayLogAvgOrderByAggregateInput
    _max?: SkillDecayLogMaxOrderByAggregateInput
    _min?: SkillDecayLogMinOrderByAggregateInput
    _sum?: SkillDecayLogSumOrderByAggregateInput
  }

  export type SkillDecayLogScalarWhereWithAggregatesInput = {
    AND?: SkillDecayLogScalarWhereWithAggregatesInput | SkillDecayLogScalarWhereWithAggregatesInput[]
    OR?: SkillDecayLogScalarWhereWithAggregatesInput[]
    NOT?: SkillDecayLogScalarWhereWithAggregatesInput | SkillDecayLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillDecayLog"> | string
    character_id?: StringWithAggregatesFilter<"SkillDecayLog"> | string
    skill_type?: StringWithAggregatesFilter<"SkillDecayLog"> | string
    knowledge_name?: StringWithAggregatesFilter<"SkillDecayLog"> | string
    event_type?: StringWithAggregatesFilter<"SkillDecayLog"> | string
    original_value?: IntWithAggregatesFilter<"SkillDecayLog"> | number
    new_value?: IntWithAggregatesFilter<"SkillDecayLog"> | number
    decay_amount?: IntWithAggregatesFilter<"SkillDecayLog"> | number
    days_since_last_practice?: IntWithAggregatesFilter<"SkillDecayLog"> | number
    action?: StringNullableWithAggregatesFilter<"SkillDecayLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"SkillDecayLog"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"SkillDecayLog"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SkillDecayLog"> | Date | string
  }

  export type SkillPracticeHistoryWhereInput = {
    AND?: SkillPracticeHistoryWhereInput | SkillPracticeHistoryWhereInput[]
    OR?: SkillPracticeHistoryWhereInput[]
    NOT?: SkillPracticeHistoryWhereInput | SkillPracticeHistoryWhereInput[]
    id?: StringFilter<"SkillPracticeHistory"> | string
    skill_id?: StringFilter<"SkillPracticeHistory"> | string
    practice_type?: StringFilter<"SkillPracticeHistory"> | string
    practice_intensity?: StringFilter<"SkillPracticeHistory"> | string
    experience_gained?: IntFilter<"SkillPracticeHistory"> | number
    proficiency_gained?: IntFilter<"SkillPracticeHistory"> | number
    knowledge_used?: StringNullableFilter<"SkillPracticeHistory"> | string | null
    timestamp?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    created_at?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    updated_at?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    character_skills?: XOR<CharacterSkillRelationFilter, CharacterSkillWhereInput>
  }

  export type SkillPracticeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    skill_id?: SortOrder
    practice_type?: SortOrder
    practice_intensity?: SortOrder
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
    knowledge_used?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    character_skills?: CharacterSkillOrderByWithRelationInput
  }

  export type SkillPracticeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillPracticeHistoryWhereInput | SkillPracticeHistoryWhereInput[]
    OR?: SkillPracticeHistoryWhereInput[]
    NOT?: SkillPracticeHistoryWhereInput | SkillPracticeHistoryWhereInput[]
    skill_id?: StringFilter<"SkillPracticeHistory"> | string
    practice_type?: StringFilter<"SkillPracticeHistory"> | string
    practice_intensity?: StringFilter<"SkillPracticeHistory"> | string
    experience_gained?: IntFilter<"SkillPracticeHistory"> | number
    proficiency_gained?: IntFilter<"SkillPracticeHistory"> | number
    knowledge_used?: StringNullableFilter<"SkillPracticeHistory"> | string | null
    timestamp?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    created_at?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    updated_at?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    character_skills?: XOR<CharacterSkillRelationFilter, CharacterSkillWhereInput>
  }, "id">

  export type SkillPracticeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    skill_id?: SortOrder
    practice_type?: SortOrder
    practice_intensity?: SortOrder
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
    knowledge_used?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SkillPracticeHistoryCountOrderByAggregateInput
    _avg?: SkillPracticeHistoryAvgOrderByAggregateInput
    _max?: SkillPracticeHistoryMaxOrderByAggregateInput
    _min?: SkillPracticeHistoryMinOrderByAggregateInput
    _sum?: SkillPracticeHistorySumOrderByAggregateInput
  }

  export type SkillPracticeHistoryScalarWhereWithAggregatesInput = {
    AND?: SkillPracticeHistoryScalarWhereWithAggregatesInput | SkillPracticeHistoryScalarWhereWithAggregatesInput[]
    OR?: SkillPracticeHistoryScalarWhereWithAggregatesInput[]
    NOT?: SkillPracticeHistoryScalarWhereWithAggregatesInput | SkillPracticeHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillPracticeHistory"> | string
    skill_id?: StringWithAggregatesFilter<"SkillPracticeHistory"> | string
    practice_type?: StringWithAggregatesFilter<"SkillPracticeHistory"> | string
    practice_intensity?: StringWithAggregatesFilter<"SkillPracticeHistory"> | string
    experience_gained?: IntWithAggregatesFilter<"SkillPracticeHistory"> | number
    proficiency_gained?: IntWithAggregatesFilter<"SkillPracticeHistory"> | number
    knowledge_used?: StringNullableWithAggregatesFilter<"SkillPracticeHistory"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"SkillPracticeHistory"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"SkillPracticeHistory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SkillPracticeHistory"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    account?: AccountListRelationFilter
    gameCharacters?: XOR<GameCharacterNullableRelationFilter, GameCharacterWhereInput> | null
    session?: SessionListRelationFilter
    userEmails?: UserEmailListRelationFilter
    userProfile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    userSettings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    userPresence?: XOR<UserPresenceNullableRelationFilter, UserPresenceWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    account?: AccountOrderByRelationAggregateInput
    gameCharacters?: GameCharacterOrderByWithRelationInput
    session?: SessionOrderByRelationAggregateInput
    userEmails?: UserEmailOrderByRelationAggregateInput
    userProfile?: UserProfileOrderByWithRelationInput
    userSettings?: UserSettingsOrderByWithRelationInput
    userPresence?: UserPresenceOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    account?: AccountListRelationFilter
    gameCharacters?: XOR<GameCharacterNullableRelationFilter, GameCharacterWhereInput> | null
    session?: SessionListRelationFilter
    userEmails?: UserEmailListRelationFilter
    userProfile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    userSettings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    userPresence?: XOR<UserPresenceNullableRelationFilter, UserPresenceWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserEmailWhereInput = {
    AND?: UserEmailWhereInput | UserEmailWhereInput[]
    OR?: UserEmailWhereInput[]
    NOT?: UserEmailWhereInput | UserEmailWhereInput[]
    id?: StringFilter<"UserEmail"> | string
    userId?: StringFilter<"UserEmail"> | string
    email?: StringFilter<"UserEmail"> | string
    label?: StringNullableFilter<"UserEmail"> | string | null
    createdAt?: DateTimeFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmail"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserEmailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    label?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_email?: UserEmailUserIdEmailCompoundUniqueInput
    AND?: UserEmailWhereInput | UserEmailWhereInput[]
    OR?: UserEmailWhereInput[]
    NOT?: UserEmailWhereInput | UserEmailWhereInput[]
    userId?: StringFilter<"UserEmail"> | string
    email?: StringFilter<"UserEmail"> | string
    label?: StringNullableFilter<"UserEmail"> | string | null
    createdAt?: DateTimeFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmail"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_email">

  export type UserEmailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    label?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserEmailCountOrderByAggregateInput
    _max?: UserEmailMaxOrderByAggregateInput
    _min?: UserEmailMinOrderByAggregateInput
  }

  export type UserEmailScalarWhereWithAggregatesInput = {
    AND?: UserEmailScalarWhereWithAggregatesInput | UserEmailScalarWhereWithAggregatesInput[]
    OR?: UserEmailScalarWhereWithAggregatesInput[]
    NOT?: UserEmailScalarWhereWithAggregatesInput | UserEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserEmail"> | string
    userId?: StringWithAggregatesFilter<"UserEmail"> | string
    email?: StringWithAggregatesFilter<"UserEmail"> | string
    label?: StringNullableWithAggregatesFilter<"UserEmail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserEmail"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    displayName?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    motto?: StringNullableFilter<"UserProfile"> | string | null
    title?: StringNullableFilter<"UserProfile"> | string | null
    phone?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    discordTag?: StringNullableFilter<"UserProfile"> | string | null
    githubUrl?: StringNullableFilter<"UserProfile"> | string | null
    facebookUrl?: StringNullableFilter<"UserProfile"> | string | null
    instagramUrl?: StringNullableFilter<"UserProfile"> | string | null
    xUrl?: StringNullableFilter<"UserProfile"> | string | null
    linkedinUrl?: StringNullableFilter<"UserProfile"> | string | null
    snapchatUrl?: StringNullableFilter<"UserProfile"> | string | null
    favoriteClass?: StringNullableFilter<"UserProfile"> | string | null
    playStyle?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    motto?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    discordTag?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    facebookUrl?: SortOrderInput | SortOrder
    instagramUrl?: SortOrderInput | SortOrder
    xUrl?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    snapchatUrl?: SortOrderInput | SortOrder
    favoriteClass?: SortOrderInput | SortOrder
    playStyle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    displayName?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    motto?: StringNullableFilter<"UserProfile"> | string | null
    title?: StringNullableFilter<"UserProfile"> | string | null
    phone?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    discordTag?: StringNullableFilter<"UserProfile"> | string | null
    githubUrl?: StringNullableFilter<"UserProfile"> | string | null
    facebookUrl?: StringNullableFilter<"UserProfile"> | string | null
    instagramUrl?: StringNullableFilter<"UserProfile"> | string | null
    xUrl?: StringNullableFilter<"UserProfile"> | string | null
    linkedinUrl?: StringNullableFilter<"UserProfile"> | string | null
    snapchatUrl?: StringNullableFilter<"UserProfile"> | string | null
    favoriteClass?: StringNullableFilter<"UserProfile"> | string | null
    playStyle?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    motto?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    discordTag?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    facebookUrl?: SortOrderInput | SortOrder
    instagramUrl?: SortOrderInput | SortOrder
    xUrl?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    snapchatUrl?: SortOrderInput | SortOrder
    favoriteClass?: SortOrderInput | SortOrder
    playStyle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    displayName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    motto?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    title?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    discordTag?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    githubUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    facebookUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    instagramUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    xUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    snapchatUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    favoriteClass?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    playStyle?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    cardColor?: StringFilter<"UserSettings"> | string
    cardTheme?: StringFilter<"UserSettings"> | string
    publicEmailChoice?: StringNullableFilter<"UserSettings"> | string | null
    theme?: StringFilter<"UserSettings"> | string
    language?: StringFilter<"UserSettings"> | string
    pinnedForums?: StringNullableListFilter<"UserSettings">
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    isProfilePublic?: BoolFilter<"UserSettings"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardColor?: SortOrder
    cardTheme?: SortOrder
    publicEmailChoice?: SortOrderInput | SortOrder
    theme?: SortOrder
    language?: SortOrder
    pinnedForums?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isProfilePublic?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    cardColor?: StringFilter<"UserSettings"> | string
    cardTheme?: StringFilter<"UserSettings"> | string
    publicEmailChoice?: StringNullableFilter<"UserSettings"> | string | null
    theme?: StringFilter<"UserSettings"> | string
    language?: StringFilter<"UserSettings"> | string
    pinnedForums?: StringNullableListFilter<"UserSettings">
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    isProfilePublic?: BoolFilter<"UserSettings"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardColor?: SortOrder
    cardTheme?: SortOrder
    publicEmailChoice?: SortOrderInput | SortOrder
    theme?: SortOrder
    language?: SortOrder
    pinnedForums?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isProfilePublic?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    cardColor?: StringWithAggregatesFilter<"UserSettings"> | string
    cardTheme?: StringWithAggregatesFilter<"UserSettings"> | string
    publicEmailChoice?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    theme?: StringWithAggregatesFilter<"UserSettings"> | string
    language?: StringWithAggregatesFilter<"UserSettings"> | string
    pinnedForums?: StringNullableListFilter<"UserSettings">
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    isProfilePublic?: BoolWithAggregatesFilter<"UserSettings"> | boolean
  }

  export type UserPresenceWhereInput = {
    AND?: UserPresenceWhereInput | UserPresenceWhereInput[]
    OR?: UserPresenceWhereInput[]
    NOT?: UserPresenceWhereInput | UserPresenceWhereInput[]
    userId?: StringFilter<"UserPresence"> | string
    isOnline?: BoolFilter<"UserPresence"> | boolean
    lastSeen?: DateTimeNullableFilter<"UserPresence"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserPresence"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPresenceOrderByWithRelationInput = {
    userId?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPresenceWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserPresenceWhereInput | UserPresenceWhereInput[]
    OR?: UserPresenceWhereInput[]
    NOT?: UserPresenceWhereInput | UserPresenceWhereInput[]
    isOnline?: BoolFilter<"UserPresence"> | boolean
    lastSeen?: DateTimeNullableFilter<"UserPresence"> | Date | string | null
    updatedAt?: DateTimeFilter<"UserPresence"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type UserPresenceOrderByWithAggregationInput = {
    userId?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: UserPresenceCountOrderByAggregateInput
    _max?: UserPresenceMaxOrderByAggregateInput
    _min?: UserPresenceMinOrderByAggregateInput
  }

  export type UserPresenceScalarWhereWithAggregatesInput = {
    AND?: UserPresenceScalarWhereWithAggregatesInput | UserPresenceScalarWhereWithAggregatesInput[]
    OR?: UserPresenceScalarWhereWithAggregatesInput[]
    NOT?: UserPresenceScalarWhereWithAggregatesInput | UserPresenceScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserPresence"> | string
    isOnline?: BoolWithAggregatesFilter<"UserPresence"> | boolean
    lastSeen?: DateTimeNullableWithAggregatesFilter<"UserPresence"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"UserPresence"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type JwksWhereInput = {
    AND?: JwksWhereInput | JwksWhereInput[]
    OR?: JwksWhereInput[]
    NOT?: JwksWhereInput | JwksWhereInput[]
    id?: StringFilter<"Jwks"> | string
    publicKey?: StringFilter<"Jwks"> | string
    privateKey?: StringFilter<"Jwks"> | string
    createdAt?: DateTimeFilter<"Jwks"> | Date | string
  }

  export type JwksOrderByWithRelationInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type JwksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JwksWhereInput | JwksWhereInput[]
    OR?: JwksWhereInput[]
    NOT?: JwksWhereInput | JwksWhereInput[]
    publicKey?: StringFilter<"Jwks"> | string
    privateKey?: StringFilter<"Jwks"> | string
    createdAt?: DateTimeFilter<"Jwks"> | Date | string
  }, "id">

  export type JwksOrderByWithAggregationInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
    _count?: JwksCountOrderByAggregateInput
    _max?: JwksMaxOrderByAggregateInput
    _min?: JwksMinOrderByAggregateInput
  }

  export type JwksScalarWhereWithAggregatesInput = {
    AND?: JwksScalarWhereWithAggregatesInput | JwksScalarWhereWithAggregatesInput[]
    OR?: JwksScalarWhereWithAggregatesInput[]
    NOT?: JwksScalarWhereWithAggregatesInput | JwksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Jwks"> | string
    publicKey?: StringWithAggregatesFilter<"Jwks"> | string
    privateKey?: StringWithAggregatesFilter<"Jwks"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Jwks"> | Date | string
  }

  export type FriendRequestWhereInput = {
    AND?: FriendRequestWhereInput | FriendRequestWhereInput[]
    OR?: FriendRequestWhereInput[]
    NOT?: FriendRequestWhereInput | FriendRequestWhereInput[]
    id?: StringFilter<"FriendRequest"> | string
    senderId?: StringFilter<"FriendRequest"> | string
    receiverId?: StringFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    message?: StringNullableFilter<"FriendRequest"> | string | null
    createdAt?: DateTimeFilter<"FriendRequest"> | Date | string
    updatedAt?: DateTimeFilter<"FriendRequest"> | Date | string
  }

  export type FriendRequestOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    senderId_receiverId?: FriendRequestSenderIdReceiverIdCompoundUniqueInput
    AND?: FriendRequestWhereInput | FriendRequestWhereInput[]
    OR?: FriendRequestWhereInput[]
    NOT?: FriendRequestWhereInput | FriendRequestWhereInput[]
    senderId?: StringFilter<"FriendRequest"> | string
    receiverId?: StringFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    message?: StringNullableFilter<"FriendRequest"> | string | null
    createdAt?: DateTimeFilter<"FriendRequest"> | Date | string
    updatedAt?: DateTimeFilter<"FriendRequest"> | Date | string
  }, "id" | "senderId_receiverId">

  export type FriendRequestOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FriendRequestCountOrderByAggregateInput
    _max?: FriendRequestMaxOrderByAggregateInput
    _min?: FriendRequestMinOrderByAggregateInput
  }

  export type FriendRequestScalarWhereWithAggregatesInput = {
    AND?: FriendRequestScalarWhereWithAggregatesInput | FriendRequestScalarWhereWithAggregatesInput[]
    OR?: FriendRequestScalarWhereWithAggregatesInput[]
    NOT?: FriendRequestScalarWhereWithAggregatesInput | FriendRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FriendRequest"> | string
    senderId?: StringWithAggregatesFilter<"FriendRequest"> | string
    receiverId?: StringWithAggregatesFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusWithAggregatesFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    message?: StringNullableWithAggregatesFilter<"FriendRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FriendRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FriendRequest"> | Date | string
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    user1Id?: StringFilter<"Friendship"> | string
    user2Id?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user1Id_user2Id?: FriendshipUser1IdUser2IdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    user1Id?: StringFilter<"Friendship"> | string
    user2Id?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }, "id" | "user1Id_user2Id">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    createdAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    user1Id?: StringWithAggregatesFilter<"Friendship"> | string
    user2Id?: StringWithAggregatesFilter<"Friendship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type BlockedUserWhereInput = {
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    id?: StringFilter<"BlockedUser"> | string
    blockedById?: StringFilter<"BlockedUser"> | string
    blockedUserId?: StringFilter<"BlockedUser"> | string
    reason?: StringNullableFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
  }

  export type BlockedUserOrderByWithRelationInput = {
    id?: SortOrder
    blockedById?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockedById_blockedUserId?: BlockedUserBlockedByIdBlockedUserIdCompoundUniqueInput
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    blockedById?: StringFilter<"BlockedUser"> | string
    blockedUserId?: StringFilter<"BlockedUser"> | string
    reason?: StringNullableFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
  }, "id" | "blockedById_blockedUserId">

  export type BlockedUserOrderByWithAggregationInput = {
    id?: SortOrder
    blockedById?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlockedUserCountOrderByAggregateInput
    _max?: BlockedUserMaxOrderByAggregateInput
    _min?: BlockedUserMinOrderByAggregateInput
  }

  export type BlockedUserScalarWhereWithAggregatesInput = {
    AND?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    OR?: BlockedUserScalarWhereWithAggregatesInput[]
    NOT?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockedUser"> | string
    blockedById?: StringWithAggregatesFilter<"BlockedUser"> | string
    blockedUserId?: StringWithAggregatesFilter<"BlockedUser"> | string
    reason?: StringNullableWithAggregatesFilter<"BlockedUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlockedUser"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    isDelivered?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDelivered?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    isDelivered?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDelivered?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    isDelivered?: BoolWithAggregatesFilter<"Message"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: StringFilter<"Post"> | string
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    imageUrl?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    title?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: StringWithAggregatesFilter<"Post"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: LikePostIdUserIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id" | "postId_userId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    postId?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type ForumTopicWhereInput = {
    AND?: ForumTopicWhereInput | ForumTopicWhereInput[]
    OR?: ForumTopicWhereInput[]
    NOT?: ForumTopicWhereInput | ForumTopicWhereInput[]
    id?: StringFilter<"ForumTopic"> | string
    forumId?: EnumForumCategoryFilter<"ForumTopic"> | $Enums.ForumCategory
    title?: StringFilter<"ForumTopic"> | string
    content?: StringFilter<"ForumTopic"> | string
    type?: EnumTopicTypeFilter<"ForumTopic"> | $Enums.TopicType
    tags?: StringNullableListFilter<"ForumTopic">
    authorId?: StringFilter<"ForumTopic"> | string
    views?: IntFilter<"ForumTopic"> | number
    isPinned?: BoolFilter<"ForumTopic"> | boolean
    isClosed?: BoolFilter<"ForumTopic"> | boolean
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeFilter<"ForumTopic"> | Date | string
    replies?: ForumReplyListRelationFilter
    likes?: ForumTopicLikeListRelationFilter
  }

  export type ForumTopicOrderByWithRelationInput = {
    id?: SortOrder
    forumId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    replies?: ForumReplyOrderByRelationAggregateInput
    likes?: ForumTopicLikeOrderByRelationAggregateInput
  }

  export type ForumTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumTopicWhereInput | ForumTopicWhereInput[]
    OR?: ForumTopicWhereInput[]
    NOT?: ForumTopicWhereInput | ForumTopicWhereInput[]
    forumId?: EnumForumCategoryFilter<"ForumTopic"> | $Enums.ForumCategory
    title?: StringFilter<"ForumTopic"> | string
    content?: StringFilter<"ForumTopic"> | string
    type?: EnumTopicTypeFilter<"ForumTopic"> | $Enums.TopicType
    tags?: StringNullableListFilter<"ForumTopic">
    authorId?: StringFilter<"ForumTopic"> | string
    views?: IntFilter<"ForumTopic"> | number
    isPinned?: BoolFilter<"ForumTopic"> | boolean
    isClosed?: BoolFilter<"ForumTopic"> | boolean
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeFilter<"ForumTopic"> | Date | string
    replies?: ForumReplyListRelationFilter
    likes?: ForumTopicLikeListRelationFilter
  }, "id">

  export type ForumTopicOrderByWithAggregationInput = {
    id?: SortOrder
    forumId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumTopicCountOrderByAggregateInput
    _avg?: ForumTopicAvgOrderByAggregateInput
    _max?: ForumTopicMaxOrderByAggregateInput
    _min?: ForumTopicMinOrderByAggregateInput
    _sum?: ForumTopicSumOrderByAggregateInput
  }

  export type ForumTopicScalarWhereWithAggregatesInput = {
    AND?: ForumTopicScalarWhereWithAggregatesInput | ForumTopicScalarWhereWithAggregatesInput[]
    OR?: ForumTopicScalarWhereWithAggregatesInput[]
    NOT?: ForumTopicScalarWhereWithAggregatesInput | ForumTopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumTopic"> | string
    forumId?: EnumForumCategoryWithAggregatesFilter<"ForumTopic"> | $Enums.ForumCategory
    title?: StringWithAggregatesFilter<"ForumTopic"> | string
    content?: StringWithAggregatesFilter<"ForumTopic"> | string
    type?: EnumTopicTypeWithAggregatesFilter<"ForumTopic"> | $Enums.TopicType
    tags?: StringNullableListFilter<"ForumTopic">
    authorId?: StringWithAggregatesFilter<"ForumTopic"> | string
    views?: IntWithAggregatesFilter<"ForumTopic"> | number
    isPinned?: BoolWithAggregatesFilter<"ForumTopic"> | boolean
    isClosed?: BoolWithAggregatesFilter<"ForumTopic"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumTopic"> | Date | string
  }

  export type ForumReplyWhereInput = {
    AND?: ForumReplyWhereInput | ForumReplyWhereInput[]
    OR?: ForumReplyWhereInput[]
    NOT?: ForumReplyWhereInput | ForumReplyWhereInput[]
    id?: StringFilter<"ForumReply"> | string
    topicId?: StringFilter<"ForumReply"> | string
    content?: StringFilter<"ForumReply"> | string
    authorId?: StringFilter<"ForumReply"> | string
    createdAt?: DateTimeFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeFilter<"ForumReply"> | Date | string
    topic?: XOR<ForumTopicRelationFilter, ForumTopicWhereInput>
    likes?: ForumReplyLikeListRelationFilter
  }

  export type ForumReplyOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topic?: ForumTopicOrderByWithRelationInput
    likes?: ForumReplyLikeOrderByRelationAggregateInput
  }

  export type ForumReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumReplyWhereInput | ForumReplyWhereInput[]
    OR?: ForumReplyWhereInput[]
    NOT?: ForumReplyWhereInput | ForumReplyWhereInput[]
    topicId?: StringFilter<"ForumReply"> | string
    content?: StringFilter<"ForumReply"> | string
    authorId?: StringFilter<"ForumReply"> | string
    createdAt?: DateTimeFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeFilter<"ForumReply"> | Date | string
    topic?: XOR<ForumTopicRelationFilter, ForumTopicWhereInput>
    likes?: ForumReplyLikeListRelationFilter
  }, "id">

  export type ForumReplyOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumReplyCountOrderByAggregateInput
    _max?: ForumReplyMaxOrderByAggregateInput
    _min?: ForumReplyMinOrderByAggregateInput
  }

  export type ForumReplyScalarWhereWithAggregatesInput = {
    AND?: ForumReplyScalarWhereWithAggregatesInput | ForumReplyScalarWhereWithAggregatesInput[]
    OR?: ForumReplyScalarWhereWithAggregatesInput[]
    NOT?: ForumReplyScalarWhereWithAggregatesInput | ForumReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumReply"> | string
    topicId?: StringWithAggregatesFilter<"ForumReply"> | string
    content?: StringWithAggregatesFilter<"ForumReply"> | string
    authorId?: StringWithAggregatesFilter<"ForumReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumReply"> | Date | string
  }

  export type ForumTopicLikeWhereInput = {
    AND?: ForumTopicLikeWhereInput | ForumTopicLikeWhereInput[]
    OR?: ForumTopicLikeWhereInput[]
    NOT?: ForumTopicLikeWhereInput | ForumTopicLikeWhereInput[]
    id?: StringFilter<"ForumTopicLike"> | string
    topicId?: StringFilter<"ForumTopicLike"> | string
    userId?: StringFilter<"ForumTopicLike"> | string
    createdAt?: DateTimeFilter<"ForumTopicLike"> | Date | string
    topic?: XOR<ForumTopicRelationFilter, ForumTopicWhereInput>
  }

  export type ForumTopicLikeOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    topic?: ForumTopicOrderByWithRelationInput
  }

  export type ForumTopicLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    topicId_userId?: ForumTopicLikeTopicIdUserIdCompoundUniqueInput
    AND?: ForumTopicLikeWhereInput | ForumTopicLikeWhereInput[]
    OR?: ForumTopicLikeWhereInput[]
    NOT?: ForumTopicLikeWhereInput | ForumTopicLikeWhereInput[]
    topicId?: StringFilter<"ForumTopicLike"> | string
    userId?: StringFilter<"ForumTopicLike"> | string
    createdAt?: DateTimeFilter<"ForumTopicLike"> | Date | string
    topic?: XOR<ForumTopicRelationFilter, ForumTopicWhereInput>
  }, "id" | "topicId_userId">

  export type ForumTopicLikeOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ForumTopicLikeCountOrderByAggregateInput
    _max?: ForumTopicLikeMaxOrderByAggregateInput
    _min?: ForumTopicLikeMinOrderByAggregateInput
  }

  export type ForumTopicLikeScalarWhereWithAggregatesInput = {
    AND?: ForumTopicLikeScalarWhereWithAggregatesInput | ForumTopicLikeScalarWhereWithAggregatesInput[]
    OR?: ForumTopicLikeScalarWhereWithAggregatesInput[]
    NOT?: ForumTopicLikeScalarWhereWithAggregatesInput | ForumTopicLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumTopicLike"> | string
    topicId?: StringWithAggregatesFilter<"ForumTopicLike"> | string
    userId?: StringWithAggregatesFilter<"ForumTopicLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumTopicLike"> | Date | string
  }

  export type ForumReplyLikeWhereInput = {
    AND?: ForumReplyLikeWhereInput | ForumReplyLikeWhereInput[]
    OR?: ForumReplyLikeWhereInput[]
    NOT?: ForumReplyLikeWhereInput | ForumReplyLikeWhereInput[]
    id?: StringFilter<"ForumReplyLike"> | string
    replyId?: StringFilter<"ForumReplyLike"> | string
    userId?: StringFilter<"ForumReplyLike"> | string
    createdAt?: DateTimeFilter<"ForumReplyLike"> | Date | string
    reply?: XOR<ForumReplyRelationFilter, ForumReplyWhereInput>
  }

  export type ForumReplyLikeOrderByWithRelationInput = {
    id?: SortOrder
    replyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    reply?: ForumReplyOrderByWithRelationInput
  }

  export type ForumReplyLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    replyId_userId?: ForumReplyLikeReplyIdUserIdCompoundUniqueInput
    AND?: ForumReplyLikeWhereInput | ForumReplyLikeWhereInput[]
    OR?: ForumReplyLikeWhereInput[]
    NOT?: ForumReplyLikeWhereInput | ForumReplyLikeWhereInput[]
    replyId?: StringFilter<"ForumReplyLike"> | string
    userId?: StringFilter<"ForumReplyLike"> | string
    createdAt?: DateTimeFilter<"ForumReplyLike"> | Date | string
    reply?: XOR<ForumReplyRelationFilter, ForumReplyWhereInput>
  }, "id" | "replyId_userId">

  export type ForumReplyLikeOrderByWithAggregationInput = {
    id?: SortOrder
    replyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ForumReplyLikeCountOrderByAggregateInput
    _max?: ForumReplyLikeMaxOrderByAggregateInput
    _min?: ForumReplyLikeMinOrderByAggregateInput
  }

  export type ForumReplyLikeScalarWhereWithAggregatesInput = {
    AND?: ForumReplyLikeScalarWhereWithAggregatesInput | ForumReplyLikeScalarWhereWithAggregatesInput[]
    OR?: ForumReplyLikeScalarWhereWithAggregatesInput[]
    NOT?: ForumReplyLikeScalarWhereWithAggregatesInput | ForumReplyLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumReplyLike"> | string
    replyId?: StringWithAggregatesFilter<"ForumReplyLike"> | string
    userId?: StringWithAggregatesFilter<"ForumReplyLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumReplyLike"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutBankAccountsInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutBankAccountInput
    loans?: LoanCreateNestedManyWithoutBankAccountsInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    characterId: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput
    loans?: LoanUncheckedCreateNestedManyWithoutBankAccountsInput
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutBankAccountsNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutBankAccountNestedInput
    loans?: LoanUpdateManyWithoutBankAccountsNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput
    loans?: LoanUncheckedUpdateManyWithoutBankAccountsNestedInput
  }

  export type BankAccountCreateManyInput = {
    id?: string
    characterId: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateInput = {
    id?: string
    transactionType: string
    amount: number
    balanceAfter: number
    description?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccount: BankAccountCreateNestedOneWithoutBankTransactionsInput
  }

  export type BankTransactionUncheckedCreateInput = {
    id?: string
    bankAccountId: string
    transactionType: string
    amount: number
    balanceAfter: number
    description?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: BankAccountUpdateOneRequiredWithoutBankTransactionsNestedInput
  }

  export type BankTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyInput = {
    id?: string
    bankAccountId: string
    transactionType: string
    amount: number
    balanceAfter: number
    description?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterKnowledgeCreateInput = {
    id?: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description?: string | null
    proficiency?: number
    learnedAt?: Date | string
    teacherNpcId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutCharacterKnowledgesInput
  }

  export type CharacterKnowledgeUncheckedCreateInput = {
    id?: string
    characterId: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description?: string | null
    proficiency?: number
    learnedAt?: Date | string
    teacherNpcId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterKnowledgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutCharacterKnowledgesNestedInput
  }

  export type CharacterKnowledgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterKnowledgeCreateManyInput = {
    id?: string
    characterId: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description?: string | null
    proficiency?: number
    learnedAt?: Date | string
    teacherNpcId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterKnowledgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterKnowledgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterSkillCreateInput = {
    id?: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutCharacterSkillsInput
    skillPracticeHistory?: SkillPracticeHistoryCreateNestedManyWithoutCharacter_skillsInput
  }

  export type CharacterSkillUncheckedCreateInput = {
    id?: string
    characterId: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skillPracticeHistory?: SkillPracticeHistoryUncheckedCreateNestedManyWithoutCharacter_skillsInput
  }

  export type CharacterSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutCharacterSkillsNestedInput
    skillPracticeHistory?: SkillPracticeHistoryUpdateManyWithoutCharacter_skillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillPracticeHistory?: SkillPracticeHistoryUncheckedUpdateManyWithoutCharacter_skillsNestedInput
  }

  export type CharacterSkillCreateManyInput = {
    id?: string
    characterId: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryQuestCreateInput = {
    id?: string
    questId: string
    deliveryType: string
    fromNpcId: string
    toNpcId: string
    fromLocation: string
    toLocation: string
    itemId: string
    itemQuality: string
    quantity: number
    totalWeight: number
    requiredCapacity: number
    timeLimit?: number | null
    distance?: number
    difficulty?: string
    goldReward: number
    experienceReward: number
    reputationReward: number
    status?: string
    assignedTo?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pickupConfirmed?: boolean
    deliveryConfirmed?: boolean
    currentLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryQuestUncheckedCreateInput = {
    id?: string
    questId: string
    deliveryType: string
    fromNpcId: string
    toNpcId: string
    fromLocation: string
    toLocation: string
    itemId: string
    itemQuality: string
    quantity: number
    totalWeight: number
    requiredCapacity: number
    timeLimit?: number | null
    distance?: number
    difficulty?: string
    goldReward: number
    experienceReward: number
    reputationReward: number
    status?: string
    assignedTo?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pickupConfirmed?: boolean
    deliveryConfirmed?: boolean
    currentLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryQuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    fromNpcId?: StringFieldUpdateOperationsInput | string
    toNpcId?: StringFieldUpdateOperationsInput | string
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemQuality?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    requiredCapacity?: FloatFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: FloatFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    goldReward?: IntFieldUpdateOperationsInput | number
    experienceReward?: IntFieldUpdateOperationsInput | number
    reputationReward?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupConfirmed?: BoolFieldUpdateOperationsInput | boolean
    deliveryConfirmed?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryQuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    fromNpcId?: StringFieldUpdateOperationsInput | string
    toNpcId?: StringFieldUpdateOperationsInput | string
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemQuality?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    requiredCapacity?: FloatFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: FloatFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    goldReward?: IntFieldUpdateOperationsInput | number
    experienceReward?: IntFieldUpdateOperationsInput | number
    reputationReward?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupConfirmed?: BoolFieldUpdateOperationsInput | boolean
    deliveryConfirmed?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryQuestCreateManyInput = {
    id?: string
    questId: string
    deliveryType: string
    fromNpcId: string
    toNpcId: string
    fromLocation: string
    toLocation: string
    itemId: string
    itemQuality: string
    quantity: number
    totalWeight: number
    requiredCapacity: number
    timeLimit?: number | null
    distance?: number
    difficulty?: string
    goldReward: number
    experienceReward: number
    reputationReward: number
    status?: string
    assignedTo?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pickupConfirmed?: boolean
    deliveryConfirmed?: boolean
    currentLocation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryQuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    fromNpcId?: StringFieldUpdateOperationsInput | string
    toNpcId?: StringFieldUpdateOperationsInput | string
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemQuality?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    requiredCapacity?: FloatFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: FloatFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    goldReward?: IntFieldUpdateOperationsInput | number
    experienceReward?: IntFieldUpdateOperationsInput | number
    reputationReward?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupConfirmed?: BoolFieldUpdateOperationsInput | boolean
    deliveryConfirmed?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryQuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    fromNpcId?: StringFieldUpdateOperationsInput | string
    toNpcId?: StringFieldUpdateOperationsInput | string
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemQuality?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    requiredCapacity?: FloatFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: FloatFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    goldReward?: IntFieldUpdateOperationsInput | number
    experienceReward?: IntFieldUpdateOperationsInput | number
    reputationReward?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupConfirmed?: BoolFieldUpdateOperationsInput | boolean
    deliveryConfirmed?: BoolFieldUpdateOperationsInput | boolean
    currentLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCharacterCreateInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterCreateManyInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
  }

  export type GameCharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type GameCharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type JobChangeHistoryCreateInput = {
    id?: string
    fromClass: string
    toClass: string
    changedAt?: Date | string
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacters: GameCharacterCreateNestedOneWithoutJobChangeHistoryInput
  }

  export type JobChangeHistoryUncheckedCreateInput = {
    id?: string
    characterId: string
    fromClass: string
    toClass: string
    changedAt?: Date | string
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobChangeHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacters?: GameCharacterUpdateOneRequiredWithoutJobChangeHistoryNestedInput
  }

  export type JobChangeHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobChangeHistoryCreateManyInput = {
    id?: string
    characterId: string
    fromClass: string
    toClass: string
    changedAt?: Date | string
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobChangeHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobChangeHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    principalPaid: number
    interestPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
    loans: LoanCreateNestedOneWithoutLoanPaymentsInput
  }

  export type LoanPaymentUncheckedCreateInput = {
    id?: string
    loanId: string
    amount: number
    paymentDate: Date | string
    principalPaid: number
    interestPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanUpdateOneRequiredWithoutLoanPaymentsNestedInput
  }

  export type LoanPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateManyInput = {
    id?: string
    loanId: string
    amount: number
    paymentDate: Date | string
    principalPaid: number
    interestPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loanId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanCreateInput = {
    id?: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanPayments?: LoanPaymentCreateNestedManyWithoutLoansInput
    bankAccounts: BankAccountCreateNestedOneWithoutLoansInput
  }

  export type LoanUncheckedCreateInput = {
    id?: string
    bankAccountId: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanPayments?: LoanPaymentUncheckedCreateNestedManyWithoutLoansInput
  }

  export type LoanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUpdateManyWithoutLoansNestedInput
    bankAccounts?: BankAccountUpdateOneRequiredWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUncheckedUpdateManyWithoutLoansNestedInput
  }

  export type LoanCreateManyInput = {
    id?: string
    bankAccountId: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogisticsTrackingCreateInput = {
    id?: string
    trackingNumber: string
    deliveryQuestId?: string | null
    routeId?: string | null
    itemId: string
    quantity: number
    weight: number
    status?: string
    currentLocation: string
    scheduledPickup: Date | string
    actualPickup?: Date | string | null
    scheduledDelivery: Date | string
    actualDelivery?: Date | string | null
    handlerType: string
    handlerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogisticsTrackingUncheckedCreateInput = {
    id?: string
    trackingNumber: string
    deliveryQuestId?: string | null
    routeId?: string | null
    itemId: string
    quantity: number
    weight: number
    status?: string
    currentLocation: string
    scheduledPickup: Date | string
    actualPickup?: Date | string | null
    scheduledDelivery: Date | string
    actualDelivery?: Date | string | null
    handlerType: string
    handlerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogisticsTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    deliveryQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currentLocation?: StringFieldUpdateOperationsInput | string
    scheduledPickup?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickup?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handlerType?: StringFieldUpdateOperationsInput | string
    handlerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogisticsTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    deliveryQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currentLocation?: StringFieldUpdateOperationsInput | string
    scheduledPickup?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickup?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handlerType?: StringFieldUpdateOperationsInput | string
    handlerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogisticsTrackingCreateManyInput = {
    id?: string
    trackingNumber: string
    deliveryQuestId?: string | null
    routeId?: string | null
    itemId: string
    quantity: number
    weight: number
    status?: string
    currentLocation: string
    scheduledPickup: Date | string
    actualPickup?: Date | string | null
    scheduledDelivery: Date | string
    actualDelivery?: Date | string | null
    handlerType: string
    handlerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogisticsTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    deliveryQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currentLocation?: StringFieldUpdateOperationsInput | string
    scheduledPickup?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickup?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handlerType?: StringFieldUpdateOperationsInput | string
    handlerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogisticsTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingNumber?: StringFieldUpdateOperationsInput | string
    deliveryQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    currentLocation?: StringFieldUpdateOperationsInput | string
    scheduledPickup?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickup?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDelivery?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    handlerType?: StringFieldUpdateOperationsInput | string
    handlerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicalStorageCreateInput = {
    id?: string
    itemId: string
    quantity?: number
    quality?: string
    manaUsed: number
    storedAt?: Date | string
    lastAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutMagicalStorageInput
  }

  export type MagicalStorageUncheckedCreateInput = {
    id?: string
    characterId: string
    itemId: string
    quantity?: number
    quality?: string
    manaUsed: number
    storedAt?: Date | string
    lastAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicalStorageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutMagicalStorageNestedInput
  }

  export type MagicalStorageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicalStorageCreateManyInput = {
    id?: string
    characterId: string
    itemId: string
    quantity?: number
    quality?: string
    manaUsed: number
    storedAt?: Date | string
    lastAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicalStorageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicalStorageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NpcDeliveryRouteCreateInput = {
    id?: string
    deliveryNpcId: string
    routeName: string
    startLocation: string
    endLocation: string
    waypoints: string
    totalDistance: number
    estimatedTime: number
    isActive?: boolean
    priority?: number
    frequency?: string
    lastRun?: Date | string | null
    nextScheduledRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NpcDeliveryRouteUncheckedCreateInput = {
    id?: string
    deliveryNpcId: string
    routeName: string
    startLocation: string
    endLocation: string
    waypoints: string
    totalDistance: number
    estimatedTime: number
    isActive?: boolean
    priority?: number
    frequency?: string
    lastRun?: Date | string | null
    nextScheduledRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NpcDeliveryRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryNpcId?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    startLocation?: StringFieldUpdateOperationsInput | string
    endLocation?: StringFieldUpdateOperationsInput | string
    waypoints?: StringFieldUpdateOperationsInput | string
    totalDistance?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NpcDeliveryRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryNpcId?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    startLocation?: StringFieldUpdateOperationsInput | string
    endLocation?: StringFieldUpdateOperationsInput | string
    waypoints?: StringFieldUpdateOperationsInput | string
    totalDistance?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NpcDeliveryRouteCreateManyInput = {
    id?: string
    deliveryNpcId: string
    routeName: string
    startLocation: string
    endLocation: string
    waypoints: string
    totalDistance: number
    estimatedTime: number
    isActive?: boolean
    priority?: number
    frequency?: string
    lastRun?: Date | string | null
    nextScheduledRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NpcDeliveryRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryNpcId?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    startLocation?: StringFieldUpdateOperationsInput | string
    endLocation?: StringFieldUpdateOperationsInput | string
    waypoints?: StringFieldUpdateOperationsInput | string
    totalDistance?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NpcDeliveryRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryNpcId?: StringFieldUpdateOperationsInput | string
    routeName?: StringFieldUpdateOperationsInput | string
    startLocation?: StringFieldUpdateOperationsInput | string
    endLocation?: StringFieldUpdateOperationsInput | string
    waypoints?: StringFieldUpdateOperationsInput | string
    totalDistance?: FloatFieldUpdateOperationsInput | number
    estimatedTime?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    frequency?: StringFieldUpdateOperationsInput | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthProvidersCreateInput = {
    id?: string
    providerId: string
    name: string
    description: string
    iconName: string
    enabled?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthProvidersUncheckedCreateInput = {
    id?: string
    providerId: string
    name: string
    description: string
    iconName: string
    enabled?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthProvidersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthProvidersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthProvidersCreateManyInput = {
    id?: string
    providerId: string
    name: string
    description: string
    iconName: string
    enabled?: boolean
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthProvidersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthProvidersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerInventoryCreateInput = {
    id?: string
    item_id: string
    quantity?: number
    quality?: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot?: number | null
    is_equipped?: boolean
    equipment_slot?: string | null
    condition?: number
    is_stackable?: boolean
    max_stack?: number
    acquired_at?: Date | string
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    game_characters: GameCharacterCreateNestedOneWithoutPlayerInventoriesInput
  }

  export type PlayerInventoryUncheckedCreateInput = {
    id?: string
    character_id: string
    item_id: string
    quantity?: number
    quality?: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot?: number | null
    is_equipped?: boolean
    equipment_slot?: string | null
    condition?: number
    is_stackable?: boolean
    max_stack?: number
    acquired_at?: Date | string
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlayerInventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    game_characters?: GameCharacterUpdateOneRequiredWithoutPlayerInventoriesNestedInput
  }

  export type PlayerInventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerInventoryCreateManyInput = {
    id?: string
    character_id: string
    item_id: string
    quantity?: number
    quality?: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot?: number | null
    is_equipped?: boolean
    equipment_slot?: string | null
    condition?: number
    is_stackable?: boolean
    max_stack?: number
    acquired_at?: Date | string
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlayerInventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerInventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SkillDecayLogCreateInput = {
    id?: string
    character_id: string
    skill_type: string
    knowledge_name: string
    event_type: string
    original_value: number
    new_value: number
    decay_amount: number
    days_since_last_practice: number
    action?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillDecayLogUncheckedCreateInput = {
    id?: string
    character_id: string
    skill_type: string
    knowledge_name: string
    event_type: string
    original_value: number
    new_value: number
    decay_amount: number
    days_since_last_practice: number
    action?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillDecayLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    knowledge_name?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
    original_value?: IntFieldUpdateOperationsInput | number
    new_value?: IntFieldUpdateOperationsInput | number
    decay_amount?: IntFieldUpdateOperationsInput | number
    days_since_last_practice?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillDecayLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    knowledge_name?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
    original_value?: IntFieldUpdateOperationsInput | number
    new_value?: IntFieldUpdateOperationsInput | number
    decay_amount?: IntFieldUpdateOperationsInput | number
    days_since_last_practice?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillDecayLogCreateManyInput = {
    id?: string
    character_id: string
    skill_type: string
    knowledge_name: string
    event_type: string
    original_value: number
    new_value: number
    decay_amount: number
    days_since_last_practice: number
    action?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillDecayLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    knowledge_name?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
    original_value?: IntFieldUpdateOperationsInput | number
    new_value?: IntFieldUpdateOperationsInput | number
    decay_amount?: IntFieldUpdateOperationsInput | number
    days_since_last_practice?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillDecayLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    character_id?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    knowledge_name?: StringFieldUpdateOperationsInput | string
    event_type?: StringFieldUpdateOperationsInput | string
    original_value?: IntFieldUpdateOperationsInput | number
    new_value?: IntFieldUpdateOperationsInput | number
    decay_amount?: IntFieldUpdateOperationsInput | number
    days_since_last_practice?: IntFieldUpdateOperationsInput | number
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPracticeHistoryCreateInput = {
    id?: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    character_skills: CharacterSkillCreateNestedOneWithoutSkillPracticeHistoryInput
  }

  export type SkillPracticeHistoryUncheckedCreateInput = {
    id?: string
    skill_id: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillPracticeHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    character_skills?: CharacterSkillUpdateOneRequiredWithoutSkillPracticeHistoryNestedInput
  }

  export type SkillPracticeHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPracticeHistoryCreateManyInput = {
    id?: string
    skill_id: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillPracticeHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPracticeHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserEmailCreateInput = {
    id?: string
    email: string
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserEmailsInput
  }

  export type UserEmailUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserEmailsNestedInput
  }

  export type UserEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailCreateManyInput = {
    id?: string
    userId: string
    email: string
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    location?: string | null
    motto?: string | null
    title?: string | null
    phone?: string | null
    website?: string | null
    discordTag?: string | null
    githubUrl?: string | null
    facebookUrl?: string | null
    instagramUrl?: string | null
    xUrl?: string | null
    linkedinUrl?: string | null
    snapchatUrl?: string | null
    favoriteClass?: string | null
    playStyle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    location?: string | null
    motto?: string | null
    title?: string | null
    phone?: string | null
    website?: string | null
    discordTag?: string | null
    githubUrl?: string | null
    facebookUrl?: string | null
    instagramUrl?: string | null
    xUrl?: string | null
    linkedinUrl?: string | null
    snapchatUrl?: string | null
    favoriteClass?: string | null
    playStyle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discordTag?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatUrl?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteClass?: NullableStringFieldUpdateOperationsInput | string | null
    playStyle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discordTag?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatUrl?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteClass?: NullableStringFieldUpdateOperationsInput | string | null
    playStyle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    location?: string | null
    motto?: string | null
    title?: string | null
    phone?: string | null
    website?: string | null
    discordTag?: string | null
    githubUrl?: string | null
    facebookUrl?: string | null
    instagramUrl?: string | null
    xUrl?: string | null
    linkedinUrl?: string | null
    snapchatUrl?: string | null
    favoriteClass?: string | null
    playStyle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discordTag?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatUrl?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteClass?: NullableStringFieldUpdateOperationsInput | string | null
    playStyle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discordTag?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatUrl?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteClass?: NullableStringFieldUpdateOperationsInput | string | null
    playStyle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    cardColor?: string
    cardTheme?: string
    publicEmailChoice?: string | null
    theme?: string
    language?: string
    pinnedForums?: UserSettingsCreatepinnedForumsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isProfilePublic?: boolean
    user: UserCreateNestedOneWithoutUserSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    cardColor?: string
    cardTheme?: string
    publicEmailChoice?: string | null
    theme?: string
    language?: string
    pinnedForums?: UserSettingsCreatepinnedForumsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isProfilePublic?: boolean
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardColor?: StringFieldUpdateOperationsInput | string
    cardTheme?: StringFieldUpdateOperationsInput | string
    publicEmailChoice?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    pinnedForums?: UserSettingsUpdatepinnedForumsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardColor?: StringFieldUpdateOperationsInput | string
    cardTheme?: StringFieldUpdateOperationsInput | string
    publicEmailChoice?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    pinnedForums?: UserSettingsUpdatepinnedForumsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    cardColor?: string
    cardTheme?: string
    publicEmailChoice?: string | null
    theme?: string
    language?: string
    pinnedForums?: UserSettingsCreatepinnedForumsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isProfilePublic?: boolean
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardColor?: StringFieldUpdateOperationsInput | string
    cardTheme?: StringFieldUpdateOperationsInput | string
    publicEmailChoice?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    pinnedForums?: UserSettingsUpdatepinnedForumsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardColor?: StringFieldUpdateOperationsInput | string
    cardTheme?: StringFieldUpdateOperationsInput | string
    publicEmailChoice?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    pinnedForums?: UserSettingsUpdatepinnedForumsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPresenceCreateInput = {
    isOnline?: boolean
    lastSeen?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPresenceInput
  }

  export type UserPresenceUncheckedCreateInput = {
    userId: string
    isOnline?: boolean
    lastSeen?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserPresenceUpdateInput = {
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPresenceNestedInput
  }

  export type UserPresenceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceCreateManyInput = {
    userId: string
    isOnline?: boolean
    lastSeen?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserPresenceUpdateManyMutationInput = {
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwksCreateInput = {
    id?: string
    publicKey: string
    privateKey: string
    createdAt?: Date | string
  }

  export type JwksUncheckedCreateInput = {
    id?: string
    publicKey: string
    privateKey: string
    createdAt?: Date | string
  }

  export type JwksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwksCreateManyInput = {
    id?: string
    publicKey: string
    privateKey: string
    createdAt?: Date | string
  }

  export type JwksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    privateKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    status?: $Enums.FriendRequestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendRequestUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    status?: $Enums.FriendRequestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    status?: $Enums.FriendRequestStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    createdAt?: Date | string
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    user1Id: string
    user2Id: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateInput = {
    id?: string
    blockedById: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserUncheckedCreateInput = {
    id?: string
    blockedById: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedById?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedById?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateManyInput = {
    id?: string
    blockedById: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockedUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedById?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedById?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    isDelivered?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    isDelivered?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDelivered?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDelivered?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    isDelivered?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDelivered?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDelivered?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    likes?: LikeCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    likes?: LikeUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicCreateInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumReplyCreateNestedManyWithoutTopicInput
    likes?: ForumTopicLikeCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumReplyUncheckedCreateNestedManyWithoutTopicInput
    likes?: ForumTopicLikeUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumReplyUpdateManyWithoutTopicNestedInput
    likes?: ForumTopicLikeUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumReplyUncheckedUpdateManyWithoutTopicNestedInput
    likes?: ForumTopicLikeUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicCreateManyInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumTopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyCreateInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    likes?: ForumReplyLikeCreateNestedManyWithoutReplyInput
  }

  export type ForumReplyUncheckedCreateInput = {
    id?: string
    topicId: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ForumReplyLikeUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ForumReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    likes?: ForumReplyLikeUpdateManyWithoutReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ForumReplyLikeUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type ForumReplyCreateManyInput = {
    id?: string
    topicId: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicLikeCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutLikesInput
  }

  export type ForumTopicLikeUncheckedCreateInput = {
    id?: string
    topicId: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumTopicLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutLikesNestedInput
  }

  export type ForumTopicLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicLikeCreateManyInput = {
    id?: string
    topicId: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumTopicLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyLikeCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    reply: ForumReplyCreateNestedOneWithoutLikesInput
  }

  export type ForumReplyLikeUncheckedCreateInput = {
    id?: string
    replyId: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumReplyLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reply?: ForumReplyUpdateOneRequiredWithoutLikesNestedInput
  }

  export type ForumReplyLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    replyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyLikeCreateManyInput = {
    id?: string
    replyId: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumReplyLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    replyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type GameCharacterRelationFilter = {
    is?: GameCharacterWhereInput
    isNot?: GameCharacterWhereInput
  }

  export type BankTransactionListRelationFilter = {
    every?: BankTransactionWhereInput
    some?: BankTransactionWhereInput
    none?: BankTransactionWhereInput
  }

  export type LoanListRelationFilter = {
    every?: LoanWhereInput
    some?: LoanWhereInput
    none?: LoanWhereInput
  }

  export type BankTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
    accountStatus?: SortOrder
    openedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
    accountStatus?: SortOrder
    openedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    accountType?: SortOrder
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
    accountStatus?: SortOrder
    openedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    balance?: SortOrder
    creditScore?: SortOrder
    creditLimit?: SortOrder
    interestRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BankAccountRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type BankTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type BankTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type CharacterKnowledgeCharacterIdSkillTypeKnowledgeNameCompoundUniqueInput = {
    characterId: string
    skillType: string
    knowledgeName: string
  }

  export type CharacterKnowledgeCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    knowledgeType?: SortOrder
    knowledgeName?: SortOrder
    description?: SortOrder
    proficiency?: SortOrder
    learnedAt?: SortOrder
    teacherNpcId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterKnowledgeAvgOrderByAggregateInput = {
    proficiency?: SortOrder
  }

  export type CharacterKnowledgeMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    knowledgeType?: SortOrder
    knowledgeName?: SortOrder
    description?: SortOrder
    proficiency?: SortOrder
    learnedAt?: SortOrder
    teacherNpcId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterKnowledgeMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    knowledgeType?: SortOrder
    knowledgeName?: SortOrder
    description?: SortOrder
    proficiency?: SortOrder
    learnedAt?: SortOrder
    teacherNpcId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterKnowledgeSumOrderByAggregateInput = {
    proficiency?: SortOrder
  }

  export type SkillPracticeHistoryListRelationFilter = {
    every?: SkillPracticeHistoryWhereInput
    some?: SkillPracticeHistoryWhereInput
    none?: SkillPracticeHistoryWhereInput
  }

  export type SkillPracticeHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterSkillCharacterIdSkillTypeCompoundUniqueInput = {
    characterId: string
    skillType: string
  }

  export type CharacterSkillCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    experience?: SortOrder
    level?: SortOrder
    unlockedAt?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSkillAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type CharacterSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    experience?: SortOrder
    level?: SortOrder
    unlockedAt?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSkillMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    skillType?: SortOrder
    experience?: SortOrder
    level?: SortOrder
    unlockedAt?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSkillSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DeliveryQuestCountOrderByAggregateInput = {
    id?: SortOrder
    questId?: SortOrder
    deliveryType?: SortOrder
    fromNpcId?: SortOrder
    toNpcId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    itemId?: SortOrder
    itemQuality?: SortOrder
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pickupConfirmed?: SortOrder
    deliveryConfirmed?: SortOrder
    currentLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryQuestAvgOrderByAggregateInput = {
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrder
    distance?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
  }

  export type DeliveryQuestMaxOrderByAggregateInput = {
    id?: SortOrder
    questId?: SortOrder
    deliveryType?: SortOrder
    fromNpcId?: SortOrder
    toNpcId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    itemId?: SortOrder
    itemQuality?: SortOrder
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pickupConfirmed?: SortOrder
    deliveryConfirmed?: SortOrder
    currentLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryQuestMinOrderByAggregateInput = {
    id?: SortOrder
    questId?: SortOrder
    deliveryType?: SortOrder
    fromNpcId?: SortOrder
    toNpcId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    itemId?: SortOrder
    itemQuality?: SortOrder
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pickupConfirmed?: SortOrder
    deliveryConfirmed?: SortOrder
    currentLocation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryQuestSumOrderByAggregateInput = {
    quantity?: SortOrder
    totalWeight?: SortOrder
    requiredCapacity?: SortOrder
    timeLimit?: SortOrder
    distance?: SortOrder
    goldReward?: SortOrder
    experienceReward?: SortOrder
    reputationReward?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BankAccountNullableRelationFilter = {
    is?: BankAccountWhereInput | null
    isNot?: BankAccountWhereInput | null
  }

  export type CharacterKnowledgeListRelationFilter = {
    every?: CharacterKnowledgeWhereInput
    some?: CharacterKnowledgeWhereInput
    none?: CharacterKnowledgeWhereInput
  }

  export type CharacterSkillListRelationFilter = {
    every?: CharacterSkillWhereInput
    some?: CharacterSkillWhereInput
    none?: CharacterSkillWhereInput
  }

  export type JobChangeHistoryListRelationFilter = {
    every?: JobChangeHistoryWhereInput
    some?: JobChangeHistoryWhereInput
    none?: JobChangeHistoryWhereInput
  }

  export type MagicalStorageListRelationFilter = {
    every?: MagicalStorageWhereInput
    some?: MagicalStorageWhereInput
    none?: MagicalStorageWhereInput
  }

  export type PlayerInventoryListRelationFilter = {
    every?: PlayerInventoryWhereInput
    some?: PlayerInventoryWhereInput
    none?: PlayerInventoryWhereInput
  }

  export type CharacterKnowledgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobChangeHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MagicalStorageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCharacterCountOrderByAggregateInput = {
    id?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    characterClass?: SortOrder
    currentMapLocation?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    equippedArmor?: SortOrder
    equippedBackpack?: SortOrder
    equippedWeapon?: SortOrder
    goldAmount?: SortOrder
    isResting?: SortOrder
    lastSaveTimestamp?: SortOrder
    lastStaminaUpdate?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    restStartTime?: SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    equippedGloves?: SortOrder
    equippedPants?: SortOrder
    equippedShield?: SortOrder
    equippedShirt?: SortOrder
    equippedShoes?: SortOrder
    luckPercentage?: SortOrder
  }

  export type GameCharacterAvgOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    goldAmount?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    luckPercentage?: SortOrder
  }

  export type GameCharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    characterClass?: SortOrder
    currentMapLocation?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    equippedArmor?: SortOrder
    equippedBackpack?: SortOrder
    equippedWeapon?: SortOrder
    goldAmount?: SortOrder
    isResting?: SortOrder
    lastSaveTimestamp?: SortOrder
    lastStaminaUpdate?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    restStartTime?: SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    equippedGloves?: SortOrder
    equippedPants?: SortOrder
    equippedShield?: SortOrder
    equippedShirt?: SortOrder
    equippedShoes?: SortOrder
    luckPercentage?: SortOrder
  }

  export type GameCharacterMinOrderByAggregateInput = {
    id?: SortOrder
    characterName?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    characterClass?: SortOrder
    currentMapLocation?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    equippedArmor?: SortOrder
    equippedBackpack?: SortOrder
    equippedWeapon?: SortOrder
    goldAmount?: SortOrder
    isResting?: SortOrder
    lastSaveTimestamp?: SortOrder
    lastStaminaUpdate?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    restStartTime?: SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    equippedGloves?: SortOrder
    equippedPants?: SortOrder
    equippedShield?: SortOrder
    equippedShirt?: SortOrder
    equippedShoes?: SortOrder
    luckPercentage?: SortOrder
  }

  export type GameCharacterSumOrderByAggregateInput = {
    level?: SortOrder
    experience?: SortOrder
    health?: SortOrder
    maxHealth?: SortOrder
    mana?: SortOrder
    maxMana?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    intelligence?: SortOrder
    vitality?: SortOrder
    luck?: SortOrder
    availableStatPoints?: SortOrder
    baseCarryingCapacity?: SortOrder
    carryingCapacity?: SortOrder
    currentVolume?: SortOrder
    currentWeight?: SortOrder
    goldAmount?: SortOrder
    magicalStorageCapacity?: SortOrder
    magicalStorageUsed?: SortOrder
    maxStamina?: SortOrder
    maxVolume?: SortOrder
    movementPenalty?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    stamina?: SortOrder
    staminaRegenRate?: SortOrder
    baseStamina?: SortOrder
    luckPercentage?: SortOrder
  }

  export type JobChangeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    fromClass?: SortOrder
    toClass?: SortOrder
    changedAt?: SortOrder
    npcTrainerId?: SortOrder
    costPaid?: SortOrder
    levelAtChange?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobChangeHistoryAvgOrderByAggregateInput = {
    costPaid?: SortOrder
    levelAtChange?: SortOrder
  }

  export type JobChangeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    fromClass?: SortOrder
    toClass?: SortOrder
    changedAt?: SortOrder
    npcTrainerId?: SortOrder
    costPaid?: SortOrder
    levelAtChange?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobChangeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    fromClass?: SortOrder
    toClass?: SortOrder
    changedAt?: SortOrder
    npcTrainerId?: SortOrder
    costPaid?: SortOrder
    levelAtChange?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobChangeHistorySumOrderByAggregateInput = {
    costPaid?: SortOrder
    levelAtChange?: SortOrder
  }

  export type LoanRelationFilter = {
    is?: LoanWhereInput
    isNot?: LoanWhereInput
  }

  export type LoanPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
  }

  export type LoanPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    loanId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    principalPaid?: SortOrder
    interestPaid?: SortOrder
  }

  export type LoanPaymentListRelationFilter = {
    every?: LoanPaymentWhereInput
    some?: LoanPaymentWhereInput
    none?: LoanPaymentWhereInput
  }

  export type LoanPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanCountOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    loanPurpose?: SortOrder
    nextPaymentDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanAvgOrderByAggregateInput = {
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
  }

  export type LoanMaxOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    loanPurpose?: SortOrder
    nextPaymentDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanMinOrderByAggregateInput = {
    id?: SortOrder
    bankAccountId?: SortOrder
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
    status?: SortOrder
    loanPurpose?: SortOrder
    nextPaymentDue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanSumOrderByAggregateInput = {
    principalAmount?: SortOrder
    interestRate?: SortOrder
    termMonths?: SortOrder
    monthlyPayment?: SortOrder
    remainingBalance?: SortOrder
  }

  export type LogisticsTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    deliveryQuestId?: SortOrder
    routeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    currentLocation?: SortOrder
    scheduledPickup?: SortOrder
    actualPickup?: SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrder
    handlerType?: SortOrder
    handlerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogisticsTrackingAvgOrderByAggregateInput = {
    quantity?: SortOrder
    weight?: SortOrder
  }

  export type LogisticsTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    deliveryQuestId?: SortOrder
    routeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    currentLocation?: SortOrder
    scheduledPickup?: SortOrder
    actualPickup?: SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrder
    handlerType?: SortOrder
    handlerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogisticsTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    trackingNumber?: SortOrder
    deliveryQuestId?: SortOrder
    routeId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    currentLocation?: SortOrder
    scheduledPickup?: SortOrder
    actualPickup?: SortOrder
    scheduledDelivery?: SortOrder
    actualDelivery?: SortOrder
    handlerType?: SortOrder
    handlerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogisticsTrackingSumOrderByAggregateInput = {
    quantity?: SortOrder
    weight?: SortOrder
  }

  export type MagicalStorageCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    manaUsed?: SortOrder
    storedAt?: SortOrder
    lastAccessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicalStorageAvgOrderByAggregateInput = {
    quantity?: SortOrder
    manaUsed?: SortOrder
  }

  export type MagicalStorageMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    manaUsed?: SortOrder
    storedAt?: SortOrder
    lastAccessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicalStorageMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    manaUsed?: SortOrder
    storedAt?: SortOrder
    lastAccessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicalStorageSumOrderByAggregateInput = {
    quantity?: SortOrder
    manaUsed?: SortOrder
  }

  export type NpcDeliveryRouteCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryNpcId?: SortOrder
    routeName?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    waypoints?: SortOrder
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    frequency?: SortOrder
    lastRun?: SortOrder
    nextScheduledRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NpcDeliveryRouteAvgOrderByAggregateInput = {
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    priority?: SortOrder
  }

  export type NpcDeliveryRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryNpcId?: SortOrder
    routeName?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    waypoints?: SortOrder
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    frequency?: SortOrder
    lastRun?: SortOrder
    nextScheduledRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NpcDeliveryRouteMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryNpcId?: SortOrder
    routeName?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    waypoints?: SortOrder
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    frequency?: SortOrder
    lastRun?: SortOrder
    nextScheduledRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NpcDeliveryRouteSumOrderByAggregateInput = {
    totalDistance?: SortOrder
    estimatedTime?: SortOrder
    priority?: SortOrder
  }

  export type OAuthProvidersCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    enabled?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthProvidersAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type OAuthProvidersMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    enabled?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthProvidersMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    enabled?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthProvidersSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PlayerInventoryCharacter_idItem_idQualityCompoundUniqueInput = {
    character_id: string
    item_id: string
    quality: string
  }

  export type PlayerInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    character_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrder
    is_equipped?: SortOrder
    equipment_slot?: SortOrder
    condition?: SortOrder
    is_stackable?: SortOrder
    max_stack?: SortOrder
    acquired_at?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlayerInventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrder
    condition?: SortOrder
    max_stack?: SortOrder
  }

  export type PlayerInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    character_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrder
    is_equipped?: SortOrder
    equipment_slot?: SortOrder
    condition?: SortOrder
    is_stackable?: SortOrder
    max_stack?: SortOrder
    acquired_at?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlayerInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    character_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrder
    is_equipped?: SortOrder
    equipment_slot?: SortOrder
    condition?: SortOrder
    is_stackable?: SortOrder
    max_stack?: SortOrder
    acquired_at?: SortOrder
    last_used_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlayerInventorySumOrderByAggregateInput = {
    quantity?: SortOrder
    weight?: SortOrder
    totalWeight?: SortOrder
    volume?: SortOrder
    totalVolume?: SortOrder
    slot?: SortOrder
    condition?: SortOrder
    max_stack?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SkillDecayLogCountOrderByAggregateInput = {
    id?: SortOrder
    character_id?: SortOrder
    skill_type?: SortOrder
    knowledge_name?: SortOrder
    event_type?: SortOrder
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillDecayLogAvgOrderByAggregateInput = {
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
  }

  export type SkillDecayLogMaxOrderByAggregateInput = {
    id?: SortOrder
    character_id?: SortOrder
    skill_type?: SortOrder
    knowledge_name?: SortOrder
    event_type?: SortOrder
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillDecayLogMinOrderByAggregateInput = {
    id?: SortOrder
    character_id?: SortOrder
    skill_type?: SortOrder
    knowledge_name?: SortOrder
    event_type?: SortOrder
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillDecayLogSumOrderByAggregateInput = {
    original_value?: SortOrder
    new_value?: SortOrder
    decay_amount?: SortOrder
    days_since_last_practice?: SortOrder
  }

  export type CharacterSkillRelationFilter = {
    is?: CharacterSkillWhereInput
    isNot?: CharacterSkillWhereInput
  }

  export type SkillPracticeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    skill_id?: SortOrder
    practice_type?: SortOrder
    practice_intensity?: SortOrder
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
    knowledge_used?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillPracticeHistoryAvgOrderByAggregateInput = {
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
  }

  export type SkillPracticeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    skill_id?: SortOrder
    practice_type?: SortOrder
    practice_intensity?: SortOrder
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
    knowledge_used?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillPracticeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    skill_id?: SortOrder
    practice_type?: SortOrder
    practice_intensity?: SortOrder
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
    knowledge_used?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SkillPracticeHistorySumOrderByAggregateInput = {
    experience_gained?: SortOrder
    proficiency_gained?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type GameCharacterNullableRelationFilter = {
    is?: GameCharacterWhereInput | null
    isNot?: GameCharacterWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserEmailListRelationFilter = {
    every?: UserEmailWhereInput
    some?: UserEmailWhereInput
    none?: UserEmailWhereInput
  }

  export type UserProfileNullableRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type UserSettingsNullableRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type UserPresenceNullableRelationFilter = {
    is?: UserPresenceWhereInput | null
    isNot?: UserPresenceWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
  }

  export type UserEmailUserIdEmailCompoundUniqueInput = {
    userId: string
    email: string
  }

  export type UserEmailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserEmailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    motto?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    discordTag?: SortOrder
    githubUrl?: SortOrder
    facebookUrl?: SortOrder
    instagramUrl?: SortOrder
    xUrl?: SortOrder
    linkedinUrl?: SortOrder
    snapchatUrl?: SortOrder
    favoriteClass?: SortOrder
    playStyle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    motto?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    discordTag?: SortOrder
    githubUrl?: SortOrder
    facebookUrl?: SortOrder
    instagramUrl?: SortOrder
    xUrl?: SortOrder
    linkedinUrl?: SortOrder
    snapchatUrl?: SortOrder
    favoriteClass?: SortOrder
    playStyle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    motto?: SortOrder
    title?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    discordTag?: SortOrder
    githubUrl?: SortOrder
    facebookUrl?: SortOrder
    instagramUrl?: SortOrder
    xUrl?: SortOrder
    linkedinUrl?: SortOrder
    snapchatUrl?: SortOrder
    favoriteClass?: SortOrder
    playStyle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardColor?: SortOrder
    cardTheme?: SortOrder
    publicEmailChoice?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    pinnedForums?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isProfilePublic?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardColor?: SortOrder
    cardTheme?: SortOrder
    publicEmailChoice?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isProfilePublic?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardColor?: SortOrder
    cardTheme?: SortOrder
    publicEmailChoice?: SortOrder
    theme?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isProfilePublic?: SortOrder
  }

  export type UserPresenceCountOrderByAggregateInput = {
    userId?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPresenceMaxOrderByAggregateInput = {
    userId?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPresenceMinOrderByAggregateInput = {
    userId?: SortOrder
    isOnline?: SortOrder
    lastSeen?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JwksCountOrderByAggregateInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type JwksMaxOrderByAggregateInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type JwksMinOrderByAggregateInput = {
    id?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFriendRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusFilter<$PrismaModel> | $Enums.FriendRequestStatus
  }

  export type FriendRequestSenderIdReceiverIdCompoundUniqueInput = {
    senderId: string
    receiverId: string
  }

  export type FriendRequestCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendRequestMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFriendRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
  }

  export type FriendshipUser1IdUser2IdCompoundUniqueInput = {
    user1Id: string
    user2Id: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserBlockedByIdBlockedUserIdCompoundUniqueInput = {
    blockedById: string
    blockedUserId: string
  }

  export type BlockedUserCountOrderByAggregateInput = {
    id?: SortOrder
    blockedById?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMaxOrderByAggregateInput = {
    id?: SortOrder
    blockedById?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMinOrderByAggregateInput = {
    id?: SortOrder
    blockedById?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDelivered?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDelivered?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDelivered?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikePostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumForumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumCategory | EnumForumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumForumCategoryFilter<$PrismaModel> | $Enums.ForumCategory
  }

  export type EnumTopicTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeFilter<$PrismaModel> | $Enums.TopicType
  }

  export type ForumReplyListRelationFilter = {
    every?: ForumReplyWhereInput
    some?: ForumReplyWhereInput
    none?: ForumReplyWhereInput
  }

  export type ForumTopicLikeListRelationFilter = {
    every?: ForumTopicLikeWhereInput
    some?: ForumTopicLikeWhereInput
    none?: ForumTopicLikeWhereInput
  }

  export type ForumReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumTopicLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumTopicCountOrderByAggregateInput = {
    id?: SortOrder
    forumId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    tags?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type ForumTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    forumId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicMinOrderByAggregateInput = {
    id?: SortOrder
    forumId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type EnumForumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumCategory | EnumForumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumForumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ForumCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForumCategoryFilter<$PrismaModel>
    _max?: NestedEnumForumCategoryFilter<$PrismaModel>
  }

  export type EnumTopicTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeWithAggregatesFilter<$PrismaModel> | $Enums.TopicType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicTypeFilter<$PrismaModel>
    _max?: NestedEnumTopicTypeFilter<$PrismaModel>
  }

  export type ForumTopicRelationFilter = {
    is?: ForumTopicWhereInput
    isNot?: ForumTopicWhereInput
  }

  export type ForumReplyLikeListRelationFilter = {
    every?: ForumReplyLikeWhereInput
    some?: ForumReplyLikeWhereInput
    none?: ForumReplyLikeWhereInput
  }

  export type ForumReplyLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumReplyCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumReplyMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicLikeTopicIdUserIdCompoundUniqueInput = {
    topicId: string
    userId: string
  }

  export type ForumTopicLikeCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumTopicLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumTopicLikeMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumReplyRelationFilter = {
    is?: ForumReplyWhereInput
    isNot?: ForumReplyWhereInput
  }

  export type ForumReplyLikeReplyIdUserIdCompoundUniqueInput = {
    replyId: string
    userId: string
  }

  export type ForumReplyLikeCountOrderByAggregateInput = {
    id?: SortOrder
    replyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumReplyLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    replyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumReplyLikeMinOrderByAggregateInput = {
    id?: SortOrder
    replyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type GameCharacterCreateNestedOneWithoutBankAccountsInput = {
    create?: XOR<GameCharacterCreateWithoutBankAccountsInput, GameCharacterUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutBankAccountsInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type BankTransactionCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type LoanCreateNestedManyWithoutBankAccountsInput = {
    create?: XOR<LoanCreateWithoutBankAccountsInput, LoanUncheckedCreateWithoutBankAccountsInput> | LoanCreateWithoutBankAccountsInput[] | LoanUncheckedCreateWithoutBankAccountsInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutBankAccountsInput | LoanCreateOrConnectWithoutBankAccountsInput[]
    createMany?: LoanCreateManyBankAccountsInputEnvelope
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type LoanUncheckedCreateNestedManyWithoutBankAccountsInput = {
    create?: XOR<LoanCreateWithoutBankAccountsInput, LoanUncheckedCreateWithoutBankAccountsInput> | LoanCreateWithoutBankAccountsInput[] | LoanUncheckedCreateWithoutBankAccountsInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutBankAccountsInput | LoanCreateOrConnectWithoutBankAccountsInput[]
    createMany?: LoanCreateManyBankAccountsInputEnvelope
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GameCharacterUpdateOneRequiredWithoutBankAccountsNestedInput = {
    create?: XOR<GameCharacterCreateWithoutBankAccountsInput, GameCharacterUncheckedCreateWithoutBankAccountsInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutBankAccountsInput
    upsert?: GameCharacterUpsertWithoutBankAccountsInput
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutBankAccountsInput, GameCharacterUpdateWithoutBankAccountsInput>, GameCharacterUncheckedUpdateWithoutBankAccountsInput>
  }

  export type BankTransactionUpdateManyWithoutBankAccountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput | BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput | BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBankAccountInput | BankTransactionUpdateManyWithWhereWithoutBankAccountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type LoanUpdateManyWithoutBankAccountsNestedInput = {
    create?: XOR<LoanCreateWithoutBankAccountsInput, LoanUncheckedCreateWithoutBankAccountsInput> | LoanCreateWithoutBankAccountsInput[] | LoanUncheckedCreateWithoutBankAccountsInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutBankAccountsInput | LoanCreateOrConnectWithoutBankAccountsInput[]
    upsert?: LoanUpsertWithWhereUniqueWithoutBankAccountsInput | LoanUpsertWithWhereUniqueWithoutBankAccountsInput[]
    createMany?: LoanCreateManyBankAccountsInputEnvelope
    set?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    disconnect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    delete?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    update?: LoanUpdateWithWhereUniqueWithoutBankAccountsInput | LoanUpdateWithWhereUniqueWithoutBankAccountsInput[]
    updateMany?: LoanUpdateManyWithWhereWithoutBankAccountsInput | LoanUpdateManyWithWhereWithoutBankAccountsInput[]
    deleteMany?: LoanScalarWhereInput | LoanScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput> | BankTransactionCreateWithoutBankAccountInput[] | BankTransactionUncheckedCreateWithoutBankAccountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBankAccountInput | BankTransactionCreateOrConnectWithoutBankAccountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput | BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput[]
    createMany?: BankTransactionCreateManyBankAccountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput | BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBankAccountInput | BankTransactionUpdateManyWithWhereWithoutBankAccountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type LoanUncheckedUpdateManyWithoutBankAccountsNestedInput = {
    create?: XOR<LoanCreateWithoutBankAccountsInput, LoanUncheckedCreateWithoutBankAccountsInput> | LoanCreateWithoutBankAccountsInput[] | LoanUncheckedCreateWithoutBankAccountsInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutBankAccountsInput | LoanCreateOrConnectWithoutBankAccountsInput[]
    upsert?: LoanUpsertWithWhereUniqueWithoutBankAccountsInput | LoanUpsertWithWhereUniqueWithoutBankAccountsInput[]
    createMany?: LoanCreateManyBankAccountsInputEnvelope
    set?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    disconnect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    delete?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    update?: LoanUpdateWithWhereUniqueWithoutBankAccountsInput | LoanUpdateWithWhereUniqueWithoutBankAccountsInput[]
    updateMany?: LoanUpdateManyWithWhereWithoutBankAccountsInput | LoanUpdateManyWithWhereWithoutBankAccountsInput[]
    deleteMany?: LoanScalarWhereInput | LoanScalarWhereInput[]
  }

  export type BankAccountCreateNestedOneWithoutBankTransactionsInput = {
    create?: XOR<BankAccountCreateWithoutBankTransactionsInput, BankAccountUncheckedCreateWithoutBankTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutBankTransactionsInput
    connect?: BankAccountWhereUniqueInput
  }

  export type BankAccountUpdateOneRequiredWithoutBankTransactionsNestedInput = {
    create?: XOR<BankAccountCreateWithoutBankTransactionsInput, BankAccountUncheckedCreateWithoutBankTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutBankTransactionsInput
    upsert?: BankAccountUpsertWithoutBankTransactionsInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutBankTransactionsInput, BankAccountUpdateWithoutBankTransactionsInput>, BankAccountUncheckedUpdateWithoutBankTransactionsInput>
  }

  export type GameCharacterCreateNestedOneWithoutCharacterKnowledgesInput = {
    create?: XOR<GameCharacterCreateWithoutCharacterKnowledgesInput, GameCharacterUncheckedCreateWithoutCharacterKnowledgesInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutCharacterKnowledgesInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type GameCharacterUpdateOneRequiredWithoutCharacterKnowledgesNestedInput = {
    create?: XOR<GameCharacterCreateWithoutCharacterKnowledgesInput, GameCharacterUncheckedCreateWithoutCharacterKnowledgesInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutCharacterKnowledgesInput
    upsert?: GameCharacterUpsertWithoutCharacterKnowledgesInput
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutCharacterKnowledgesInput, GameCharacterUpdateWithoutCharacterKnowledgesInput>, GameCharacterUncheckedUpdateWithoutCharacterKnowledgesInput>
  }

  export type GameCharacterCreateNestedOneWithoutCharacterSkillsInput = {
    create?: XOR<GameCharacterCreateWithoutCharacterSkillsInput, GameCharacterUncheckedCreateWithoutCharacterSkillsInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutCharacterSkillsInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type SkillPracticeHistoryCreateNestedManyWithoutCharacter_skillsInput = {
    create?: XOR<SkillPracticeHistoryCreateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput> | SkillPracticeHistoryCreateWithoutCharacter_skillsInput[] | SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput[]
    connectOrCreate?: SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput | SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput[]
    createMany?: SkillPracticeHistoryCreateManyCharacter_skillsInputEnvelope
    connect?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
  }

  export type SkillPracticeHistoryUncheckedCreateNestedManyWithoutCharacter_skillsInput = {
    create?: XOR<SkillPracticeHistoryCreateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput> | SkillPracticeHistoryCreateWithoutCharacter_skillsInput[] | SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput[]
    connectOrCreate?: SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput | SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput[]
    createMany?: SkillPracticeHistoryCreateManyCharacter_skillsInputEnvelope
    connect?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
  }

  export type GameCharacterUpdateOneRequiredWithoutCharacterSkillsNestedInput = {
    create?: XOR<GameCharacterCreateWithoutCharacterSkillsInput, GameCharacterUncheckedCreateWithoutCharacterSkillsInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutCharacterSkillsInput
    upsert?: GameCharacterUpsertWithoutCharacterSkillsInput
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutCharacterSkillsInput, GameCharacterUpdateWithoutCharacterSkillsInput>, GameCharacterUncheckedUpdateWithoutCharacterSkillsInput>
  }

  export type SkillPracticeHistoryUpdateManyWithoutCharacter_skillsNestedInput = {
    create?: XOR<SkillPracticeHistoryCreateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput> | SkillPracticeHistoryCreateWithoutCharacter_skillsInput[] | SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput[]
    connectOrCreate?: SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput | SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput[]
    upsert?: SkillPracticeHistoryUpsertWithWhereUniqueWithoutCharacter_skillsInput | SkillPracticeHistoryUpsertWithWhereUniqueWithoutCharacter_skillsInput[]
    createMany?: SkillPracticeHistoryCreateManyCharacter_skillsInputEnvelope
    set?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    disconnect?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    delete?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    connect?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    update?: SkillPracticeHistoryUpdateWithWhereUniqueWithoutCharacter_skillsInput | SkillPracticeHistoryUpdateWithWhereUniqueWithoutCharacter_skillsInput[]
    updateMany?: SkillPracticeHistoryUpdateManyWithWhereWithoutCharacter_skillsInput | SkillPracticeHistoryUpdateManyWithWhereWithoutCharacter_skillsInput[]
    deleteMany?: SkillPracticeHistoryScalarWhereInput | SkillPracticeHistoryScalarWhereInput[]
  }

  export type SkillPracticeHistoryUncheckedUpdateManyWithoutCharacter_skillsNestedInput = {
    create?: XOR<SkillPracticeHistoryCreateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput> | SkillPracticeHistoryCreateWithoutCharacter_skillsInput[] | SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput[]
    connectOrCreate?: SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput | SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput[]
    upsert?: SkillPracticeHistoryUpsertWithWhereUniqueWithoutCharacter_skillsInput | SkillPracticeHistoryUpsertWithWhereUniqueWithoutCharacter_skillsInput[]
    createMany?: SkillPracticeHistoryCreateManyCharacter_skillsInputEnvelope
    set?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    disconnect?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    delete?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    connect?: SkillPracticeHistoryWhereUniqueInput | SkillPracticeHistoryWhereUniqueInput[]
    update?: SkillPracticeHistoryUpdateWithWhereUniqueWithoutCharacter_skillsInput | SkillPracticeHistoryUpdateWithWhereUniqueWithoutCharacter_skillsInput[]
    updateMany?: SkillPracticeHistoryUpdateManyWithWhereWithoutCharacter_skillsInput | SkillPracticeHistoryUpdateManyWithWhereWithoutCharacter_skillsInput[]
    deleteMany?: SkillPracticeHistoryScalarWhereInput | SkillPracticeHistoryScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BankAccountCreateNestedOneWithoutGameCharacterInput = {
    create?: XOR<BankAccountCreateWithoutGameCharacterInput, BankAccountUncheckedCreateWithoutGameCharacterInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutGameCharacterInput
    connect?: BankAccountWhereUniqueInput
  }

  export type CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput = {
    create?: XOR<CharacterKnowledgeCreateWithoutGameCharacterInput, CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput> | CharacterKnowledgeCreateWithoutGameCharacterInput[] | CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput | CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput[]
    createMany?: CharacterKnowledgeCreateManyGameCharacterInputEnvelope
    connect?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
  }

  export type CharacterSkillCreateNestedManyWithoutGameCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutGameCharacterInput, CharacterSkillUncheckedCreateWithoutGameCharacterInput> | CharacterSkillCreateWithoutGameCharacterInput[] | CharacterSkillUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutGameCharacterInput | CharacterSkillCreateOrConnectWithoutGameCharacterInput[]
    createMany?: CharacterSkillCreateManyGameCharacterInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutGameCharactersInput = {
    create?: XOR<UserCreateWithoutGameCharactersInput, UserUncheckedCreateWithoutGameCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type JobChangeHistoryCreateNestedManyWithoutGameCharactersInput = {
    create?: XOR<JobChangeHistoryCreateWithoutGameCharactersInput, JobChangeHistoryUncheckedCreateWithoutGameCharactersInput> | JobChangeHistoryCreateWithoutGameCharactersInput[] | JobChangeHistoryUncheckedCreateWithoutGameCharactersInput[]
    connectOrCreate?: JobChangeHistoryCreateOrConnectWithoutGameCharactersInput | JobChangeHistoryCreateOrConnectWithoutGameCharactersInput[]
    createMany?: JobChangeHistoryCreateManyGameCharactersInputEnvelope
    connect?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
  }

  export type MagicalStorageCreateNestedManyWithoutGameCharacterInput = {
    create?: XOR<MagicalStorageCreateWithoutGameCharacterInput, MagicalStorageUncheckedCreateWithoutGameCharacterInput> | MagicalStorageCreateWithoutGameCharacterInput[] | MagicalStorageUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: MagicalStorageCreateOrConnectWithoutGameCharacterInput | MagicalStorageCreateOrConnectWithoutGameCharacterInput[]
    createMany?: MagicalStorageCreateManyGameCharacterInputEnvelope
    connect?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
  }

  export type PlayerInventoryCreateNestedManyWithoutGame_charactersInput = {
    create?: XOR<PlayerInventoryCreateWithoutGame_charactersInput, PlayerInventoryUncheckedCreateWithoutGame_charactersInput> | PlayerInventoryCreateWithoutGame_charactersInput[] | PlayerInventoryUncheckedCreateWithoutGame_charactersInput[]
    connectOrCreate?: PlayerInventoryCreateOrConnectWithoutGame_charactersInput | PlayerInventoryCreateOrConnectWithoutGame_charactersInput[]
    createMany?: PlayerInventoryCreateManyGame_charactersInputEnvelope
    connect?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
  }

  export type BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput = {
    create?: XOR<BankAccountCreateWithoutGameCharacterInput, BankAccountUncheckedCreateWithoutGameCharacterInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutGameCharacterInput
    connect?: BankAccountWhereUniqueInput
  }

  export type CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput = {
    create?: XOR<CharacterKnowledgeCreateWithoutGameCharacterInput, CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput> | CharacterKnowledgeCreateWithoutGameCharacterInput[] | CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput | CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput[]
    createMany?: CharacterKnowledgeCreateManyGameCharacterInputEnvelope
    connect?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
  }

  export type CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutGameCharacterInput, CharacterSkillUncheckedCreateWithoutGameCharacterInput> | CharacterSkillCreateWithoutGameCharacterInput[] | CharacterSkillUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutGameCharacterInput | CharacterSkillCreateOrConnectWithoutGameCharacterInput[]
    createMany?: CharacterSkillCreateManyGameCharacterInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput = {
    create?: XOR<JobChangeHistoryCreateWithoutGameCharactersInput, JobChangeHistoryUncheckedCreateWithoutGameCharactersInput> | JobChangeHistoryCreateWithoutGameCharactersInput[] | JobChangeHistoryUncheckedCreateWithoutGameCharactersInput[]
    connectOrCreate?: JobChangeHistoryCreateOrConnectWithoutGameCharactersInput | JobChangeHistoryCreateOrConnectWithoutGameCharactersInput[]
    createMany?: JobChangeHistoryCreateManyGameCharactersInputEnvelope
    connect?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
  }

  export type MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput = {
    create?: XOR<MagicalStorageCreateWithoutGameCharacterInput, MagicalStorageUncheckedCreateWithoutGameCharacterInput> | MagicalStorageCreateWithoutGameCharacterInput[] | MagicalStorageUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: MagicalStorageCreateOrConnectWithoutGameCharacterInput | MagicalStorageCreateOrConnectWithoutGameCharacterInput[]
    createMany?: MagicalStorageCreateManyGameCharacterInputEnvelope
    connect?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
  }

  export type PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput = {
    create?: XOR<PlayerInventoryCreateWithoutGame_charactersInput, PlayerInventoryUncheckedCreateWithoutGame_charactersInput> | PlayerInventoryCreateWithoutGame_charactersInput[] | PlayerInventoryUncheckedCreateWithoutGame_charactersInput[]
    connectOrCreate?: PlayerInventoryCreateOrConnectWithoutGame_charactersInput | PlayerInventoryCreateOrConnectWithoutGame_charactersInput[]
    createMany?: PlayerInventoryCreateManyGame_charactersInputEnvelope
    connect?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
  }

  export type BankAccountUpdateOneWithoutGameCharacterNestedInput = {
    create?: XOR<BankAccountCreateWithoutGameCharacterInput, BankAccountUncheckedCreateWithoutGameCharacterInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutGameCharacterInput
    upsert?: BankAccountUpsertWithoutGameCharacterInput
    disconnect?: BankAccountWhereInput | boolean
    delete?: BankAccountWhereInput | boolean
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutGameCharacterInput, BankAccountUpdateWithoutGameCharacterInput>, BankAccountUncheckedUpdateWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput = {
    create?: XOR<CharacterKnowledgeCreateWithoutGameCharacterInput, CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput> | CharacterKnowledgeCreateWithoutGameCharacterInput[] | CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput | CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput[]
    upsert?: CharacterKnowledgeUpsertWithWhereUniqueWithoutGameCharacterInput | CharacterKnowledgeUpsertWithWhereUniqueWithoutGameCharacterInput[]
    createMany?: CharacterKnowledgeCreateManyGameCharacterInputEnvelope
    set?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    disconnect?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    delete?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    connect?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    update?: CharacterKnowledgeUpdateWithWhereUniqueWithoutGameCharacterInput | CharacterKnowledgeUpdateWithWhereUniqueWithoutGameCharacterInput[]
    updateMany?: CharacterKnowledgeUpdateManyWithWhereWithoutGameCharacterInput | CharacterKnowledgeUpdateManyWithWhereWithoutGameCharacterInput[]
    deleteMany?: CharacterKnowledgeScalarWhereInput | CharacterKnowledgeScalarWhereInput[]
  }

  export type CharacterSkillUpdateManyWithoutGameCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutGameCharacterInput, CharacterSkillUncheckedCreateWithoutGameCharacterInput> | CharacterSkillCreateWithoutGameCharacterInput[] | CharacterSkillUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutGameCharacterInput | CharacterSkillCreateOrConnectWithoutGameCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutGameCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutGameCharacterInput[]
    createMany?: CharacterSkillCreateManyGameCharacterInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutGameCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutGameCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutGameCharacterInput | CharacterSkillUpdateManyWithWhereWithoutGameCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutGameCharactersNestedInput = {
    create?: XOR<UserCreateWithoutGameCharactersInput, UserUncheckedCreateWithoutGameCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameCharactersInput
    upsert?: UserUpsertWithoutGameCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameCharactersInput, UserUpdateWithoutGameCharactersInput>, UserUncheckedUpdateWithoutGameCharactersInput>
  }

  export type JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput = {
    create?: XOR<JobChangeHistoryCreateWithoutGameCharactersInput, JobChangeHistoryUncheckedCreateWithoutGameCharactersInput> | JobChangeHistoryCreateWithoutGameCharactersInput[] | JobChangeHistoryUncheckedCreateWithoutGameCharactersInput[]
    connectOrCreate?: JobChangeHistoryCreateOrConnectWithoutGameCharactersInput | JobChangeHistoryCreateOrConnectWithoutGameCharactersInput[]
    upsert?: JobChangeHistoryUpsertWithWhereUniqueWithoutGameCharactersInput | JobChangeHistoryUpsertWithWhereUniqueWithoutGameCharactersInput[]
    createMany?: JobChangeHistoryCreateManyGameCharactersInputEnvelope
    set?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    disconnect?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    delete?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    connect?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    update?: JobChangeHistoryUpdateWithWhereUniqueWithoutGameCharactersInput | JobChangeHistoryUpdateWithWhereUniqueWithoutGameCharactersInput[]
    updateMany?: JobChangeHistoryUpdateManyWithWhereWithoutGameCharactersInput | JobChangeHistoryUpdateManyWithWhereWithoutGameCharactersInput[]
    deleteMany?: JobChangeHistoryScalarWhereInput | JobChangeHistoryScalarWhereInput[]
  }

  export type MagicalStorageUpdateManyWithoutGameCharacterNestedInput = {
    create?: XOR<MagicalStorageCreateWithoutGameCharacterInput, MagicalStorageUncheckedCreateWithoutGameCharacterInput> | MagicalStorageCreateWithoutGameCharacterInput[] | MagicalStorageUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: MagicalStorageCreateOrConnectWithoutGameCharacterInput | MagicalStorageCreateOrConnectWithoutGameCharacterInput[]
    upsert?: MagicalStorageUpsertWithWhereUniqueWithoutGameCharacterInput | MagicalStorageUpsertWithWhereUniqueWithoutGameCharacterInput[]
    createMany?: MagicalStorageCreateManyGameCharacterInputEnvelope
    set?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    disconnect?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    delete?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    connect?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    update?: MagicalStorageUpdateWithWhereUniqueWithoutGameCharacterInput | MagicalStorageUpdateWithWhereUniqueWithoutGameCharacterInput[]
    updateMany?: MagicalStorageUpdateManyWithWhereWithoutGameCharacterInput | MagicalStorageUpdateManyWithWhereWithoutGameCharacterInput[]
    deleteMany?: MagicalStorageScalarWhereInput | MagicalStorageScalarWhereInput[]
  }

  export type PlayerInventoryUpdateManyWithoutGame_charactersNestedInput = {
    create?: XOR<PlayerInventoryCreateWithoutGame_charactersInput, PlayerInventoryUncheckedCreateWithoutGame_charactersInput> | PlayerInventoryCreateWithoutGame_charactersInput[] | PlayerInventoryUncheckedCreateWithoutGame_charactersInput[]
    connectOrCreate?: PlayerInventoryCreateOrConnectWithoutGame_charactersInput | PlayerInventoryCreateOrConnectWithoutGame_charactersInput[]
    upsert?: PlayerInventoryUpsertWithWhereUniqueWithoutGame_charactersInput | PlayerInventoryUpsertWithWhereUniqueWithoutGame_charactersInput[]
    createMany?: PlayerInventoryCreateManyGame_charactersInputEnvelope
    set?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    disconnect?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    delete?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    connect?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    update?: PlayerInventoryUpdateWithWhereUniqueWithoutGame_charactersInput | PlayerInventoryUpdateWithWhereUniqueWithoutGame_charactersInput[]
    updateMany?: PlayerInventoryUpdateManyWithWhereWithoutGame_charactersInput | PlayerInventoryUpdateManyWithWhereWithoutGame_charactersInput[]
    deleteMany?: PlayerInventoryScalarWhereInput | PlayerInventoryScalarWhereInput[]
  }

  export type BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput = {
    create?: XOR<BankAccountCreateWithoutGameCharacterInput, BankAccountUncheckedCreateWithoutGameCharacterInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutGameCharacterInput
    upsert?: BankAccountUpsertWithoutGameCharacterInput
    disconnect?: BankAccountWhereInput | boolean
    delete?: BankAccountWhereInput | boolean
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutGameCharacterInput, BankAccountUpdateWithoutGameCharacterInput>, BankAccountUncheckedUpdateWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput = {
    create?: XOR<CharacterKnowledgeCreateWithoutGameCharacterInput, CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput> | CharacterKnowledgeCreateWithoutGameCharacterInput[] | CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput | CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput[]
    upsert?: CharacterKnowledgeUpsertWithWhereUniqueWithoutGameCharacterInput | CharacterKnowledgeUpsertWithWhereUniqueWithoutGameCharacterInput[]
    createMany?: CharacterKnowledgeCreateManyGameCharacterInputEnvelope
    set?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    disconnect?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    delete?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    connect?: CharacterKnowledgeWhereUniqueInput | CharacterKnowledgeWhereUniqueInput[]
    update?: CharacterKnowledgeUpdateWithWhereUniqueWithoutGameCharacterInput | CharacterKnowledgeUpdateWithWhereUniqueWithoutGameCharacterInput[]
    updateMany?: CharacterKnowledgeUpdateManyWithWhereWithoutGameCharacterInput | CharacterKnowledgeUpdateManyWithWhereWithoutGameCharacterInput[]
    deleteMany?: CharacterKnowledgeScalarWhereInput | CharacterKnowledgeScalarWhereInput[]
  }

  export type CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutGameCharacterInput, CharacterSkillUncheckedCreateWithoutGameCharacterInput> | CharacterSkillCreateWithoutGameCharacterInput[] | CharacterSkillUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutGameCharacterInput | CharacterSkillCreateOrConnectWithoutGameCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutGameCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutGameCharacterInput[]
    createMany?: CharacterSkillCreateManyGameCharacterInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutGameCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutGameCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutGameCharacterInput | CharacterSkillUpdateManyWithWhereWithoutGameCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput = {
    create?: XOR<JobChangeHistoryCreateWithoutGameCharactersInput, JobChangeHistoryUncheckedCreateWithoutGameCharactersInput> | JobChangeHistoryCreateWithoutGameCharactersInput[] | JobChangeHistoryUncheckedCreateWithoutGameCharactersInput[]
    connectOrCreate?: JobChangeHistoryCreateOrConnectWithoutGameCharactersInput | JobChangeHistoryCreateOrConnectWithoutGameCharactersInput[]
    upsert?: JobChangeHistoryUpsertWithWhereUniqueWithoutGameCharactersInput | JobChangeHistoryUpsertWithWhereUniqueWithoutGameCharactersInput[]
    createMany?: JobChangeHistoryCreateManyGameCharactersInputEnvelope
    set?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    disconnect?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    delete?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    connect?: JobChangeHistoryWhereUniqueInput | JobChangeHistoryWhereUniqueInput[]
    update?: JobChangeHistoryUpdateWithWhereUniqueWithoutGameCharactersInput | JobChangeHistoryUpdateWithWhereUniqueWithoutGameCharactersInput[]
    updateMany?: JobChangeHistoryUpdateManyWithWhereWithoutGameCharactersInput | JobChangeHistoryUpdateManyWithWhereWithoutGameCharactersInput[]
    deleteMany?: JobChangeHistoryScalarWhereInput | JobChangeHistoryScalarWhereInput[]
  }

  export type MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput = {
    create?: XOR<MagicalStorageCreateWithoutGameCharacterInput, MagicalStorageUncheckedCreateWithoutGameCharacterInput> | MagicalStorageCreateWithoutGameCharacterInput[] | MagicalStorageUncheckedCreateWithoutGameCharacterInput[]
    connectOrCreate?: MagicalStorageCreateOrConnectWithoutGameCharacterInput | MagicalStorageCreateOrConnectWithoutGameCharacterInput[]
    upsert?: MagicalStorageUpsertWithWhereUniqueWithoutGameCharacterInput | MagicalStorageUpsertWithWhereUniqueWithoutGameCharacterInput[]
    createMany?: MagicalStorageCreateManyGameCharacterInputEnvelope
    set?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    disconnect?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    delete?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    connect?: MagicalStorageWhereUniqueInput | MagicalStorageWhereUniqueInput[]
    update?: MagicalStorageUpdateWithWhereUniqueWithoutGameCharacterInput | MagicalStorageUpdateWithWhereUniqueWithoutGameCharacterInput[]
    updateMany?: MagicalStorageUpdateManyWithWhereWithoutGameCharacterInput | MagicalStorageUpdateManyWithWhereWithoutGameCharacterInput[]
    deleteMany?: MagicalStorageScalarWhereInput | MagicalStorageScalarWhereInput[]
  }

  export type PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput = {
    create?: XOR<PlayerInventoryCreateWithoutGame_charactersInput, PlayerInventoryUncheckedCreateWithoutGame_charactersInput> | PlayerInventoryCreateWithoutGame_charactersInput[] | PlayerInventoryUncheckedCreateWithoutGame_charactersInput[]
    connectOrCreate?: PlayerInventoryCreateOrConnectWithoutGame_charactersInput | PlayerInventoryCreateOrConnectWithoutGame_charactersInput[]
    upsert?: PlayerInventoryUpsertWithWhereUniqueWithoutGame_charactersInput | PlayerInventoryUpsertWithWhereUniqueWithoutGame_charactersInput[]
    createMany?: PlayerInventoryCreateManyGame_charactersInputEnvelope
    set?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    disconnect?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    delete?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    connect?: PlayerInventoryWhereUniqueInput | PlayerInventoryWhereUniqueInput[]
    update?: PlayerInventoryUpdateWithWhereUniqueWithoutGame_charactersInput | PlayerInventoryUpdateWithWhereUniqueWithoutGame_charactersInput[]
    updateMany?: PlayerInventoryUpdateManyWithWhereWithoutGame_charactersInput | PlayerInventoryUpdateManyWithWhereWithoutGame_charactersInput[]
    deleteMany?: PlayerInventoryScalarWhereInput | PlayerInventoryScalarWhereInput[]
  }

  export type GameCharacterCreateNestedOneWithoutJobChangeHistoryInput = {
    create?: XOR<GameCharacterCreateWithoutJobChangeHistoryInput, GameCharacterUncheckedCreateWithoutJobChangeHistoryInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutJobChangeHistoryInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type GameCharacterUpdateOneRequiredWithoutJobChangeHistoryNestedInput = {
    create?: XOR<GameCharacterCreateWithoutJobChangeHistoryInput, GameCharacterUncheckedCreateWithoutJobChangeHistoryInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutJobChangeHistoryInput
    upsert?: GameCharacterUpsertWithoutJobChangeHistoryInput
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutJobChangeHistoryInput, GameCharacterUpdateWithoutJobChangeHistoryInput>, GameCharacterUncheckedUpdateWithoutJobChangeHistoryInput>
  }

  export type LoanCreateNestedOneWithoutLoanPaymentsInput = {
    create?: XOR<LoanCreateWithoutLoanPaymentsInput, LoanUncheckedCreateWithoutLoanPaymentsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutLoanPaymentsInput
    connect?: LoanWhereUniqueInput
  }

  export type LoanUpdateOneRequiredWithoutLoanPaymentsNestedInput = {
    create?: XOR<LoanCreateWithoutLoanPaymentsInput, LoanUncheckedCreateWithoutLoanPaymentsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutLoanPaymentsInput
    upsert?: LoanUpsertWithoutLoanPaymentsInput
    connect?: LoanWhereUniqueInput
    update?: XOR<XOR<LoanUpdateToOneWithWhereWithoutLoanPaymentsInput, LoanUpdateWithoutLoanPaymentsInput>, LoanUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type LoanPaymentCreateNestedManyWithoutLoansInput = {
    create?: XOR<LoanPaymentCreateWithoutLoansInput, LoanPaymentUncheckedCreateWithoutLoansInput> | LoanPaymentCreateWithoutLoansInput[] | LoanPaymentUncheckedCreateWithoutLoansInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoansInput | LoanPaymentCreateOrConnectWithoutLoansInput[]
    createMany?: LoanPaymentCreateManyLoansInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type BankAccountCreateNestedOneWithoutLoansInput = {
    create?: XOR<BankAccountCreateWithoutLoansInput, BankAccountUncheckedCreateWithoutLoansInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutLoansInput
    connect?: BankAccountWhereUniqueInput
  }

  export type LoanPaymentUncheckedCreateNestedManyWithoutLoansInput = {
    create?: XOR<LoanPaymentCreateWithoutLoansInput, LoanPaymentUncheckedCreateWithoutLoansInput> | LoanPaymentCreateWithoutLoansInput[] | LoanPaymentUncheckedCreateWithoutLoansInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoansInput | LoanPaymentCreateOrConnectWithoutLoansInput[]
    createMany?: LoanPaymentCreateManyLoansInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type LoanPaymentUpdateManyWithoutLoansNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutLoansInput, LoanPaymentUncheckedCreateWithoutLoansInput> | LoanPaymentCreateWithoutLoansInput[] | LoanPaymentUncheckedCreateWithoutLoansInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoansInput | LoanPaymentCreateOrConnectWithoutLoansInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutLoansInput | LoanPaymentUpsertWithWhereUniqueWithoutLoansInput[]
    createMany?: LoanPaymentCreateManyLoansInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutLoansInput | LoanPaymentUpdateWithWhereUniqueWithoutLoansInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutLoansInput | LoanPaymentUpdateManyWithWhereWithoutLoansInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type BankAccountUpdateOneRequiredWithoutLoansNestedInput = {
    create?: XOR<BankAccountCreateWithoutLoansInput, BankAccountUncheckedCreateWithoutLoansInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutLoansInput
    upsert?: BankAccountUpsertWithoutLoansInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutLoansInput, BankAccountUpdateWithoutLoansInput>, BankAccountUncheckedUpdateWithoutLoansInput>
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoansNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutLoansInput, LoanPaymentUncheckedCreateWithoutLoansInput> | LoanPaymentCreateWithoutLoansInput[] | LoanPaymentUncheckedCreateWithoutLoansInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoansInput | LoanPaymentCreateOrConnectWithoutLoansInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutLoansInput | LoanPaymentUpsertWithWhereUniqueWithoutLoansInput[]
    createMany?: LoanPaymentCreateManyLoansInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutLoansInput | LoanPaymentUpdateWithWhereUniqueWithoutLoansInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutLoansInput | LoanPaymentUpdateManyWithWhereWithoutLoansInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type GameCharacterCreateNestedOneWithoutMagicalStorageInput = {
    create?: XOR<GameCharacterCreateWithoutMagicalStorageInput, GameCharacterUncheckedCreateWithoutMagicalStorageInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutMagicalStorageInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type GameCharacterUpdateOneRequiredWithoutMagicalStorageNestedInput = {
    create?: XOR<GameCharacterCreateWithoutMagicalStorageInput, GameCharacterUncheckedCreateWithoutMagicalStorageInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutMagicalStorageInput
    upsert?: GameCharacterUpsertWithoutMagicalStorageInput
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutMagicalStorageInput, GameCharacterUpdateWithoutMagicalStorageInput>, GameCharacterUncheckedUpdateWithoutMagicalStorageInput>
  }

  export type GameCharacterCreateNestedOneWithoutPlayerInventoriesInput = {
    create?: XOR<GameCharacterCreateWithoutPlayerInventoriesInput, GameCharacterUncheckedCreateWithoutPlayerInventoriesInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutPlayerInventoriesInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type GameCharacterUpdateOneRequiredWithoutPlayerInventoriesNestedInput = {
    create?: XOR<GameCharacterCreateWithoutPlayerInventoriesInput, GameCharacterUncheckedCreateWithoutPlayerInventoriesInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutPlayerInventoriesInput
    upsert?: GameCharacterUpsertWithoutPlayerInventoriesInput
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutPlayerInventoriesInput, GameCharacterUpdateWithoutPlayerInventoriesInput>, GameCharacterUncheckedUpdateWithoutPlayerInventoriesInput>
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type CharacterSkillCreateNestedOneWithoutSkillPracticeHistoryInput = {
    create?: XOR<CharacterSkillCreateWithoutSkillPracticeHistoryInput, CharacterSkillUncheckedCreateWithoutSkillPracticeHistoryInput>
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutSkillPracticeHistoryInput
    connect?: CharacterSkillWhereUniqueInput
  }

  export type CharacterSkillUpdateOneRequiredWithoutSkillPracticeHistoryNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutSkillPracticeHistoryInput, CharacterSkillUncheckedCreateWithoutSkillPracticeHistoryInput>
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutSkillPracticeHistoryInput
    upsert?: CharacterSkillUpsertWithoutSkillPracticeHistoryInput
    connect?: CharacterSkillWhereUniqueInput
    update?: XOR<XOR<CharacterSkillUpdateToOneWithWhereWithoutSkillPracticeHistoryInput, CharacterSkillUpdateWithoutSkillPracticeHistoryInput>, CharacterSkillUncheckedUpdateWithoutSkillPracticeHistoryInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type GameCharacterCreateNestedOneWithoutUserInput = {
    create?: XOR<GameCharacterCreateWithoutUserInput, GameCharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutUserInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserEmailCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type UserPresenceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    connect?: UserPresenceWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type GameCharacterUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GameCharacterCreateWithoutUserInput, GameCharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutUserInput
    connect?: GameCharacterWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserEmailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type UserPresenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    connect?: UserPresenceWhereUniqueInput
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type GameCharacterUpdateOneWithoutUserNestedInput = {
    create?: XOR<GameCharacterCreateWithoutUserInput, GameCharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutUserInput
    upsert?: GameCharacterUpsertWithoutUserInput
    disconnect?: GameCharacterWhereInput | boolean
    delete?: GameCharacterWhereInput | boolean
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutUserInput, GameCharacterUpdateWithoutUserInput>, GameCharacterUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserEmailUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    upsert?: UserEmailUpsertWithWhereUniqueWithoutUserInput | UserEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    set?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    disconnect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    delete?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    update?: UserEmailUpdateWithWhereUniqueWithoutUserInput | UserEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEmailUpdateManyWithWhereWithoutUserInput | UserEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserPresenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    upsert?: UserPresenceUpsertWithoutUserInput
    disconnect?: UserPresenceWhereInput | boolean
    delete?: UserPresenceWhereInput | boolean
    connect?: UserPresenceWhereUniqueInput
    update?: XOR<XOR<UserPresenceUpdateToOneWithWhereWithoutUserInput, UserPresenceUpdateWithoutUserInput>, UserPresenceUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type GameCharacterUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GameCharacterCreateWithoutUserInput, GameCharacterUncheckedCreateWithoutUserInput>
    connectOrCreate?: GameCharacterCreateOrConnectWithoutUserInput
    upsert?: GameCharacterUpsertWithoutUserInput
    disconnect?: GameCharacterWhereInput | boolean
    delete?: GameCharacterWhereInput | boolean
    connect?: GameCharacterWhereUniqueInput
    update?: XOR<XOR<GameCharacterUpdateToOneWithWhereWithoutUserInput, GameCharacterUpdateWithoutUserInput>, GameCharacterUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserEmailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput> | UserEmailCreateWithoutUserInput[] | UserEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserEmailCreateOrConnectWithoutUserInput | UserEmailCreateOrConnectWithoutUserInput[]
    upsert?: UserEmailUpsertWithWhereUniqueWithoutUserInput | UserEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserEmailCreateManyUserInputEnvelope
    set?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    disconnect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    delete?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    connect?: UserEmailWhereUniqueInput | UserEmailWhereUniqueInput[]
    update?: UserEmailUpdateWithWhereUniqueWithoutUserInput | UserEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserEmailUpdateManyWithWhereWithoutUserInput | UserEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserPresenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    upsert?: UserPresenceUpsertWithoutUserInput
    disconnect?: UserPresenceWhereInput | boolean
    delete?: UserPresenceWhereInput | boolean
    connect?: UserPresenceWhereUniqueInput
    update?: XOR<XOR<UserPresenceUpdateToOneWithWhereWithoutUserInput, UserPresenceUpdateWithoutUserInput>, UserPresenceUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserEmailsInput = {
    create?: XOR<UserCreateWithoutUserEmailsInput, UserUncheckedCreateWithoutUserEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEmailsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserEmailsNestedInput = {
    create?: XOR<UserCreateWithoutUserEmailsInput, UserUncheckedCreateWithoutUserEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEmailsInput
    upsert?: UserUpsertWithoutUserEmailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserEmailsInput, UserUpdateWithoutUserEmailsInput>, UserUncheckedUpdateWithoutUserEmailsInput>
  }

  export type UserCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    upsert?: UserUpsertWithoutUserProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProfileInput, UserUpdateWithoutUserProfileInput>, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserSettingsCreatepinnedForumsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserSettingsUpdatepinnedForumsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    upsert?: UserUpsertWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsInput, UserUpdateWithoutUserSettingsInput>, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserCreateNestedOneWithoutUserPresenceInput = {
    create?: XOR<UserCreateWithoutUserPresenceInput, UserUncheckedCreateWithoutUserPresenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPresenceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPresenceNestedInput = {
    create?: XOR<UserCreateWithoutUserPresenceInput, UserUncheckedCreateWithoutUserPresenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPresenceInput
    upsert?: UserUpsertWithoutUserPresenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPresenceInput, UserUpdateWithoutUserPresenceInput>, UserUncheckedUpdateWithoutUserPresenceInput>
  }

  export type EnumFriendRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendRequestStatus
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput> | LikeCreateWithoutPostInput[] | LikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostInput | LikeCreateOrConnectWithoutPostInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostInput | LikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeCreateManyPostInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostInput | LikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostInput | LikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutLikesInput
    upsert?: PostUpsertWithoutLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutLikesInput, PostUpdateWithoutLikesInput>, PostUncheckedUpdateWithoutLikesInput>
  }

  export type ForumTopicCreatetagsInput = {
    set: string[]
  }

  export type ForumReplyCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumTopicLikeCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumTopicLikeCreateWithoutTopicInput, ForumTopicLikeUncheckedCreateWithoutTopicInput> | ForumTopicLikeCreateWithoutTopicInput[] | ForumTopicLikeUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumTopicLikeCreateOrConnectWithoutTopicInput | ForumTopicLikeCreateOrConnectWithoutTopicInput[]
    createMany?: ForumTopicLikeCreateManyTopicInputEnvelope
    connect?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
  }

  export type ForumReplyUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumTopicLikeUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumTopicLikeCreateWithoutTopicInput, ForumTopicLikeUncheckedCreateWithoutTopicInput> | ForumTopicLikeCreateWithoutTopicInput[] | ForumTopicLikeUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumTopicLikeCreateOrConnectWithoutTopicInput | ForumTopicLikeCreateOrConnectWithoutTopicInput[]
    createMany?: ForumTopicLikeCreateManyTopicInputEnvelope
    connect?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
  }

  export type EnumForumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ForumCategory
  }

  export type EnumTopicTypeFieldUpdateOperationsInput = {
    set?: $Enums.TopicType
  }

  export type ForumTopicUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ForumReplyUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutTopicInput | ForumReplyUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutTopicInput | ForumReplyUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutTopicInput | ForumReplyUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumTopicLikeUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumTopicLikeCreateWithoutTopicInput, ForumTopicLikeUncheckedCreateWithoutTopicInput> | ForumTopicLikeCreateWithoutTopicInput[] | ForumTopicLikeUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumTopicLikeCreateOrConnectWithoutTopicInput | ForumTopicLikeCreateOrConnectWithoutTopicInput[]
    upsert?: ForumTopicLikeUpsertWithWhereUniqueWithoutTopicInput | ForumTopicLikeUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumTopicLikeCreateManyTopicInputEnvelope
    set?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    disconnect?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    delete?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    connect?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    update?: ForumTopicLikeUpdateWithWhereUniqueWithoutTopicInput | ForumTopicLikeUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumTopicLikeUpdateManyWithWhereWithoutTopicInput | ForumTopicLikeUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumTopicLikeScalarWhereInput | ForumTopicLikeScalarWhereInput[]
  }

  export type ForumReplyUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutTopicInput | ForumReplyUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutTopicInput | ForumReplyUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutTopicInput | ForumReplyUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumTopicLikeUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumTopicLikeCreateWithoutTopicInput, ForumTopicLikeUncheckedCreateWithoutTopicInput> | ForumTopicLikeCreateWithoutTopicInput[] | ForumTopicLikeUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumTopicLikeCreateOrConnectWithoutTopicInput | ForumTopicLikeCreateOrConnectWithoutTopicInput[]
    upsert?: ForumTopicLikeUpsertWithWhereUniqueWithoutTopicInput | ForumTopicLikeUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumTopicLikeCreateManyTopicInputEnvelope
    set?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    disconnect?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    delete?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    connect?: ForumTopicLikeWhereUniqueInput | ForumTopicLikeWhereUniqueInput[]
    update?: ForumTopicLikeUpdateWithWhereUniqueWithoutTopicInput | ForumTopicLikeUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumTopicLikeUpdateManyWithWhereWithoutTopicInput | ForumTopicLikeUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumTopicLikeScalarWhereInput | ForumTopicLikeScalarWhereInput[]
  }

  export type ForumTopicCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutRepliesInput
    connect?: ForumTopicWhereUniqueInput
  }

  export type ForumReplyLikeCreateNestedManyWithoutReplyInput = {
    create?: XOR<ForumReplyLikeCreateWithoutReplyInput, ForumReplyLikeUncheckedCreateWithoutReplyInput> | ForumReplyLikeCreateWithoutReplyInput[] | ForumReplyLikeUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ForumReplyLikeCreateOrConnectWithoutReplyInput | ForumReplyLikeCreateOrConnectWithoutReplyInput[]
    createMany?: ForumReplyLikeCreateManyReplyInputEnvelope
    connect?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
  }

  export type ForumReplyLikeUncheckedCreateNestedManyWithoutReplyInput = {
    create?: XOR<ForumReplyLikeCreateWithoutReplyInput, ForumReplyLikeUncheckedCreateWithoutReplyInput> | ForumReplyLikeCreateWithoutReplyInput[] | ForumReplyLikeUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ForumReplyLikeCreateOrConnectWithoutReplyInput | ForumReplyLikeCreateOrConnectWithoutReplyInput[]
    createMany?: ForumReplyLikeCreateManyReplyInputEnvelope
    connect?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
  }

  export type ForumTopicUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutRepliesInput
    upsert?: ForumTopicUpsertWithoutRepliesInput
    connect?: ForumTopicWhereUniqueInput
    update?: XOR<XOR<ForumTopicUpdateToOneWithWhereWithoutRepliesInput, ForumTopicUpdateWithoutRepliesInput>, ForumTopicUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumReplyLikeUpdateManyWithoutReplyNestedInput = {
    create?: XOR<ForumReplyLikeCreateWithoutReplyInput, ForumReplyLikeUncheckedCreateWithoutReplyInput> | ForumReplyLikeCreateWithoutReplyInput[] | ForumReplyLikeUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ForumReplyLikeCreateOrConnectWithoutReplyInput | ForumReplyLikeCreateOrConnectWithoutReplyInput[]
    upsert?: ForumReplyLikeUpsertWithWhereUniqueWithoutReplyInput | ForumReplyLikeUpsertWithWhereUniqueWithoutReplyInput[]
    createMany?: ForumReplyLikeCreateManyReplyInputEnvelope
    set?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    disconnect?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    delete?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    connect?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    update?: ForumReplyLikeUpdateWithWhereUniqueWithoutReplyInput | ForumReplyLikeUpdateWithWhereUniqueWithoutReplyInput[]
    updateMany?: ForumReplyLikeUpdateManyWithWhereWithoutReplyInput | ForumReplyLikeUpdateManyWithWhereWithoutReplyInput[]
    deleteMany?: ForumReplyLikeScalarWhereInput | ForumReplyLikeScalarWhereInput[]
  }

  export type ForumReplyLikeUncheckedUpdateManyWithoutReplyNestedInput = {
    create?: XOR<ForumReplyLikeCreateWithoutReplyInput, ForumReplyLikeUncheckedCreateWithoutReplyInput> | ForumReplyLikeCreateWithoutReplyInput[] | ForumReplyLikeUncheckedCreateWithoutReplyInput[]
    connectOrCreate?: ForumReplyLikeCreateOrConnectWithoutReplyInput | ForumReplyLikeCreateOrConnectWithoutReplyInput[]
    upsert?: ForumReplyLikeUpsertWithWhereUniqueWithoutReplyInput | ForumReplyLikeUpsertWithWhereUniqueWithoutReplyInput[]
    createMany?: ForumReplyLikeCreateManyReplyInputEnvelope
    set?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    disconnect?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    delete?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    connect?: ForumReplyLikeWhereUniqueInput | ForumReplyLikeWhereUniqueInput[]
    update?: ForumReplyLikeUpdateWithWhereUniqueWithoutReplyInput | ForumReplyLikeUpdateWithWhereUniqueWithoutReplyInput[]
    updateMany?: ForumReplyLikeUpdateManyWithWhereWithoutReplyInput | ForumReplyLikeUpdateManyWithWhereWithoutReplyInput[]
    deleteMany?: ForumReplyLikeScalarWhereInput | ForumReplyLikeScalarWhereInput[]
  }

  export type ForumTopicCreateNestedOneWithoutLikesInput = {
    create?: XOR<ForumTopicCreateWithoutLikesInput, ForumTopicUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutLikesInput
    connect?: ForumTopicWhereUniqueInput
  }

  export type ForumTopicUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<ForumTopicCreateWithoutLikesInput, ForumTopicUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutLikesInput
    upsert?: ForumTopicUpsertWithoutLikesInput
    connect?: ForumTopicWhereUniqueInput
    update?: XOR<XOR<ForumTopicUpdateToOneWithWhereWithoutLikesInput, ForumTopicUpdateWithoutLikesInput>, ForumTopicUncheckedUpdateWithoutLikesInput>
  }

  export type ForumReplyCreateNestedOneWithoutLikesInput = {
    create?: XOR<ForumReplyCreateWithoutLikesInput, ForumReplyUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ForumReplyCreateOrConnectWithoutLikesInput
    connect?: ForumReplyWhereUniqueInput
  }

  export type ForumReplyUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<ForumReplyCreateWithoutLikesInput, ForumReplyUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ForumReplyCreateOrConnectWithoutLikesInput
    upsert?: ForumReplyUpsertWithoutLikesInput
    connect?: ForumReplyWhereUniqueInput
    update?: XOR<XOR<ForumReplyUpdateToOneWithWhereWithoutLikesInput, ForumReplyUpdateWithoutLikesInput>, ForumReplyUncheckedUpdateWithoutLikesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumFriendRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusFilter<$PrismaModel> | $Enums.FriendRequestStatus
  }

  export type NestedEnumFriendRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumForumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumCategory | EnumForumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumForumCategoryFilter<$PrismaModel> | $Enums.ForumCategory
  }

  export type NestedEnumTopicTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeFilter<$PrismaModel> | $Enums.TopicType
  }

  export type NestedEnumForumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumCategory | EnumForumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumCategory[] | ListEnumForumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumForumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ForumCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForumCategoryFilter<$PrismaModel>
    _max?: NestedEnumForumCategoryFilter<$PrismaModel>
  }

  export type NestedEnumTopicTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeWithAggregatesFilter<$PrismaModel> | $Enums.TopicType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicTypeFilter<$PrismaModel>
    _max?: NestedEnumTopicTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GameCharacterCreateWithoutBankAccountsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateWithoutBankAccountsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterCreateOrConnectWithoutBankAccountsInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutBankAccountsInput, GameCharacterUncheckedCreateWithoutBankAccountsInput>
  }

  export type BankTransactionCreateWithoutBankAccountInput = {
    id?: string
    transactionType: string
    amount: number
    balanceAfter: number
    description?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUncheckedCreateWithoutBankAccountInput = {
    id?: string
    transactionType: string
    amount: number
    balanceAfter: number
    description?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput>
  }

  export type BankTransactionCreateManyBankAccountInputEnvelope = {
    data: BankTransactionCreateManyBankAccountInput | BankTransactionCreateManyBankAccountInput[]
    skipDuplicates?: boolean
  }

  export type LoanCreateWithoutBankAccountsInput = {
    id?: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanPayments?: LoanPaymentCreateNestedManyWithoutLoansInput
  }

  export type LoanUncheckedCreateWithoutBankAccountsInput = {
    id?: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loanPayments?: LoanPaymentUncheckedCreateNestedManyWithoutLoansInput
  }

  export type LoanCreateOrConnectWithoutBankAccountsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutBankAccountsInput, LoanUncheckedCreateWithoutBankAccountsInput>
  }

  export type LoanCreateManyBankAccountsInputEnvelope = {
    data: LoanCreateManyBankAccountsInput | LoanCreateManyBankAccountsInput[]
    skipDuplicates?: boolean
  }

  export type GameCharacterUpsertWithoutBankAccountsInput = {
    update: XOR<GameCharacterUpdateWithoutBankAccountsInput, GameCharacterUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<GameCharacterCreateWithoutBankAccountsInput, GameCharacterUncheckedCreateWithoutBankAccountsInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutBankAccountsInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutBankAccountsInput, GameCharacterUncheckedUpdateWithoutBankAccountsInput>
  }

  export type GameCharacterUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutBankAccountInput, BankTransactionUncheckedUpdateWithoutBankAccountInput>
    create: XOR<BankTransactionCreateWithoutBankAccountInput, BankTransactionUncheckedCreateWithoutBankAccountInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutBankAccountInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutBankAccountInput, BankTransactionUncheckedUpdateWithoutBankAccountInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutBankAccountInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutBankAccountInput>
  }

  export type BankTransactionScalarWhereInput = {
    AND?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    OR?: BankTransactionScalarWhereInput[]
    NOT?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    id?: StringFilter<"BankTransaction"> | string
    bankAccountId?: StringFilter<"BankTransaction"> | string
    transactionType?: StringFilter<"BankTransaction"> | string
    amount?: FloatFilter<"BankTransaction"> | number
    balanceAfter?: FloatFilter<"BankTransaction"> | number
    description?: StringNullableFilter<"BankTransaction"> | string | null
    timestamp?: DateTimeFilter<"BankTransaction"> | Date | string
    createdAt?: DateTimeFilter<"BankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BankTransaction"> | Date | string
  }

  export type LoanUpsertWithWhereUniqueWithoutBankAccountsInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutBankAccountsInput, LoanUncheckedUpdateWithoutBankAccountsInput>
    create: XOR<LoanCreateWithoutBankAccountsInput, LoanUncheckedCreateWithoutBankAccountsInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutBankAccountsInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutBankAccountsInput, LoanUncheckedUpdateWithoutBankAccountsInput>
  }

  export type LoanUpdateManyWithWhereWithoutBankAccountsInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutBankAccountsInput>
  }

  export type LoanScalarWhereInput = {
    AND?: LoanScalarWhereInput | LoanScalarWhereInput[]
    OR?: LoanScalarWhereInput[]
    NOT?: LoanScalarWhereInput | LoanScalarWhereInput[]
    id?: StringFilter<"Loan"> | string
    bankAccountId?: StringFilter<"Loan"> | string
    principalAmount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    termMonths?: IntFilter<"Loan"> | number
    monthlyPayment?: FloatFilter<"Loan"> | number
    remainingBalance?: FloatFilter<"Loan"> | number
    status?: StringFilter<"Loan"> | string
    loanPurpose?: StringFilter<"Loan"> | string
    nextPaymentDue?: DateTimeNullableFilter<"Loan"> | Date | string | null
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
  }

  export type BankAccountCreateWithoutBankTransactionsInput = {
    id?: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutBankAccountsInput
    loans?: LoanCreateNestedManyWithoutBankAccountsInput
  }

  export type BankAccountUncheckedCreateWithoutBankTransactionsInput = {
    id?: string
    characterId: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    loans?: LoanUncheckedCreateNestedManyWithoutBankAccountsInput
  }

  export type BankAccountCreateOrConnectWithoutBankTransactionsInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutBankTransactionsInput, BankAccountUncheckedCreateWithoutBankTransactionsInput>
  }

  export type BankAccountUpsertWithoutBankTransactionsInput = {
    update: XOR<BankAccountUpdateWithoutBankTransactionsInput, BankAccountUncheckedUpdateWithoutBankTransactionsInput>
    create: XOR<BankAccountCreateWithoutBankTransactionsInput, BankAccountUncheckedCreateWithoutBankTransactionsInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutBankTransactionsInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutBankTransactionsInput, BankAccountUncheckedUpdateWithoutBankTransactionsInput>
  }

  export type BankAccountUpdateWithoutBankTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutBankAccountsNestedInput
    loans?: LoanUpdateManyWithoutBankAccountsNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutBankTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loans?: LoanUncheckedUpdateManyWithoutBankAccountsNestedInput
  }

  export type GameCharacterCreateWithoutCharacterKnowledgesInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateWithoutCharacterKnowledgesInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterCreateOrConnectWithoutCharacterKnowledgesInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutCharacterKnowledgesInput, GameCharacterUncheckedCreateWithoutCharacterKnowledgesInput>
  }

  export type GameCharacterUpsertWithoutCharacterKnowledgesInput = {
    update: XOR<GameCharacterUpdateWithoutCharacterKnowledgesInput, GameCharacterUncheckedUpdateWithoutCharacterKnowledgesInput>
    create: XOR<GameCharacterCreateWithoutCharacterKnowledgesInput, GameCharacterUncheckedCreateWithoutCharacterKnowledgesInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutCharacterKnowledgesInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutCharacterKnowledgesInput, GameCharacterUncheckedUpdateWithoutCharacterKnowledgesInput>
  }

  export type GameCharacterUpdateWithoutCharacterKnowledgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutCharacterKnowledgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterCreateWithoutCharacterSkillsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateWithoutCharacterSkillsInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterCreateOrConnectWithoutCharacterSkillsInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutCharacterSkillsInput, GameCharacterUncheckedCreateWithoutCharacterSkillsInput>
  }

  export type SkillPracticeHistoryCreateWithoutCharacter_skillsInput = {
    id?: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput = {
    id?: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillPracticeHistoryCreateOrConnectWithoutCharacter_skillsInput = {
    where: SkillPracticeHistoryWhereUniqueInput
    create: XOR<SkillPracticeHistoryCreateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput>
  }

  export type SkillPracticeHistoryCreateManyCharacter_skillsInputEnvelope = {
    data: SkillPracticeHistoryCreateManyCharacter_skillsInput | SkillPracticeHistoryCreateManyCharacter_skillsInput[]
    skipDuplicates?: boolean
  }

  export type GameCharacterUpsertWithoutCharacterSkillsInput = {
    update: XOR<GameCharacterUpdateWithoutCharacterSkillsInput, GameCharacterUncheckedUpdateWithoutCharacterSkillsInput>
    create: XOR<GameCharacterCreateWithoutCharacterSkillsInput, GameCharacterUncheckedCreateWithoutCharacterSkillsInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutCharacterSkillsInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutCharacterSkillsInput, GameCharacterUncheckedUpdateWithoutCharacterSkillsInput>
  }

  export type GameCharacterUpdateWithoutCharacterSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutCharacterSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type SkillPracticeHistoryUpsertWithWhereUniqueWithoutCharacter_skillsInput = {
    where: SkillPracticeHistoryWhereUniqueInput
    update: XOR<SkillPracticeHistoryUpdateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedUpdateWithoutCharacter_skillsInput>
    create: XOR<SkillPracticeHistoryCreateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedCreateWithoutCharacter_skillsInput>
  }

  export type SkillPracticeHistoryUpdateWithWhereUniqueWithoutCharacter_skillsInput = {
    where: SkillPracticeHistoryWhereUniqueInput
    data: XOR<SkillPracticeHistoryUpdateWithoutCharacter_skillsInput, SkillPracticeHistoryUncheckedUpdateWithoutCharacter_skillsInput>
  }

  export type SkillPracticeHistoryUpdateManyWithWhereWithoutCharacter_skillsInput = {
    where: SkillPracticeHistoryScalarWhereInput
    data: XOR<SkillPracticeHistoryUpdateManyMutationInput, SkillPracticeHistoryUncheckedUpdateManyWithoutCharacter_skillsInput>
  }

  export type SkillPracticeHistoryScalarWhereInput = {
    AND?: SkillPracticeHistoryScalarWhereInput | SkillPracticeHistoryScalarWhereInput[]
    OR?: SkillPracticeHistoryScalarWhereInput[]
    NOT?: SkillPracticeHistoryScalarWhereInput | SkillPracticeHistoryScalarWhereInput[]
    id?: StringFilter<"SkillPracticeHistory"> | string
    skill_id?: StringFilter<"SkillPracticeHistory"> | string
    practice_type?: StringFilter<"SkillPracticeHistory"> | string
    practice_intensity?: StringFilter<"SkillPracticeHistory"> | string
    experience_gained?: IntFilter<"SkillPracticeHistory"> | number
    proficiency_gained?: IntFilter<"SkillPracticeHistory"> | number
    knowledge_used?: StringNullableFilter<"SkillPracticeHistory"> | string | null
    timestamp?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    created_at?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
    updated_at?: DateTimeFilter<"SkillPracticeHistory"> | Date | string
  }

  export type BankAccountCreateWithoutGameCharacterInput = {
    id?: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransactions?: BankTransactionCreateNestedManyWithoutBankAccountInput
    loans?: LoanCreateNestedManyWithoutBankAccountsInput
  }

  export type BankAccountUncheckedCreateWithoutGameCharacterInput = {
    id?: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput
    loans?: LoanUncheckedCreateNestedManyWithoutBankAccountsInput
  }

  export type BankAccountCreateOrConnectWithoutGameCharacterInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutGameCharacterInput, BankAccountUncheckedCreateWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeCreateWithoutGameCharacterInput = {
    id?: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description?: string | null
    proficiency?: number
    learnedAt?: Date | string
    teacherNpcId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput = {
    id?: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description?: string | null
    proficiency?: number
    learnedAt?: Date | string
    teacherNpcId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterKnowledgeCreateOrConnectWithoutGameCharacterInput = {
    where: CharacterKnowledgeWhereUniqueInput
    create: XOR<CharacterKnowledgeCreateWithoutGameCharacterInput, CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeCreateManyGameCharacterInputEnvelope = {
    data: CharacterKnowledgeCreateManyGameCharacterInput | CharacterKnowledgeCreateManyGameCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterSkillCreateWithoutGameCharacterInput = {
    id?: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skillPracticeHistory?: SkillPracticeHistoryCreateNestedManyWithoutCharacter_skillsInput
  }

  export type CharacterSkillUncheckedCreateWithoutGameCharacterInput = {
    id?: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    skillPracticeHistory?: SkillPracticeHistoryUncheckedCreateNestedManyWithoutCharacter_skillsInput
  }

  export type CharacterSkillCreateOrConnectWithoutGameCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    create: XOR<CharacterSkillCreateWithoutGameCharacterInput, CharacterSkillUncheckedCreateWithoutGameCharacterInput>
  }

  export type CharacterSkillCreateManyGameCharacterInputEnvelope = {
    data: CharacterSkillCreateManyGameCharacterInput | CharacterSkillCreateManyGameCharacterInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutGameCharactersInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGameCharactersInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGameCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameCharactersInput, UserUncheckedCreateWithoutGameCharactersInput>
  }

  export type JobChangeHistoryCreateWithoutGameCharactersInput = {
    id?: string
    fromClass: string
    toClass: string
    changedAt?: Date | string
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobChangeHistoryUncheckedCreateWithoutGameCharactersInput = {
    id?: string
    fromClass: string
    toClass: string
    changedAt?: Date | string
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobChangeHistoryCreateOrConnectWithoutGameCharactersInput = {
    where: JobChangeHistoryWhereUniqueInput
    create: XOR<JobChangeHistoryCreateWithoutGameCharactersInput, JobChangeHistoryUncheckedCreateWithoutGameCharactersInput>
  }

  export type JobChangeHistoryCreateManyGameCharactersInputEnvelope = {
    data: JobChangeHistoryCreateManyGameCharactersInput | JobChangeHistoryCreateManyGameCharactersInput[]
    skipDuplicates?: boolean
  }

  export type MagicalStorageCreateWithoutGameCharacterInput = {
    id?: string
    itemId: string
    quantity?: number
    quality?: string
    manaUsed: number
    storedAt?: Date | string
    lastAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicalStorageUncheckedCreateWithoutGameCharacterInput = {
    id?: string
    itemId: string
    quantity?: number
    quality?: string
    manaUsed: number
    storedAt?: Date | string
    lastAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicalStorageCreateOrConnectWithoutGameCharacterInput = {
    where: MagicalStorageWhereUniqueInput
    create: XOR<MagicalStorageCreateWithoutGameCharacterInput, MagicalStorageUncheckedCreateWithoutGameCharacterInput>
  }

  export type MagicalStorageCreateManyGameCharacterInputEnvelope = {
    data: MagicalStorageCreateManyGameCharacterInput | MagicalStorageCreateManyGameCharacterInput[]
    skipDuplicates?: boolean
  }

  export type PlayerInventoryCreateWithoutGame_charactersInput = {
    id?: string
    item_id: string
    quantity?: number
    quality?: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot?: number | null
    is_equipped?: boolean
    equipment_slot?: string | null
    condition?: number
    is_stackable?: boolean
    max_stack?: number
    acquired_at?: Date | string
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlayerInventoryUncheckedCreateWithoutGame_charactersInput = {
    id?: string
    item_id: string
    quantity?: number
    quality?: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot?: number | null
    is_equipped?: boolean
    equipment_slot?: string | null
    condition?: number
    is_stackable?: boolean
    max_stack?: number
    acquired_at?: Date | string
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlayerInventoryCreateOrConnectWithoutGame_charactersInput = {
    where: PlayerInventoryWhereUniqueInput
    create: XOR<PlayerInventoryCreateWithoutGame_charactersInput, PlayerInventoryUncheckedCreateWithoutGame_charactersInput>
  }

  export type PlayerInventoryCreateManyGame_charactersInputEnvelope = {
    data: PlayerInventoryCreateManyGame_charactersInput | PlayerInventoryCreateManyGame_charactersInput[]
    skipDuplicates?: boolean
  }

  export type BankAccountUpsertWithoutGameCharacterInput = {
    update: XOR<BankAccountUpdateWithoutGameCharacterInput, BankAccountUncheckedUpdateWithoutGameCharacterInput>
    create: XOR<BankAccountCreateWithoutGameCharacterInput, BankAccountUncheckedCreateWithoutGameCharacterInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutGameCharacterInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutGameCharacterInput, BankAccountUncheckedUpdateWithoutGameCharacterInput>
  }

  export type BankAccountUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransactions?: BankTransactionUpdateManyWithoutBankAccountNestedInput
    loans?: LoanUpdateManyWithoutBankAccountsNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput
    loans?: LoanUncheckedUpdateManyWithoutBankAccountsNestedInput
  }

  export type CharacterKnowledgeUpsertWithWhereUniqueWithoutGameCharacterInput = {
    where: CharacterKnowledgeWhereUniqueInput
    update: XOR<CharacterKnowledgeUpdateWithoutGameCharacterInput, CharacterKnowledgeUncheckedUpdateWithoutGameCharacterInput>
    create: XOR<CharacterKnowledgeCreateWithoutGameCharacterInput, CharacterKnowledgeUncheckedCreateWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeUpdateWithWhereUniqueWithoutGameCharacterInput = {
    where: CharacterKnowledgeWhereUniqueInput
    data: XOR<CharacterKnowledgeUpdateWithoutGameCharacterInput, CharacterKnowledgeUncheckedUpdateWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeUpdateManyWithWhereWithoutGameCharacterInput = {
    where: CharacterKnowledgeScalarWhereInput
    data: XOR<CharacterKnowledgeUpdateManyMutationInput, CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterInput>
  }

  export type CharacterKnowledgeScalarWhereInput = {
    AND?: CharacterKnowledgeScalarWhereInput | CharacterKnowledgeScalarWhereInput[]
    OR?: CharacterKnowledgeScalarWhereInput[]
    NOT?: CharacterKnowledgeScalarWhereInput | CharacterKnowledgeScalarWhereInput[]
    id?: StringFilter<"CharacterKnowledge"> | string
    characterId?: StringFilter<"CharacterKnowledge"> | string
    skillType?: StringFilter<"CharacterKnowledge"> | string
    knowledgeType?: StringFilter<"CharacterKnowledge"> | string
    knowledgeName?: StringFilter<"CharacterKnowledge"> | string
    description?: StringNullableFilter<"CharacterKnowledge"> | string | null
    proficiency?: IntFilter<"CharacterKnowledge"> | number
    learnedAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    teacherNpcId?: StringNullableFilter<"CharacterKnowledge"> | string | null
    createdAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterKnowledge"> | Date | string
  }

  export type CharacterSkillUpsertWithWhereUniqueWithoutGameCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    update: XOR<CharacterSkillUpdateWithoutGameCharacterInput, CharacterSkillUncheckedUpdateWithoutGameCharacterInput>
    create: XOR<CharacterSkillCreateWithoutGameCharacterInput, CharacterSkillUncheckedCreateWithoutGameCharacterInput>
  }

  export type CharacterSkillUpdateWithWhereUniqueWithoutGameCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    data: XOR<CharacterSkillUpdateWithoutGameCharacterInput, CharacterSkillUncheckedUpdateWithoutGameCharacterInput>
  }

  export type CharacterSkillUpdateManyWithWhereWithoutGameCharacterInput = {
    where: CharacterSkillScalarWhereInput
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyWithoutGameCharacterInput>
  }

  export type CharacterSkillScalarWhereInput = {
    AND?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    OR?: CharacterSkillScalarWhereInput[]
    NOT?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    characterId?: StringFilter<"CharacterSkill"> | string
    skillType?: StringFilter<"CharacterSkill"> | string
    experience?: IntFilter<"CharacterSkill"> | number
    level?: StringFilter<"CharacterSkill"> | string
    unlockedAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    lastPracticed?: DateTimeNullableFilter<"CharacterSkill"> | Date | string | null
    createdAt?: DateTimeFilter<"CharacterSkill"> | Date | string
    updatedAt?: DateTimeFilter<"CharacterSkill"> | Date | string
  }

  export type UserUpsertWithoutGameCharactersInput = {
    update: XOR<UserUpdateWithoutGameCharactersInput, UserUncheckedUpdateWithoutGameCharactersInput>
    create: XOR<UserCreateWithoutGameCharactersInput, UserUncheckedCreateWithoutGameCharactersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameCharactersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameCharactersInput, UserUncheckedUpdateWithoutGameCharactersInput>
  }

  export type UserUpdateWithoutGameCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGameCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type JobChangeHistoryUpsertWithWhereUniqueWithoutGameCharactersInput = {
    where: JobChangeHistoryWhereUniqueInput
    update: XOR<JobChangeHistoryUpdateWithoutGameCharactersInput, JobChangeHistoryUncheckedUpdateWithoutGameCharactersInput>
    create: XOR<JobChangeHistoryCreateWithoutGameCharactersInput, JobChangeHistoryUncheckedCreateWithoutGameCharactersInput>
  }

  export type JobChangeHistoryUpdateWithWhereUniqueWithoutGameCharactersInput = {
    where: JobChangeHistoryWhereUniqueInput
    data: XOR<JobChangeHistoryUpdateWithoutGameCharactersInput, JobChangeHistoryUncheckedUpdateWithoutGameCharactersInput>
  }

  export type JobChangeHistoryUpdateManyWithWhereWithoutGameCharactersInput = {
    where: JobChangeHistoryScalarWhereInput
    data: XOR<JobChangeHistoryUpdateManyMutationInput, JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersInput>
  }

  export type JobChangeHistoryScalarWhereInput = {
    AND?: JobChangeHistoryScalarWhereInput | JobChangeHistoryScalarWhereInput[]
    OR?: JobChangeHistoryScalarWhereInput[]
    NOT?: JobChangeHistoryScalarWhereInput | JobChangeHistoryScalarWhereInput[]
    id?: StringFilter<"JobChangeHistory"> | string
    characterId?: StringFilter<"JobChangeHistory"> | string
    fromClass?: StringFilter<"JobChangeHistory"> | string
    toClass?: StringFilter<"JobChangeHistory"> | string
    changedAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    npcTrainerId?: StringFilter<"JobChangeHistory"> | string
    costPaid?: IntFilter<"JobChangeHistory"> | number
    levelAtChange?: IntFilter<"JobChangeHistory"> | number
    notes?: StringNullableFilter<"JobChangeHistory"> | string | null
    createdAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
    updatedAt?: DateTimeFilter<"JobChangeHistory"> | Date | string
  }

  export type MagicalStorageUpsertWithWhereUniqueWithoutGameCharacterInput = {
    where: MagicalStorageWhereUniqueInput
    update: XOR<MagicalStorageUpdateWithoutGameCharacterInput, MagicalStorageUncheckedUpdateWithoutGameCharacterInput>
    create: XOR<MagicalStorageCreateWithoutGameCharacterInput, MagicalStorageUncheckedCreateWithoutGameCharacterInput>
  }

  export type MagicalStorageUpdateWithWhereUniqueWithoutGameCharacterInput = {
    where: MagicalStorageWhereUniqueInput
    data: XOR<MagicalStorageUpdateWithoutGameCharacterInput, MagicalStorageUncheckedUpdateWithoutGameCharacterInput>
  }

  export type MagicalStorageUpdateManyWithWhereWithoutGameCharacterInput = {
    where: MagicalStorageScalarWhereInput
    data: XOR<MagicalStorageUpdateManyMutationInput, MagicalStorageUncheckedUpdateManyWithoutGameCharacterInput>
  }

  export type MagicalStorageScalarWhereInput = {
    AND?: MagicalStorageScalarWhereInput | MagicalStorageScalarWhereInput[]
    OR?: MagicalStorageScalarWhereInput[]
    NOT?: MagicalStorageScalarWhereInput | MagicalStorageScalarWhereInput[]
    id?: StringFilter<"MagicalStorage"> | string
    characterId?: StringFilter<"MagicalStorage"> | string
    itemId?: StringFilter<"MagicalStorage"> | string
    quantity?: IntFilter<"MagicalStorage"> | number
    quality?: StringFilter<"MagicalStorage"> | string
    manaUsed?: FloatFilter<"MagicalStorage"> | number
    storedAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"MagicalStorage"> | Date | string | null
    createdAt?: DateTimeFilter<"MagicalStorage"> | Date | string
    updatedAt?: DateTimeFilter<"MagicalStorage"> | Date | string
  }

  export type PlayerInventoryUpsertWithWhereUniqueWithoutGame_charactersInput = {
    where: PlayerInventoryWhereUniqueInput
    update: XOR<PlayerInventoryUpdateWithoutGame_charactersInput, PlayerInventoryUncheckedUpdateWithoutGame_charactersInput>
    create: XOR<PlayerInventoryCreateWithoutGame_charactersInput, PlayerInventoryUncheckedCreateWithoutGame_charactersInput>
  }

  export type PlayerInventoryUpdateWithWhereUniqueWithoutGame_charactersInput = {
    where: PlayerInventoryWhereUniqueInput
    data: XOR<PlayerInventoryUpdateWithoutGame_charactersInput, PlayerInventoryUncheckedUpdateWithoutGame_charactersInput>
  }

  export type PlayerInventoryUpdateManyWithWhereWithoutGame_charactersInput = {
    where: PlayerInventoryScalarWhereInput
    data: XOR<PlayerInventoryUpdateManyMutationInput, PlayerInventoryUncheckedUpdateManyWithoutGame_charactersInput>
  }

  export type PlayerInventoryScalarWhereInput = {
    AND?: PlayerInventoryScalarWhereInput | PlayerInventoryScalarWhereInput[]
    OR?: PlayerInventoryScalarWhereInput[]
    NOT?: PlayerInventoryScalarWhereInput | PlayerInventoryScalarWhereInput[]
    id?: StringFilter<"PlayerInventory"> | string
    character_id?: StringFilter<"PlayerInventory"> | string
    item_id?: StringFilter<"PlayerInventory"> | string
    quantity?: IntFilter<"PlayerInventory"> | number
    quality?: StringFilter<"PlayerInventory"> | string
    weight?: FloatFilter<"PlayerInventory"> | number
    totalWeight?: FloatFilter<"PlayerInventory"> | number
    volume?: FloatFilter<"PlayerInventory"> | number
    totalVolume?: FloatFilter<"PlayerInventory"> | number
    slot?: IntNullableFilter<"PlayerInventory"> | number | null
    is_equipped?: BoolFilter<"PlayerInventory"> | boolean
    equipment_slot?: StringNullableFilter<"PlayerInventory"> | string | null
    condition?: FloatFilter<"PlayerInventory"> | number
    is_stackable?: BoolFilter<"PlayerInventory"> | boolean
    max_stack?: IntFilter<"PlayerInventory"> | number
    acquired_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    last_used_at?: DateTimeNullableFilter<"PlayerInventory"> | Date | string | null
    created_at?: DateTimeFilter<"PlayerInventory"> | Date | string
    updated_at?: DateTimeFilter<"PlayerInventory"> | Date | string
  }

  export type GameCharacterCreateWithoutJobChangeHistoryInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateWithoutJobChangeHistoryInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterCreateOrConnectWithoutJobChangeHistoryInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutJobChangeHistoryInput, GameCharacterUncheckedCreateWithoutJobChangeHistoryInput>
  }

  export type GameCharacterUpsertWithoutJobChangeHistoryInput = {
    update: XOR<GameCharacterUpdateWithoutJobChangeHistoryInput, GameCharacterUncheckedUpdateWithoutJobChangeHistoryInput>
    create: XOR<GameCharacterCreateWithoutJobChangeHistoryInput, GameCharacterUncheckedCreateWithoutJobChangeHistoryInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutJobChangeHistoryInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutJobChangeHistoryInput, GameCharacterUncheckedUpdateWithoutJobChangeHistoryInput>
  }

  export type GameCharacterUpdateWithoutJobChangeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutJobChangeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type LoanCreateWithoutLoanPaymentsInput = {
    id?: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bankAccounts: BankAccountCreateNestedOneWithoutLoansInput
  }

  export type LoanUncheckedCreateWithoutLoanPaymentsInput = {
    id?: string
    bankAccountId: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateOrConnectWithoutLoanPaymentsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutLoanPaymentsInput, LoanUncheckedCreateWithoutLoanPaymentsInput>
  }

  export type LoanUpsertWithoutLoanPaymentsInput = {
    update: XOR<LoanUpdateWithoutLoanPaymentsInput, LoanUncheckedUpdateWithoutLoanPaymentsInput>
    create: XOR<LoanCreateWithoutLoanPaymentsInput, LoanUncheckedCreateWithoutLoanPaymentsInput>
    where?: LoanWhereInput
  }

  export type LoanUpdateToOneWithWhereWithoutLoanPaymentsInput = {
    where?: LoanWhereInput
    data: XOR<LoanUpdateWithoutLoanPaymentsInput, LoanUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type LoanUpdateWithoutLoanPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccounts?: BankAccountUpdateOneRequiredWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateWithoutLoanPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankAccountId?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateWithoutLoansInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    principalPaid: number
    interestPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanPaymentUncheckedCreateWithoutLoansInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    principalPaid: number
    interestPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanPaymentCreateOrConnectWithoutLoansInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutLoansInput, LoanPaymentUncheckedCreateWithoutLoansInput>
  }

  export type LoanPaymentCreateManyLoansInputEnvelope = {
    data: LoanPaymentCreateManyLoansInput | LoanPaymentCreateManyLoansInput[]
    skipDuplicates?: boolean
  }

  export type BankAccountCreateWithoutLoansInput = {
    id?: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutBankAccountsInput
    bankTransactions?: BankTransactionCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateWithoutLoansInput = {
    id?: string
    characterId: string
    accountType?: string
    balance?: number
    creditScore?: number
    creditLimit?: number
    interestRate?: number
    accountStatus?: string
    openedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    bankTransactions?: BankTransactionUncheckedCreateNestedManyWithoutBankAccountInput
  }

  export type BankAccountCreateOrConnectWithoutLoansInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutLoansInput, BankAccountUncheckedCreateWithoutLoansInput>
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutLoansInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutLoansInput, LoanPaymentUncheckedUpdateWithoutLoansInput>
    create: XOR<LoanPaymentCreateWithoutLoansInput, LoanPaymentUncheckedCreateWithoutLoansInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutLoansInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutLoansInput, LoanPaymentUncheckedUpdateWithoutLoansInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutLoansInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutLoansInput>
  }

  export type LoanPaymentScalarWhereInput = {
    AND?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
    OR?: LoanPaymentScalarWhereInput[]
    NOT?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
    id?: StringFilter<"LoanPayment"> | string
    loanId?: StringFilter<"LoanPayment"> | string
    amount?: FloatFilter<"LoanPayment"> | number
    paymentDate?: DateTimeFilter<"LoanPayment"> | Date | string
    principalPaid?: FloatFilter<"LoanPayment"> | number
    interestPaid?: FloatFilter<"LoanPayment"> | number
    createdAt?: DateTimeFilter<"LoanPayment"> | Date | string
    updatedAt?: DateTimeFilter<"LoanPayment"> | Date | string
  }

  export type BankAccountUpsertWithoutLoansInput = {
    update: XOR<BankAccountUpdateWithoutLoansInput, BankAccountUncheckedUpdateWithoutLoansInput>
    create: XOR<BankAccountCreateWithoutLoansInput, BankAccountUncheckedCreateWithoutLoansInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutLoansInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutLoansInput, BankAccountUncheckedUpdateWithoutLoansInput>
  }

  export type BankAccountUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutBankAccountsNestedInput
    bankTransactions?: BankTransactionUpdateManyWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    creditScore?: IntFieldUpdateOperationsInput | number
    creditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    accountStatus?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankTransactions?: BankTransactionUncheckedUpdateManyWithoutBankAccountNestedInput
  }

  export type GameCharacterCreateWithoutMagicalStorageInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateWithoutMagicalStorageInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterCreateOrConnectWithoutMagicalStorageInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutMagicalStorageInput, GameCharacterUncheckedCreateWithoutMagicalStorageInput>
  }

  export type GameCharacterUpsertWithoutMagicalStorageInput = {
    update: XOR<GameCharacterUpdateWithoutMagicalStorageInput, GameCharacterUncheckedUpdateWithoutMagicalStorageInput>
    create: XOR<GameCharacterCreateWithoutMagicalStorageInput, GameCharacterUncheckedCreateWithoutMagicalStorageInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutMagicalStorageInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutMagicalStorageInput, GameCharacterUncheckedUpdateWithoutMagicalStorageInput>
  }

  export type GameCharacterUpdateWithoutMagicalStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutMagicalStorageInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterCreateWithoutPlayerInventoriesInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    user: UserCreateNestedOneWithoutGameCharactersInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
  }

  export type GameCharacterUncheckedCreateWithoutPlayerInventoriesInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
  }

  export type GameCharacterCreateOrConnectWithoutPlayerInventoriesInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutPlayerInventoriesInput, GameCharacterUncheckedCreateWithoutPlayerInventoriesInput>
  }

  export type GameCharacterUpsertWithoutPlayerInventoriesInput = {
    update: XOR<GameCharacterUpdateWithoutPlayerInventoriesInput, GameCharacterUncheckedUpdateWithoutPlayerInventoriesInput>
    create: XOR<GameCharacterCreateWithoutPlayerInventoriesInput, GameCharacterUncheckedCreateWithoutPlayerInventoriesInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutPlayerInventoriesInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutPlayerInventoriesInput, GameCharacterUncheckedUpdateWithoutPlayerInventoriesInput>
  }

  export type GameCharacterUpdateWithoutPlayerInventoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    user?: UserUpdateOneRequiredWithoutGameCharactersNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutPlayerInventoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
  }

  export type UserCreateWithoutSessionInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CharacterSkillCreateWithoutSkillPracticeHistoryInput = {
    id?: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gameCharacter: GameCharacterCreateNestedOneWithoutCharacterSkillsInput
  }

  export type CharacterSkillUncheckedCreateWithoutSkillPracticeHistoryInput = {
    id?: string
    characterId: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterSkillCreateOrConnectWithoutSkillPracticeHistoryInput = {
    where: CharacterSkillWhereUniqueInput
    create: XOR<CharacterSkillCreateWithoutSkillPracticeHistoryInput, CharacterSkillUncheckedCreateWithoutSkillPracticeHistoryInput>
  }

  export type CharacterSkillUpsertWithoutSkillPracticeHistoryInput = {
    update: XOR<CharacterSkillUpdateWithoutSkillPracticeHistoryInput, CharacterSkillUncheckedUpdateWithoutSkillPracticeHistoryInput>
    create: XOR<CharacterSkillCreateWithoutSkillPracticeHistoryInput, CharacterSkillUncheckedCreateWithoutSkillPracticeHistoryInput>
    where?: CharacterSkillWhereInput
  }

  export type CharacterSkillUpdateToOneWithWhereWithoutSkillPracticeHistoryInput = {
    where?: CharacterSkillWhereInput
    data: XOR<CharacterSkillUpdateWithoutSkillPracticeHistoryInput, CharacterSkillUncheckedUpdateWithoutSkillPracticeHistoryInput>
  }

  export type CharacterSkillUpdateWithoutSkillPracticeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameCharacter?: GameCharacterUpdateOneRequiredWithoutCharacterSkillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateWithoutSkillPracticeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameCharacterCreateWithoutUserInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterUncheckedCreateWithoutUserInput = {
    id?: string
    characterName: string
    level?: number
    experience?: number
    health?: number
    maxHealth?: number
    mana?: number
    maxMana?: number
    strength?: number
    dexterity?: number
    intelligence?: number
    vitality?: number
    luck?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    availableStatPoints?: number
    baseCarryingCapacity?: number
    carryingCapacity?: number
    characterClass?: string
    currentMapLocation?: string
    currentVolume?: number
    currentWeight?: number
    equippedArmor?: string | null
    equippedBackpack?: string | null
    equippedWeapon?: string | null
    goldAmount?: number
    isResting?: boolean
    lastSaveTimestamp?: Date | string
    lastStaminaUpdate?: Date | string
    magicalStorageCapacity?: number
    magicalStorageUsed?: number
    maxStamina?: number
    maxVolume?: number
    movementPenalty?: number
    positionX?: number
    positionY?: number
    restStartTime?: Date | string | null
    stamina?: number
    staminaRegenRate?: number
    baseStamina?: number
    equippedGloves?: string | null
    equippedPants?: string | null
    equippedShield?: string | null
    equippedShirt?: string | null
    equippedShoes?: string | null
    luckPercentage?: number
    bankAccounts?: BankAccountUncheckedCreateNestedOneWithoutGameCharacterInput
    characterKnowledges?: CharacterKnowledgeUncheckedCreateNestedManyWithoutGameCharacterInput
    characterSkills?: CharacterSkillUncheckedCreateNestedManyWithoutGameCharacterInput
    jobChangeHistory?: JobChangeHistoryUncheckedCreateNestedManyWithoutGameCharactersInput
    magicalStorage?: MagicalStorageUncheckedCreateNestedManyWithoutGameCharacterInput
    playerInventories?: PlayerInventoryUncheckedCreateNestedManyWithoutGame_charactersInput
  }

  export type GameCharacterCreateOrConnectWithoutUserInput = {
    where: GameCharacterWhereUniqueInput
    create: XOR<GameCharacterCreateWithoutUserInput, GameCharacterUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserEmailCreateWithoutUserInput = {
    id?: string
    email: string
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserEmailCreateOrConnectWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    create: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput>
  }

  export type UserEmailCreateManyUserInputEnvelope = {
    data: UserEmailCreateManyUserInput | UserEmailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    location?: string | null
    motto?: string | null
    title?: string | null
    phone?: string | null
    website?: string | null
    discordTag?: string | null
    githubUrl?: string | null
    facebookUrl?: string | null
    instagramUrl?: string | null
    xUrl?: string | null
    linkedinUrl?: string | null
    snapchatUrl?: string | null
    favoriteClass?: string | null
    playStyle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    location?: string | null
    motto?: string | null
    title?: string | null
    phone?: string | null
    website?: string | null
    discordTag?: string | null
    githubUrl?: string | null
    facebookUrl?: string | null
    instagramUrl?: string | null
    xUrl?: string | null
    linkedinUrl?: string | null
    snapchatUrl?: string | null
    favoriteClass?: string | null
    playStyle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    cardColor?: string
    cardTheme?: string
    publicEmailChoice?: string | null
    theme?: string
    language?: string
    pinnedForums?: UserSettingsCreatepinnedForumsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isProfilePublic?: boolean
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    cardColor?: string
    cardTheme?: string
    publicEmailChoice?: string | null
    theme?: string
    language?: string
    pinnedForums?: UserSettingsCreatepinnedForumsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isProfilePublic?: boolean
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserPresenceCreateWithoutUserInput = {
    isOnline?: boolean
    lastSeen?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserPresenceUncheckedCreateWithoutUserInput = {
    isOnline?: boolean
    lastSeen?: Date | string | null
    updatedAt?: Date | string
  }

  export type UserPresenceCreateOrConnectWithoutUserInput = {
    where: UserPresenceWhereUniqueInput
    create: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type GameCharacterUpsertWithoutUserInput = {
    update: XOR<GameCharacterUpdateWithoutUserInput, GameCharacterUncheckedUpdateWithoutUserInput>
    create: XOR<GameCharacterCreateWithoutUserInput, GameCharacterUncheckedCreateWithoutUserInput>
    where?: GameCharacterWhereInput
  }

  export type GameCharacterUpdateToOneWithWhereWithoutUserInput = {
    where?: GameCharacterWhereInput
    data: XOR<GameCharacterUpdateWithoutUserInput, GameCharacterUncheckedUpdateWithoutUserInput>
  }

  export type GameCharacterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUpdateManyWithoutGame_charactersNestedInput
  }

  export type GameCharacterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    maxHealth?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    maxMana?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    vitality?: IntFieldUpdateOperationsInput | number
    luck?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableStatPoints?: IntFieldUpdateOperationsInput | number
    baseCarryingCapacity?: FloatFieldUpdateOperationsInput | number
    carryingCapacity?: FloatFieldUpdateOperationsInput | number
    characterClass?: StringFieldUpdateOperationsInput | string
    currentMapLocation?: StringFieldUpdateOperationsInput | string
    currentVolume?: FloatFieldUpdateOperationsInput | number
    currentWeight?: FloatFieldUpdateOperationsInput | number
    equippedArmor?: NullableStringFieldUpdateOperationsInput | string | null
    equippedBackpack?: NullableStringFieldUpdateOperationsInput | string | null
    equippedWeapon?: NullableStringFieldUpdateOperationsInput | string | null
    goldAmount?: IntFieldUpdateOperationsInput | number
    isResting?: BoolFieldUpdateOperationsInput | boolean
    lastSaveTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    lastStaminaUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    magicalStorageCapacity?: FloatFieldUpdateOperationsInput | number
    magicalStorageUsed?: FloatFieldUpdateOperationsInput | number
    maxStamina?: FloatFieldUpdateOperationsInput | number
    maxVolume?: FloatFieldUpdateOperationsInput | number
    movementPenalty?: FloatFieldUpdateOperationsInput | number
    positionX?: FloatFieldUpdateOperationsInput | number
    positionY?: FloatFieldUpdateOperationsInput | number
    restStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stamina?: FloatFieldUpdateOperationsInput | number
    staminaRegenRate?: FloatFieldUpdateOperationsInput | number
    baseStamina?: IntFieldUpdateOperationsInput | number
    equippedGloves?: NullableStringFieldUpdateOperationsInput | string | null
    equippedPants?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShield?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShirt?: NullableStringFieldUpdateOperationsInput | string | null
    equippedShoes?: NullableStringFieldUpdateOperationsInput | string | null
    luckPercentage?: FloatFieldUpdateOperationsInput | number
    bankAccounts?: BankAccountUncheckedUpdateOneWithoutGameCharacterNestedInput
    characterKnowledges?: CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterNestedInput
    characterSkills?: CharacterSkillUncheckedUpdateManyWithoutGameCharacterNestedInput
    jobChangeHistory?: JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersNestedInput
    magicalStorage?: MagicalStorageUncheckedUpdateManyWithoutGameCharacterNestedInput
    playerInventories?: PlayerInventoryUncheckedUpdateManyWithoutGame_charactersNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type UserEmailUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    update: XOR<UserEmailUpdateWithoutUserInput, UserEmailUncheckedUpdateWithoutUserInput>
    create: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput>
  }

  export type UserEmailUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    data: XOR<UserEmailUpdateWithoutUserInput, UserEmailUncheckedUpdateWithoutUserInput>
  }

  export type UserEmailUpdateManyWithWhereWithoutUserInput = {
    where: UserEmailScalarWhereInput
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyWithoutUserInput>
  }

  export type UserEmailScalarWhereInput = {
    AND?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
    OR?: UserEmailScalarWhereInput[]
    NOT?: UserEmailScalarWhereInput | UserEmailScalarWhereInput[]
    id?: StringFilter<"UserEmail"> | string
    userId?: StringFilter<"UserEmail"> | string
    email?: StringFilter<"UserEmail"> | string
    label?: StringNullableFilter<"UserEmail"> | string | null
    createdAt?: DateTimeFilter<"UserEmail"> | Date | string
    updatedAt?: DateTimeFilter<"UserEmail"> | Date | string
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discordTag?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatUrl?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteClass?: NullableStringFieldUpdateOperationsInput | string | null
    playStyle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    motto?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discordTag?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    facebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatUrl?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteClass?: NullableStringFieldUpdateOperationsInput | string | null
    playStyle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardColor?: StringFieldUpdateOperationsInput | string
    cardTheme?: StringFieldUpdateOperationsInput | string
    publicEmailChoice?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    pinnedForums?: UserSettingsUpdatepinnedForumsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardColor?: StringFieldUpdateOperationsInput | string
    cardTheme?: StringFieldUpdateOperationsInput | string
    publicEmailChoice?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    pinnedForums?: UserSettingsUpdatepinnedForumsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isProfilePublic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPresenceUpsertWithoutUserInput = {
    update: XOR<UserPresenceUpdateWithoutUserInput, UserPresenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    where?: UserPresenceWhereInput
  }

  export type UserPresenceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPresenceWhereInput
    data: XOR<UserPresenceUpdateWithoutUserInput, UserPresenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPresenceUpdateWithoutUserInput = {
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceUncheckedUpdateWithoutUserInput = {
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserEmailsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserEmailsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserEmailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserEmailsInput, UserUncheckedCreateWithoutUserEmailsInput>
  }

  export type UserUpsertWithoutUserEmailsInput = {
    update: XOR<UserUpdateWithoutUserEmailsInput, UserUncheckedUpdateWithoutUserEmailsInput>
    create: XOR<UserCreateWithoutUserEmailsInput, UserUncheckedCreateWithoutUserEmailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserEmailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserEmailsInput, UserUncheckedUpdateWithoutUserEmailsInput>
  }

  export type UserUpdateWithoutUserEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUserProfileInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProfileInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpsertWithoutUserProfileInput = {
    update: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUserSettingsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userPresence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserUpsertWithoutUserSettingsInput = {
    update: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userPresence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutUserPresenceInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterCreateNestedOneWithoutUserInput
    session?: SessionCreateNestedManyWithoutUserInput
    userEmails?: UserEmailCreateNestedManyWithoutUserInput
    userProfile?: UserProfileCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPresenceInput = {
    id?: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    account?: AccountUncheckedCreateNestedManyWithoutUserInput
    gameCharacters?: GameCharacterUncheckedCreateNestedOneWithoutUserInput
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    userEmails?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPresenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPresenceInput, UserUncheckedCreateWithoutUserPresenceInput>
  }

  export type UserUpsertWithoutUserPresenceInput = {
    update: XOR<UserUpdateWithoutUserPresenceInput, UserUncheckedUpdateWithoutUserPresenceInput>
    create: XOR<UserCreateWithoutUserPresenceInput, UserUncheckedCreateWithoutUserPresenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPresenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPresenceInput, UserUncheckedUpdateWithoutUserPresenceInput>
  }

  export type UserUpdateWithoutUserPresenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUpdateOneWithoutUserNestedInput
    session?: SessionUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPresenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUncheckedUpdateManyWithoutUserNestedInput
    gameCharacters?: GameCharacterUncheckedUpdateOneWithoutUserNestedInput
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    userEmails?: UserEmailUncheckedUpdateManyWithoutUserNestedInput
    userProfile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPostInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeCreateManyPostInputEnvelope = {
    data: LikeCreateManyPostInput | LikeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
    create: XOR<LikeCreateWithoutPostInput, LikeUncheckedCreateWithoutPostInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostInput, LikeUncheckedUpdateWithoutPostInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    postId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutLikesInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLikesInput = {
    id?: string
    authorId: string
    title?: string | null
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
  }

  export type PostUpsertWithoutLikesInput = {
    update: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
    create: XOR<PostCreateWithoutLikesInput, PostUncheckedCreateWithoutLikesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutLikesInput, PostUncheckedUpdateWithoutLikesInput>
  }

  export type PostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumReplyCreateWithoutTopicInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ForumReplyLikeCreateNestedManyWithoutReplyInput
  }

  export type ForumReplyUncheckedCreateWithoutTopicInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ForumReplyLikeUncheckedCreateNestedManyWithoutReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutTopicInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput>
  }

  export type ForumReplyCreateManyTopicInputEnvelope = {
    data: ForumReplyCreateManyTopicInput | ForumReplyCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ForumTopicLikeCreateWithoutTopicInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumTopicLikeUncheckedCreateWithoutTopicInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumTopicLikeCreateOrConnectWithoutTopicInput = {
    where: ForumTopicLikeWhereUniqueInput
    create: XOR<ForumTopicLikeCreateWithoutTopicInput, ForumTopicLikeUncheckedCreateWithoutTopicInput>
  }

  export type ForumTopicLikeCreateManyTopicInputEnvelope = {
    data: ForumTopicLikeCreateManyTopicInput | ForumTopicLikeCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ForumReplyUpsertWithWhereUniqueWithoutTopicInput = {
    where: ForumReplyWhereUniqueInput
    update: XOR<ForumReplyUpdateWithoutTopicInput, ForumReplyUncheckedUpdateWithoutTopicInput>
    create: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput>
  }

  export type ForumReplyUpdateWithWhereUniqueWithoutTopicInput = {
    where: ForumReplyWhereUniqueInput
    data: XOR<ForumReplyUpdateWithoutTopicInput, ForumReplyUncheckedUpdateWithoutTopicInput>
  }

  export type ForumReplyUpdateManyWithWhereWithoutTopicInput = {
    where: ForumReplyScalarWhereInput
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyWithoutTopicInput>
  }

  export type ForumReplyScalarWhereInput = {
    AND?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
    OR?: ForumReplyScalarWhereInput[]
    NOT?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
    id?: StringFilter<"ForumReply"> | string
    topicId?: StringFilter<"ForumReply"> | string
    content?: StringFilter<"ForumReply"> | string
    authorId?: StringFilter<"ForumReply"> | string
    createdAt?: DateTimeFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeFilter<"ForumReply"> | Date | string
  }

  export type ForumTopicLikeUpsertWithWhereUniqueWithoutTopicInput = {
    where: ForumTopicLikeWhereUniqueInput
    update: XOR<ForumTopicLikeUpdateWithoutTopicInput, ForumTopicLikeUncheckedUpdateWithoutTopicInput>
    create: XOR<ForumTopicLikeCreateWithoutTopicInput, ForumTopicLikeUncheckedCreateWithoutTopicInput>
  }

  export type ForumTopicLikeUpdateWithWhereUniqueWithoutTopicInput = {
    where: ForumTopicLikeWhereUniqueInput
    data: XOR<ForumTopicLikeUpdateWithoutTopicInput, ForumTopicLikeUncheckedUpdateWithoutTopicInput>
  }

  export type ForumTopicLikeUpdateManyWithWhereWithoutTopicInput = {
    where: ForumTopicLikeScalarWhereInput
    data: XOR<ForumTopicLikeUpdateManyMutationInput, ForumTopicLikeUncheckedUpdateManyWithoutTopicInput>
  }

  export type ForumTopicLikeScalarWhereInput = {
    AND?: ForumTopicLikeScalarWhereInput | ForumTopicLikeScalarWhereInput[]
    OR?: ForumTopicLikeScalarWhereInput[]
    NOT?: ForumTopicLikeScalarWhereInput | ForumTopicLikeScalarWhereInput[]
    id?: StringFilter<"ForumTopicLike"> | string
    topicId?: StringFilter<"ForumTopicLike"> | string
    userId?: StringFilter<"ForumTopicLike"> | string
    createdAt?: DateTimeFilter<"ForumTopicLike"> | Date | string
  }

  export type ForumTopicCreateWithoutRepliesInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ForumTopicLikeCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateWithoutRepliesInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ForumTopicLikeUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicCreateOrConnectWithoutRepliesInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
  }

  export type ForumReplyLikeCreateWithoutReplyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumReplyLikeUncheckedCreateWithoutReplyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumReplyLikeCreateOrConnectWithoutReplyInput = {
    where: ForumReplyLikeWhereUniqueInput
    create: XOR<ForumReplyLikeCreateWithoutReplyInput, ForumReplyLikeUncheckedCreateWithoutReplyInput>
  }

  export type ForumReplyLikeCreateManyReplyInputEnvelope = {
    data: ForumReplyLikeCreateManyReplyInput | ForumReplyLikeCreateManyReplyInput[]
    skipDuplicates?: boolean
  }

  export type ForumTopicUpsertWithoutRepliesInput = {
    update: XOR<ForumTopicUpdateWithoutRepliesInput, ForumTopicUncheckedUpdateWithoutRepliesInput>
    create: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
    where?: ForumTopicWhereInput
  }

  export type ForumTopicUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ForumTopicWhereInput
    data: XOR<ForumTopicUpdateWithoutRepliesInput, ForumTopicUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumTopicUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ForumTopicLikeUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ForumTopicLikeUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumReplyLikeUpsertWithWhereUniqueWithoutReplyInput = {
    where: ForumReplyLikeWhereUniqueInput
    update: XOR<ForumReplyLikeUpdateWithoutReplyInput, ForumReplyLikeUncheckedUpdateWithoutReplyInput>
    create: XOR<ForumReplyLikeCreateWithoutReplyInput, ForumReplyLikeUncheckedCreateWithoutReplyInput>
  }

  export type ForumReplyLikeUpdateWithWhereUniqueWithoutReplyInput = {
    where: ForumReplyLikeWhereUniqueInput
    data: XOR<ForumReplyLikeUpdateWithoutReplyInput, ForumReplyLikeUncheckedUpdateWithoutReplyInput>
  }

  export type ForumReplyLikeUpdateManyWithWhereWithoutReplyInput = {
    where: ForumReplyLikeScalarWhereInput
    data: XOR<ForumReplyLikeUpdateManyMutationInput, ForumReplyLikeUncheckedUpdateManyWithoutReplyInput>
  }

  export type ForumReplyLikeScalarWhereInput = {
    AND?: ForumReplyLikeScalarWhereInput | ForumReplyLikeScalarWhereInput[]
    OR?: ForumReplyLikeScalarWhereInput[]
    NOT?: ForumReplyLikeScalarWhereInput | ForumReplyLikeScalarWhereInput[]
    id?: StringFilter<"ForumReplyLike"> | string
    replyId?: StringFilter<"ForumReplyLike"> | string
    userId?: StringFilter<"ForumReplyLike"> | string
    createdAt?: DateTimeFilter<"ForumReplyLike"> | Date | string
  }

  export type ForumTopicCreateWithoutLikesInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumReplyCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateWithoutLikesInput = {
    id?: string
    forumId: $Enums.ForumCategory
    title: string
    content: string
    type?: $Enums.TopicType
    tags?: ForumTopicCreatetagsInput | string[]
    authorId: string
    views?: number
    isPinned?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumReplyUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicCreateOrConnectWithoutLikesInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutLikesInput, ForumTopicUncheckedCreateWithoutLikesInput>
  }

  export type ForumTopicUpsertWithoutLikesInput = {
    update: XOR<ForumTopicUpdateWithoutLikesInput, ForumTopicUncheckedUpdateWithoutLikesInput>
    create: XOR<ForumTopicCreateWithoutLikesInput, ForumTopicUncheckedCreateWithoutLikesInput>
    where?: ForumTopicWhereInput
  }

  export type ForumTopicUpdateToOneWithWhereWithoutLikesInput = {
    where?: ForumTopicWhereInput
    data: XOR<ForumTopicUpdateWithoutLikesInput, ForumTopicUncheckedUpdateWithoutLikesInput>
  }

  export type ForumTopicUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumReplyUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: EnumForumCategoryFieldUpdateOperationsInput | $Enums.ForumCategory
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    tags?: ForumTopicUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumReplyUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumReplyCreateWithoutLikesInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
  }

  export type ForumReplyUncheckedCreateWithoutLikesInput = {
    id?: string
    topicId: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyCreateOrConnectWithoutLikesInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutLikesInput, ForumReplyUncheckedCreateWithoutLikesInput>
  }

  export type ForumReplyUpsertWithoutLikesInput = {
    update: XOR<ForumReplyUpdateWithoutLikesInput, ForumReplyUncheckedUpdateWithoutLikesInput>
    create: XOR<ForumReplyCreateWithoutLikesInput, ForumReplyUncheckedCreateWithoutLikesInput>
    where?: ForumReplyWhereInput
  }

  export type ForumReplyUpdateToOneWithWhereWithoutLikesInput = {
    where?: ForumReplyWhereInput
    data: XOR<ForumReplyUpdateWithoutLikesInput, ForumReplyUncheckedUpdateWithoutLikesInput>
  }

  export type ForumReplyUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyBankAccountInput = {
    id?: string
    transactionType: string
    amount: number
    balanceAfter: number
    description?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateManyBankAccountsInput = {
    id?: string
    principalAmount: number
    interestRate: number
    termMonths: number
    monthlyPayment: number
    remainingBalance: number
    status?: string
    loanPurpose: string
    nextPaymentDue?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankTransactionUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutBankAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    balanceAfter?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUpdateManyWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanPayments?: LoanPaymentUncheckedUpdateManyWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateManyWithoutBankAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    principalAmount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    termMonths?: IntFieldUpdateOperationsInput | number
    monthlyPayment?: FloatFieldUpdateOperationsInput | number
    remainingBalance?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    loanPurpose?: StringFieldUpdateOperationsInput | string
    nextPaymentDue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPracticeHistoryCreateManyCharacter_skillsInput = {
    id?: string
    practice_type: string
    practice_intensity: string
    experience_gained: number
    proficiency_gained: number
    knowledge_used?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SkillPracticeHistoryUpdateWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPracticeHistoryUncheckedUpdateWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillPracticeHistoryUncheckedUpdateManyWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    practice_type?: StringFieldUpdateOperationsInput | string
    practice_intensity?: StringFieldUpdateOperationsInput | string
    experience_gained?: IntFieldUpdateOperationsInput | number
    proficiency_gained?: IntFieldUpdateOperationsInput | number
    knowledge_used?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterKnowledgeCreateManyGameCharacterInput = {
    id?: string
    skillType: string
    knowledgeType: string
    knowledgeName: string
    description?: string | null
    proficiency?: number
    learnedAt?: Date | string
    teacherNpcId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterSkillCreateManyGameCharacterInput = {
    id?: string
    skillType: string
    experience?: number
    level?: string
    unlockedAt?: Date | string
    lastPracticed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobChangeHistoryCreateManyGameCharactersInput = {
    id?: string
    fromClass: string
    toClass: string
    changedAt?: Date | string
    npcTrainerId: string
    costPaid: number
    levelAtChange: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicalStorageCreateManyGameCharacterInput = {
    id?: string
    itemId: string
    quantity?: number
    quality?: string
    manaUsed: number
    storedAt?: Date | string
    lastAccessedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerInventoryCreateManyGame_charactersInput = {
    id?: string
    item_id: string
    quantity?: number
    quality?: string
    weight: number
    totalWeight: number
    volume: number
    totalVolume: number
    slot?: number | null
    is_equipped?: boolean
    equipment_slot?: string | null
    condition?: number
    is_stackable?: boolean
    max_stack?: number
    acquired_at?: Date | string
    last_used_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CharacterKnowledgeUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterKnowledgeUncheckedUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterKnowledgeUncheckedUpdateManyWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    knowledgeType?: StringFieldUpdateOperationsInput | string
    knowledgeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    proficiency?: IntFieldUpdateOperationsInput | number
    learnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterSkillUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillPracticeHistory?: SkillPracticeHistoryUpdateManyWithoutCharacter_skillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillPracticeHistory?: SkillPracticeHistoryUncheckedUpdateManyWithoutCharacter_skillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateManyWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillType?: StringFieldUpdateOperationsInput | string
    experience?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobChangeHistoryUpdateWithoutGameCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobChangeHistoryUncheckedUpdateWithoutGameCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobChangeHistoryUncheckedUpdateManyWithoutGameCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromClass?: StringFieldUpdateOperationsInput | string
    toClass?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcTrainerId?: StringFieldUpdateOperationsInput | string
    costPaid?: IntFieldUpdateOperationsInput | number
    levelAtChange?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicalStorageUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicalStorageUncheckedUpdateWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicalStorageUncheckedUpdateManyWithoutGameCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    manaUsed?: FloatFieldUpdateOperationsInput | number
    storedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerInventoryUpdateWithoutGame_charactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerInventoryUncheckedUpdateWithoutGame_charactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerInventoryUncheckedUpdateManyWithoutGame_charactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    totalWeight?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    totalVolume?: FloatFieldUpdateOperationsInput | number
    slot?: NullableIntFieldUpdateOperationsInput | number | null
    is_equipped?: BoolFieldUpdateOperationsInput | boolean
    equipment_slot?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: FloatFieldUpdateOperationsInput | number
    is_stackable?: BoolFieldUpdateOperationsInput | boolean
    max_stack?: IntFieldUpdateOperationsInput | number
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateManyLoansInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    principalPaid: number
    interestPaid: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanPaymentUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    principalPaid?: FloatFieldUpdateOperationsInput | number
    interestPaid?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type UserEmailCreateManyUserInput = {
    id?: string
    email: string
    label?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserEmailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEmailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyCreateManyTopicInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumTopicLikeCreateManyTopicInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumReplyUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ForumReplyLikeUpdateManyWithoutReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ForumReplyLikeUncheckedUpdateManyWithoutReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicLikeUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicLikeUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicLikeUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyLikeCreateManyReplyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ForumReplyLikeUpdateWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyLikeUncheckedUpdateWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyLikeUncheckedUpdateManyWithoutReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BankAccountCountOutputTypeDefaultArgs instead
     */
    export type BankAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterSkillCountOutputTypeDefaultArgs instead
     */
    export type CharacterSkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterSkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCharacterCountOutputTypeDefaultArgs instead
     */
    export type GameCharacterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCharacterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanCountOutputTypeDefaultArgs instead
     */
    export type LoanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumTopicCountOutputTypeDefaultArgs instead
     */
    export type ForumTopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumReplyCountOutputTypeDefaultArgs instead
     */
    export type ForumReplyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumReplyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankAccountDefaultArgs instead
     */
    export type BankAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankTransactionDefaultArgs instead
     */
    export type BankTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterKnowledgeDefaultArgs instead
     */
    export type CharacterKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterKnowledgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterSkillDefaultArgs instead
     */
    export type CharacterSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryQuestDefaultArgs instead
     */
    export type DeliveryQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryQuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCharacterDefaultArgs instead
     */
    export type GameCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobChangeHistoryDefaultArgs instead
     */
    export type JobChangeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobChangeHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanPaymentDefaultArgs instead
     */
    export type LoanPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanDefaultArgs instead
     */
    export type LoanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogisticsTrackingDefaultArgs instead
     */
    export type LogisticsTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogisticsTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MagicalStorageDefaultArgs instead
     */
    export type MagicalStorageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MagicalStorageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NpcDeliveryRouteDefaultArgs instead
     */
    export type NpcDeliveryRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NpcDeliveryRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthProvidersDefaultArgs instead
     */
    export type OAuthProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthProvidersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerInventoryDefaultArgs instead
     */
    export type PlayerInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerInventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDecayLogDefaultArgs instead
     */
    export type SkillDecayLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDecayLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillPracticeHistoryDefaultArgs instead
     */
    export type SkillPracticeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillPracticeHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserEmailDefaultArgs instead
     */
    export type UserEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserEmailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileDefaultArgs instead
     */
    export type UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingsDefaultArgs instead
     */
    export type UserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserPresenceDefaultArgs instead
     */
    export type UserPresenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserPresenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationDefaultArgs instead
     */
    export type VerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JwksDefaultArgs instead
     */
    export type JwksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JwksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendRequestDefaultArgs instead
     */
    export type FriendRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendshipDefaultArgs instead
     */
    export type FriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockedUserDefaultArgs instead
     */
    export type BlockedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockedUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumTopicDefaultArgs instead
     */
    export type ForumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumReplyDefaultArgs instead
     */
    export type ForumReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumTopicLikeDefaultArgs instead
     */
    export type ForumTopicLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumTopicLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumReplyLikeDefaultArgs instead
     */
    export type ForumReplyLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumReplyLikeDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}